00:00:00 - Yeah, I'm excited to be here.

00:00:02 - Yeah, it's great to have you here.

00:00:04 Oh, we get to talk about one of my favorite topics, MongoDB, I'm so excited.

00:00:08 - Yeah, my favorite topic, obviously too.

00:00:12 - Yeah, you definitely put a lot of time into it.

00:00:14 We're gonna talk about your ODM.

00:00:17 People often hear about ORMs, Object Relational Mappers, but traditionally, MongoDB and other document databases and those who can't read, and those who can't type, and other document databases and NoSQL databases haven't modeled things to relationships, it's more through documents.

00:00:34 So the D instead of R, ODM, Beanie, which is gonna be super fun, it brings together so many cool topics and even relationships.

00:00:43 So maybe if you really wanted, I guess you could put the R back in there as of recently.

00:00:48 Anyway, super fun topic on deck for us.

00:00:51 Before we get to that, let's just start with your story.

00:00:53 How'd you get into programming in Python?

00:00:55 - I started when I was a student, like more than 10 years ago now.

00:01:03 So, but I started not with Python.

00:01:04 I started, it was 2008, I think, 2007 probably.

00:01:09 I started with Flash and nobody knew that Flash will die soon.

00:01:14 - Flash was such a big thing when it was new.

00:01:17 I remember people were just completely getting amazing consulting jobs and building websites with Flash.

00:01:23 I'm like, what is this?

00:01:24 I'm not sure I want to learn this, but...

00:01:26 - Do I have to learn this?

00:01:27 I hope not.

00:01:27 - But yeah, anyway, yeah.

00:01:29 It did kind of get killed by HTML5.

00:01:32 And you know, I think honestly, maybe it got killed by Steve Jobs, really.

00:01:35 At least earlier than it would have been.

00:01:37 - Yeah.

00:01:38 So, but that time I didn't know that and ActionScript two and three were my tools.

00:01:46 And then I decided to move to backend problems.

00:01:50 So Flash is a client technology.

00:01:52 If somebody don't know.

00:01:54 So, and then I moved to... I just wanted to build websites and wanted to move to backend.

00:02:00 And I chose Django. Not Python, but Django. Because Django was super fancy at that time.

00:02:08 And now also, but at that time, yes. And I was a Django developer, not Python developer, but Django developer for a year probably. Because, you know, I knew a few tricks and tips about Django tools.

00:02:19 models for use and et cetera to Python.

00:02:22 And then somehow I learned Python also and now I'm more or less good Python developer.

00:02:27 - Yeah, fantastic.

00:02:29 I think I just realized as you were speaking, we might have to tell people what Flash is.

00:02:36 I feel like it's just one of these, you know, iconic things out of the tech industry, but it might be like talking about Alta Vista.

00:02:42 At some point, the kids, they won't know what Flash is.

00:02:45 They won't know there was this battle about getting this thing on people's computer and it was always like viruses that are being found in it, but it could always do this magical stuff.

00:02:54 How interesting.

00:02:56 - Yeah, yeah.

00:02:58 How old we are.

00:02:58 - Exactly.

00:03:00 The other thing that is interesting is you said you chose Django, you didn't choose Python, which...

00:03:08 - Yeah.

00:03:09 - Yeah, I think that that's...

00:03:11 Now people are often choosing Python because of the data science and computational story, But before 2012, there was not this massive influx of data science people.

00:03:21 And I think that the big influx was people becoming Django developers.

00:03:25 And like, well, I guess I'll learn Python.

00:03:28 Kind of like people becoming Ruby on Rails developers.

00:03:30 They're like, I don't know Ruby, but I want to do Ruby on Rails.

00:03:32 So I guess I got to learn Ruby.

00:03:34 And Django is kind of our version of that, right?

00:03:37 - Right, yeah.

00:03:37 Then I think Flask appeared after a few years and everyone started to do microservices with Flask.

00:03:45 and after that, the game started.

00:03:48 (laughing)

00:03:49 - That's right.

00:03:50 That's right, oh my goodness.

00:03:52 Out in the live stream, we're getting some high fives from Pradvan on Django and JF says, he says Django the right way, fantastic.

00:04:00 So awesome.

00:04:03 Yeah, and I think Django has been massively important for Python and very, very cool.

00:04:09 - Yeah.

00:04:10 - How about now, what are you doing day to day?

00:04:13 So I'm principal Python developer now and this is interesting.

00:04:17 Actually I changed my job three months ago and I didn't look for a new job.

00:04:24 But one day Mahmood, my current manager, just texted me into Twitter that, "Hey, I saw your library, Bini, and it's interesting and we need something like this in our project and probably would like to participate in and, you know, integrate Bini into our project and develop Bini at the work time.

00:04:47 Oh, cool.

00:04:47 And I decided, yeah.

00:04:48 Yeah, that's amazing.

00:04:51 I mean, on one hand, it would just be cool to have a fun job doing cool MongoDB stuff, right?

00:04:57 On the other, it's like, oh my gosh, I get to use my library and build up my library in a real production environment.

00:05:04 Like, that's awesome, right?

00:05:05 Yeah, yeah.

00:05:06 And so I decided the same day, I think.

00:05:11 - Let me think about it.

00:05:14 Yes, okay.

00:05:15 (laughing)

00:05:16 I'm trying to figure out how long it takes me to quit my current job.

00:05:19 Awesome, well, congratulations.

00:05:20 That's really cool.

00:05:21 So that only means good things for Beanie, right?

00:05:24 It only means more time and energy on it, I would suspect.

00:05:27 - Yeah, all this, the current release, the huge release is possible only because I can work a little bit time on work time, not only on weekends.

00:05:36 - Yeah, absolutely.

00:05:38 Yeah, it's easy to justify, like the library needs this feature to work right for us.

00:05:43 So let me add that feature to the library as just part of the sprint or whatever, right?

00:05:48 - And also probably it's even more important set when I can work on production with Beanie, I can also see what does it need, like which feature and which movement.

00:06:01 - It's so true because there's just these little edge cases.

00:06:05 They don't show up under even a complicated little example you build for yourself.

00:06:11 You know, you've got to put it into production and live with it.

00:06:15 You know, some of that stuff might be migrations, right?

00:06:17 Like, I never need these migrations.

00:06:19 Oh, wait, we have the zero downtime promise.

00:06:22 We kind of need migrations now or something, right?

00:06:25 - Yeah, right.

00:06:26 Totally correct.

00:06:27 - Yeah, yeah, cool.

00:06:28 Well, that's great to hear.

00:06:29 Congratulations.

00:06:30 Now, I wanted to start our chat off not talking about Beanie precisely, but like a little lower in the tech stack here.

00:06:39 Let's just talk about MongoDB for a little bit.

00:06:44 I'm a huge fan of MongoDB, as I'm sure many of the listeners know out there.

00:06:49 I've been running Talk Python, Talk Python Training those things on top of MongoDB for quite some time.

00:06:57 In the very, very early days, some of that was SQLAlchemy stuff, but then I switched over to Mongo and whatnot.

00:07:05 So I'm a huge fan of it.

00:07:07 I definitely think there's a lot of value in it.

00:07:10 There's a lot of these architectures where people talk about, oh, we have a Redis middle tier cache because we got to have our website fast.

00:07:20 You know what?

00:07:21 We get 10 millisecond response time and there's no cache.

00:07:24 It's just talking to the database 'cause, you know, everything is structured the right way.

00:07:29 I think it's, anyway, I'm kind of going on too much, But what I wanted to start with was, I wanna hear your thoughts on just sort of why build on top of Mongo?

00:07:38 You know, so many people in the Python space build on Postgres, which is fine.

00:07:43 It's a good database and all, it's just a completely different modeling story.

00:07:46 So why are you interested in Mongo?

00:07:49 - So, first of all, Mongo is super flexible database by design.

00:07:57 And I really like to do prototypes.

00:08:01 So when I just come up with new idea of new project, home project and et cetera, it's quite simple to work with MongoDB instead of Postgres when you have to change painfully schema of your data.

00:08:20 But with Mongo, you can just do what you want to.

00:08:23 - That's been my experience as well that I remember almost every release of my code would involve some migration on the SQLAlchemy version.

00:08:32 And I think I've done one, what you would consider a migration in like five years on MongoDB.

00:08:38 Whereas everything else is like, I'm gonna add this equivalent of a table, or I'm gonna add a field to this document, but it just goes in and it adapts.

00:08:49 It's fantastic.

00:08:50 It's like plastic instead of something brittle.

00:08:54 - Ah, in the indexes.

00:08:56 - Yeah, yeah, absolutely.

00:08:58 - So yeah, that's why it's great for me, I think, yeah.

00:09:03 - Yeah, it's really easy for prototyping, right?

00:09:05 You just, instead of trying to keep the database in sync or whatever, you just work on your models and magic happens.

00:09:12 - Yeah, yeah, you're right.

00:09:14 And then, for sure, for production, you have to understand your, so profiling your needs and then you can move to Postgres or you can move to something like timestamp database like Clickhouse, for example, yeah.

00:09:32 But in most cases, Mongo is enough.

00:09:35 And for some cases, Mongo is the best choice because of flexibility and because of many cool stuff like indexes and such.

00:09:44 - Yeah, absolutely.

00:09:45 I think indexes, I don't know, this is maybe getting ahead of ourselves, But I think indexes are just so underappreciated in databases.

00:09:56 I mean, I know a lot of people out there make sure their queries have the right indexes and stuff in it, but there's also so many websites I visit that take three seconds to load a page.

00:10:06 I'm like, there's no way there's an index on this query.

00:10:08 There's just no way, I don't know what it's doing, but somebody has just not even thought about it.

00:10:14 And if it was a weird little, oh, here's like the reporting page, fine.

00:10:18 But it's like the homepage or something, you know what I mean?

00:10:20 How are they not making this faster even in like a Postgres story, right?

00:10:26 Like I feel like there's one thing to have a database that does something, there's another to like tune it to do the right thing regardless of whether it's relational or NoSQL.

00:10:38 - Yeah, totally correct.

00:10:39 - Yeah, you have a lot of experience with databases.

00:10:41 I mean, you must have that feeling as well.

00:10:43 You go to some website, you're like, what is it doing?

00:10:45 Why is this thing spinning?

00:10:47 What could it possibly be doing here?

00:10:50 - Yeah, probably somebody is going to get data.

00:10:52 - Exactly, I mean, you're thinking through the ideas, okay, is it just not have an index or is it an N plus one problem with some ORM or why am I waiting here?

00:11:03 What mistake have they made?

00:11:04 (both laughing)

00:11:06 Fantastic, all right.

00:11:08 So the next thing I wanna sort of touch on is this tweet from Scott Stoltzman sent this out yesterday.

00:11:15 I don't think he knew that we were coming up with this conversation actually.

00:11:20 So there was this programming humor joke.

00:11:23 It says, it has like two, I guess one of them is like a kitchen.

00:11:31 The other is an office, but it doesn't really matter.

00:11:33 Like the kitchen is super organized and it says MySQL.

00:11:36 Everything's little buckets and put away nice.

00:11:39 And then there's a desk area that's just, it looks like a hoarder house or like a, earthquake hit and destroyed this area.

00:11:48 And it says MongoDB.

00:11:50 - And it's actually true.

00:11:52 - It is, it can be true.

00:11:55 And the reason I bring this up is Scott said, you know, I know a guy who made this course that saved me from this chaos with Mongo engine.

00:12:03 Because it can happen with, it can happen in about 15 seconds without a strong plan.

00:12:08 And so out of the box, the way MongoDB, the dev folks there suggest that you, or at least provide, let's put it that way, the tools they provide for you to work with MongoDB are dictionaries, like you can give us dictionaries and put them somewhere and then you get dictionaries back.

00:12:30 In Python, dictionaries are just whatever, right?

00:12:34 There's zero structure, there's zero discoverability, there's zero type safety, right?

00:12:38 Sometimes it's a string that looks like a number, other times it's a number.

00:12:42 good luck, those don't match in a query.

00:12:44 You know, that gets horrible.

00:12:46 And so for me, I feel like what you need to do when you're working with databases that have less structure in the thing itself, like this is MySQL, say Postgres.

00:12:58 Like Postgres says, the table looks like this.

00:13:00 This column is that size of a string.

00:13:04 This is a number and that's it.

00:13:06 You know, like the structure is in the database, where in these document databases, the structure is in the code.

00:13:14 And so you should have some kind of code that helps you not end up in a situation like this, right?

00:13:20 - Yeah, yeah.

00:13:21 But so honestly, Postgres also came up with JSONB fields now.

00:13:27 - Yeah, so they're kind of, maybe they fall into that bottom bucket, like in a small little area.

00:13:32 - Yeah, but yeah, it's also one of the things why, - Yeah.

00:13:37 Schemas about structure.

00:13:47 - Yeah, and so the thing I think saves you from, Scott mentioned Mongoid, which is pretty good, but I think the thing that saves you from this are these ODMs, like you have a lot more structure in your classes and your Python layer, right?

00:14:05 - Yeah, yeah, correct.

00:14:06 And also, so yeah, Beanie is ODM based on Pydentik.

00:14:11 Pydentik is a Python library.

00:14:14 Validating stuff, so.

00:14:24 - Yeah, let me read the little introduction bit here because I think there's so much in this first sentence.

00:14:32 So Beanie is an asynchronous Python object document mapper, ODM, for MongoDB.

00:14:39 So ODM we talked about, Mongo we talked about, asynchronous, and also I didn't finish the sentence, based on motor, which comes from MongoDB, and Pydantic.

00:14:52 So it's also asynchronous, right?

00:14:56 Which is pretty awesome, as in async and await.

00:14:59 And so often the models that we build for the databases are their own special thing.

00:15:08 Then you got to build maybe an API and you might use Pydantic or something like that.

00:15:12 But Pydantic has been really coming on strong as a super cool way to build object trees and object graphs and stuff.

00:15:21 And so Pydantic is a perfect thing to say, well, let's just use that.

00:15:25 Everyone already knows how to use that.

00:15:27 and things like APIs can already exchange those on the wire.

00:15:31 - Yep.

00:15:34 - Yeah.

00:15:35 - So, and that's why I chose this.

00:15:38 - Yeah, it's just such a neat combination of bringing the async and await stuff together along with Pydantic and saying, let's see if we can use those ideas for the ODM.

00:15:56 So there's other ones, you know, Scott mentioned Mongo engine.

00:15:58 That's actually what I'm using right now for my MongoDB stuff in Python.

00:16:02 Mongo engine's pretty good.

00:16:05 I feel like it's kind of wherever it's gonna be.

00:16:11 There's not a ton of excitement in terms of like new features and pushing stuff forward.

00:16:16 For example, there's, to my knowledge, there's no async and await stuff happening in there.

00:16:21 - Yeah.

00:16:22 - There's, I think it's synchronous.

00:16:25 - Possibly there's something that's happened that's changed that, but the last time I looked, it was synchronous still.

00:16:29 - Weeks ago it was synchronous, yeah.

00:16:31 - Yeah, okay.

00:16:32 That's much more recent than I've looked.

00:16:34 And what are some of the other ones?

00:16:37 I'm trying to think of some of the other MongoDB ODMs out there.

00:16:43 - I know in another languages probably, like Mongoose in JavaScript.

00:16:48 - Yep.

00:16:48 Yeah.

00:16:51 - Active record stuff for Ruby.

00:16:53 - Yeah, yeah, so a lot of these systems were based on the Django ORM model.

00:17:02 So for example, like Mongo engine is basically Django ORM but adapted for documents in Mongo, right?

00:17:09 Like the terminology and everything is quite similar.

00:17:12 Being based on Pydantic, yours is a little bit different.

00:17:17 I feel like there's a lot of interesting things, choices you've made.

00:17:22 One, to be based on Pydantic and how that works.

00:17:25 But two, we'll get into the API and stuff, but when you look at the API, I feel like you've chosen to be very near MongoDB's native query syntax or query language.

00:17:36 So for example, instead of doing a select, you would do like a find or find one, or the updates, and like a set operator is one of the things you can do, like a set a value on there.

00:17:51 Was that conscious?

00:17:52 Did it say, like, I'm going to try to be really close to MongoDB or what was the thinking there?

00:17:57 - So, yeah, when I started to work on Beanie, it was not Beanie, it was just a side project.

00:18:07 Because, so yeah, once the very beginning, I started to play with FastAPI.

00:18:11 It was a very modern web framework at that time.

00:18:15 Now it's still modern and great for a web framework.

00:18:18 but at that time it was quite new, around a few years ago.

00:18:22 And this is asynchronous also, and uses Pydantic under the hood.

00:18:26 And there were no ODM, no async ODM for Python and MongoDB.

00:18:34 - Yeah.

00:18:35 - And I decided--

00:18:36 - I had the same experience, like I wanted to use MongoDB with some FastAPI stuff.

00:18:41 I'm like, there's not a great, great library that I can pick here, So I guess I'll just use SQLAlchemy or something, right?

00:18:50 - And what I did, I just started with Spadantic and I've got a motor.

00:19:00 It is a PyMongo.

00:19:06 So yeah, this is an engine over PyMongo and it is a synchronous engine.

00:19:12 - Yeah, let's talk about motor a little bit because I suspect that most people who work with MongoDB work with PyMongo, right?

00:19:21 When I opened the conversation, I said, the tools they give you are just, here's a dictionary to put in, and then I get dictionaries back out.

00:19:29 I was exactly thinking of the PyMongo library, right?

00:19:34 And so what's this motor thing?

00:19:36 This is also from MongoDB.

00:19:38 - This is also from MongoDB, right?

00:19:40 And it also reflects each method and function from PyMongo.

00:19:46 But it converted, let's say, into a synchronous method and function.

00:19:55 So it uses the same--

00:19:57 mostly the same syntax as MongoDB itself and as PyMongo.

00:20:04 So it's a lot like PyMongo.

00:20:06 It says, "Motor supports nearly every method PyMongo does, "but motor methods that do network IO are co-routines." So, async and await type of things, right?

00:20:19 And yeah, yeah.

00:20:21 - So yeah, and what I did, I just combined together pedantic and motor without any query builder stuff and other ODM fancy stuff, just querying using dictionaries, the same dictionaries as motor do, and PyMongo for models and nothing more, small library.

00:20:46 It wasn't Beanie at that time, it was internal project, just to play with FastAPI.

00:20:52 And then after a few months of working, I decided probably I can make it open source.

00:21:01 came up with the name "Bini".

00:21:03 So, and that's why, mostly that's why I'm following MongoDB naming, not select, not join, etc.

00:21:13 Just find many, find one, update, etc.

00:21:18 Because I'm using, I started to use directly motor functions inside of Pydantic stuff.

00:21:27 And only after that, I just started to update Beanie stuff with more fancy stuff.

00:21:35 Mm-hmm. Yeah, so it was a pretty close match to like, how do I take Motor and just make it send and receive Pydantic instead of sending and receiving straight dictionaries, right?

00:21:46 Yeah, yeah. So the first project was just a parser from Motor to Pydantic and back.

00:21:53 Cool. Well, I think it's really neat.

00:21:55 And I, you know, however you got there, I think it's really nice that you have the API that matches that because then I can go to the MongoDB documentation and where I can find some other example that somebody has on, well, here's how you do it with PyMongo.

00:22:10 And you're like, well, that looks really close to the same thing over here.

00:22:14 So we can talk about that.

00:22:16 Now, I want to dig into some of the other features and stuff there.

00:22:21 for example, data and schema migrations, and support and whatnot, that's pretty cool.

00:22:27 But let's talk about modeling data here.

00:22:31 That's the first letter in ODM, the object bit.

00:22:36 So what does it look like?

00:22:40 I know, well, maybe not everyone listening knows what it looks like to model something with Pydantic.

00:22:45 So maybe you could give us a Pydantic example, and then we could talk about how to turn that into something that can be stored in MongoDB?

00:22:51 - So yeah, Pydantic is base model.

00:22:57 The main class of Pydantic is base model and you inherit everything from base model.

00:23:01 And it's like, it's looks like data classes of Python, but it also supports validation and parsing.

00:23:11 - And yeah, the conversions and stuff, it's really cool.

00:23:15 That's one of the things I think Pydantic is so good about.

00:23:19 If you look at their example, the way you define these classes is you have a class and you just as a sort of class level, not instance level, you'd say name colon or variable colon type, variable colon type.

00:23:34 So in this example, you've got a category, say name colon str, description colon str.

00:23:40 And then this just means this thing has two fields, they're both strings.

00:23:44 But the Pydentic example on their website is got some kind of model where it's got multiple fields and one of them is a list of things that are supposed to be numbers.

00:23:55 And if you pass it a data and that list happens to have a list of strings that can be parsed to numbers, it'll just convert it straight to numbers as part of loading it.

00:24:05 It's really, really nice, right?

00:24:07 - Yeah, yeah, this is a great feature.

00:24:09 - Yeah, this exchange across, especially across either files or API boundaries, right?

00:24:14 somebody writes some code and they send you some data.

00:24:18 Well, if they didn't really use the native data type but it could be turned into it, then that's really nice.

00:24:25 - You also can add your own parser, like your own validation step.

00:24:29 And then it will convert with your rule, like from string to number, to date.

00:24:38 So yeah, and the Beanie uses the same schema, the same, so document is a main class of Bini and it's inherited from Pydantic base model and it inherits all the methods, all the aspects of base model of Pydantic so it can use the same validation stuff, the same parsing stuff and et cetera.

00:25:04 - Right, so whatever people know and think about Pydantic, that's what the modeling looks like here.

00:25:10 I guess the one difference is when you talk about, when you model the top level documents that are going to be stored and queried in MongoDB, you don't derive from base model, right?

00:25:24 Derive from something else?

00:25:26 - Yeah, from document.

00:25:28 - Right, and document, it comes from Beanie, but that document itself is, derives from base model ultimately, right?

00:25:35 So even though you gotta do this little more specialized class, it's still a Pydantic model in its behavior, right?

00:25:42 - Yeah, yeah, correct.

00:25:43 That's why you can use it as a response model, for example, in FastAPI, if you're familiar with, because it uses pedantic base models and sub models of base models.

00:25:56 - Yeah, if people haven't seen that, let me, here's an example.

00:26:02 One of the things you can do with FastAPI that's super, super neat is you can go and say, as part of returning, where is this here?

00:26:12 As part of returning the values out of the API, one of the things you can do in the decorator is you can just say the response model is some Pydantic class.

00:26:24 And if you just add that one line and that class happens to be a Pydantic model, you get all sorts of live documentation and API definition stuff.

00:26:35 And there's even code that will consume that.

00:26:37 So I built this little weather thing in FastAPI for one of my classes over at weather.talkpython.fm.

00:26:45 And we just go to slash docs.

00:26:46 It pulls up, oh, here's all the APIs you can call.

00:26:51 And here's like the return value with exactly what the schema is.

00:26:55 And all of that's just from that one line of code.

00:26:58 So what you're saying is you could do that with these database models.

00:27:02 You could just say, I'm gonna return this directly from my API back to you.

00:27:06 If you just say response model equals your data entity model, you get all this for free, right?

00:27:13 - Yeah, it's also validated based on this model.

00:27:15 Like if you're, for example, using some external source of data and they changed schema and you received it and responded back.

00:27:24 And if the format is not correct, it just will raise an error and you can gracefully handle this, yeah.

00:27:31 - Nice.

00:27:32 Yeah, the error that it returns is also meaningful.

00:27:35 Like the third entry in this list cannot be parsed to an integer rather than 400 invalid data.

00:27:42 Good luck.

00:27:43 Okay, so we've modeled these objects in here.

00:27:48 And I guess one more thing to throw in while we're talking about modeling.

00:27:52 In your example, right at the bottom of the GitHub page, you have a category which has the name and description and you have a product that has its own name and description and then a price and the product has a category and here you just say colon category, right?

00:28:07 And that would make, I guess would make this in this case an embedded document inside of the product document, right?

00:28:17 - Yeah, totally correct.

00:28:18 It will just create embedded document.

00:28:20 - Yeah, so the way that you model, this is why Pydantic is a really good match 'cause Pydantic allows you to compose these Pydantic models in this hierarchy you can have list of other Pydantic models within a Pydantic model, which is exactly the same modeling you get with document databases like Mongo, right?

00:28:39 - Yeah, yeah.

00:28:40 - So you don't have to do anything.

00:28:42 It keeps modeling the things I wanted to model, cool.

00:28:45 In other database systems like SQLAlchemy or something, you would be able to say this field is nullable or it's required or something like that.

00:29:01 So how do you say that in this model?

00:29:04 - If it's notable, yeah, I can just use Python, type in optional, it's not class, but optional, optional, (laughs)

00:29:14 - Yeah.

00:29:15 - And mark it as optional and--

00:29:17 - Like optional bracket str versus just str, right?

00:29:21 - Yeah.

00:29:22 - And I guess for a default value, you just set it equal to its default value, right?

00:29:26 - If it's, yeah, you're right, but if it's option, so it's explicitly marked here, but pedantic allows you to use optional without default value and default would be none in that case 'cause pedantic is marked. - I'm thinking like a false or none or something like that.

00:29:45 This case, you probably wouldn't make it optional, you would just give it a default value, right?

00:29:49 - Yeah, correct.

00:29:51 - Now, one of the things that I can do and say Mongo engine is I can say the default is a function because maybe this is incredibly common for in my world is I want to know when something was created.

00:30:06 When did this user create an account?

00:30:07 When was this purchase made?

00:30:09 When did this person watch this video or whatever?

00:30:12 And so almost all of my models have some kind of created date type of thing.

00:30:16 And the default value is dateTime.dateTime.now without parentheses.

00:30:22 Like I want you to call the now function when you do an insert.

00:30:26 How would I model that in Beanie?

00:30:28 - You can use, again, you can use pedantic stuff here.

00:30:32 So I'm really like pedantic.

00:30:34 They did half a fork.

00:30:36 You can use fields class, equal fields.

00:30:39 And inside of that, you can use default factory parameter where you can just provide function you want to.

00:30:48 - Okay.

00:30:49 - And so yeah. - Oh, that's right.

00:30:50 So you can, instead of setting it, Like you could say it's a string, but its value is, what is it, you say field factory or something?

00:30:58 You set it to be one of these things that Pydantic knows about?

00:31:01 - Didn't get you, sorry.

00:31:05 - Yeah, so what, so like, is that thing that I'm setting it to equal to, does that come out of Pydantic?

00:31:12 Like that's not a Beanie thing?

00:31:14 - This is Pydantic stuff, yeah.

00:31:18 Default factory stuff.

00:31:19 But there is interesting feature about this.

00:31:22 I can show you in another code example here.

00:31:30 For example, if you want to use not created at field, but updated at.

00:31:37 So each time when you update, you want to update time.

00:31:42 And for that case, default factory will not work because default factory--

00:31:45 - Right, it's already got a value.

00:31:46 Yeah, it's only on creating, yeah.

00:31:48 Yeah, so, and Beanie allows you to use event-based actions for this.

00:31:56 And you can just create a method of the class.

00:32:00 And they are marked it like run before event, before event decorator, yeah.

00:32:09 Before event.

00:32:10 And inside of this, you can just write your logic like self updated at field equals current time and it will work for events you will choose like insert replace and anything else.

00:32:25 Yeah this is one of the new features we're going to talk about some of the new things but one of them are these these event actions so you can say before the insert event or before the save event happens or after the thing's been replaced or any of those types of things you can sort of put a or decorator and say run this function when that happens on this type or in this collection effectively, right?

00:32:50 - Yep.

00:32:51 - Very, very cool.

00:32:52 All right, we're gonna dive back into that 'cause that's good.

00:32:55 And so that would be actually a pretty good way, wouldn't it?

00:32:57 Just do an event on insert.

00:33:00 And when an insert happens, set my created date to be datetime.now.

00:33:03 - Yeah.

00:33:06 - Okay, good, good.

00:33:08 And then I guess the other part that's interesting now is doing queries and inserts on this.

00:33:13 So you would create your objects just exactly the same as you would Pydantic, right?

00:33:18 Just class name, key value, key value, key value, like that.

00:33:23 - Yeah, or even parse object like category dot parse object and dictionary with values.

00:33:33 And yeah, if you want to parse more.

00:33:35 - Right, if it's coming, okay.

00:33:37 Or if it's coming out of an API or something like that.

00:33:39 Right.

00:33:40 And then you would say, here's where it gets interesting, you say await object.insert, or await class.find1, right?

00:33:51 Or await set some value there.

00:33:55 - Yeah, yeah, yeah.

00:33:56 Because this is a sync/await library, so that's why you have to use await here.

00:34:01 Yeah.

00:34:05 Based on the synchronous nature of the library.

00:34:09 - Sure, and that's the whole point, right?

00:34:10 Is that it's built around that.

00:34:13 I think, I mean, there's ways in which you could use it in asynchronous situations, right?

00:34:17 You could always create your own event loop and just run the function and just block right that way or use something like Unsync, which maybe we'll touch on a little bit later.

00:34:26 But yeah, so, but if you're doing something like Flask or FastAPI, where the functions themselves, the thing being called by the framework is already handling it.

00:34:41 It's basically no work, right?

00:34:42 You just make an async method and then you just await things and you unlock this scalability right there.

00:34:50 - Yeah, yeah.

00:34:51 I think modern Python work is pretty everywhere asynchronous already.

00:34:57 I don't know if I think framework development now, like most of them are already asynchronous.

00:35:05 I mean, that's the worst. - Yeah, exactly.

00:35:06 Yeah, I think with Flask, there's limited support for async.

00:35:11 And then if you want full async, you have to use court for the moment, but maybe stuff's happening.

00:35:16 I know Django is working on an async story as well.

00:35:20 I think the big holdup for like full-on async in Django has actually been the Django ORM.

00:35:24 So, you know, this would fix that.

00:35:28 Although, does it make any sense to use Beanie or another ODM or something like that with Django?

00:35:35 Or, I mean, it's so tied into its ORM itself, right?

00:35:38 - I think for Django, it's a little bit tricky.

00:35:43 Probably things changed, but Django works with relative databases here, with SQL databases, and also the Django model stuff picked to this kind of.

00:35:57 So, and it will be, it's possible, - Yeah, it's just, you know, if you're fighting against the system, then you maybe should just choose a different framework rather than try to fight the way that it works, right?

00:36:10 Like if you're gonna choose something like Django that gives you a lot of opinionated workflow, but a lot of benefit if you stay in that workflow, then just, you know, I'd say follow that.

00:36:20 But the other frameworks are pretty wide open, right?

00:36:22 You could easily use this with Flask.

00:36:25 You could use this with, you know, easily use this with a flask, you could use this with pretty much anything.

00:36:32 It's better if it supports async, right?

00:36:34 There's not a synchronous version.

00:36:36 Is there?

00:36:37 Yeah, there is no synchronous version of this as it uses a motor inside this, as we said.

00:36:43 I'm thinking about at, you know, by Mongo support without motor.

00:36:49 And in that case, it would be just synchronous.

00:36:52 I would think that would be great.

00:36:54 Honestly.

00:36:55 I'm very excited that this is async burst.

00:37:00 I think that's really good.

00:37:02 But let me give you an example.

00:37:05 For my website, I would love to be able to make all the view methods be async.

00:37:11 That would give it a little bit more scalability.

00:37:13 It's pretty quick like I said, but it would still be way more scalable if it could do more while it's waiting on the server.

00:37:20 But at the same time, I have all these little scripts that I run, and like here's how I want to go and just show me all the, you know, show me all of the podcast episodes that, and who is sponsoring them to make sure that if I had to reorder things, I don't mess up some sponsorship detail or show me all the people who have signed up for this class this month and whatnot.

00:37:47 Those little scripts, right?

00:37:49 It would be nice if I could just say these little things are going to be synchronous because it's the easier programming model.

00:37:54 I don't have to deal with this loop stuff.

00:37:56 But then keep the website using the same models in the async version.

00:38:02 What do you think of that?

00:38:04 - Yeah, yeah, I do agree totally.

00:38:06 But I have limited time, that's why.

00:38:08 (both laughing)

00:38:10 - Yes, no, of course you do.

00:38:12 And I guess that pull requests are accepted, or contributions are accepted if there's meaningful good work, right?

00:38:20 - Yeah, sure, sure.

00:38:21 - Yeah, cool.

00:38:23 No, I'm not suggesting that it's like a super shortcoming, right, it's not that hard to create an async method and then just call async.io.run on it, but having this ability to say, this situation is really a synchronous one, don't need to go through the hoops to make that happen.

00:38:41 - Even I had this situation in the past, you know, and I had to create a loop inside of synchronous function.

00:38:47 (laughing)

00:38:49 - Yeah, exactly.

00:38:50 - And you know, I think that's worth touching on a little bit because people say that async and await is like, what's the, it's like a virus or something.

00:39:01 Like once one part of your code base gets async, like it sort of expands upward so that anything that might touch that function itself has to become async and then its colors have to become async and so on.

00:39:13 And I, you know, in the most naive, straightforward way, that's totally true.

00:39:19 but it's not true if you don't want it to be.

00:39:24 Right, like halfway through that function, that call stack, you could say on this part, I'm gonna create an asyncio event loop and just run it and just block.

00:39:32 Right, and anyone who calls that function doesn't have to know it's asyncio, right?

00:39:36 You can sort of stop that async propagation.

00:39:39 And that sounds like that's what you're talking about, like creating a loop and running it inside of a synchronous function.

00:39:44 - Yeah, but this looks really super ugly.

00:39:48 - Yeah, you're like-- - You even don't have any chance to avoid this.

00:39:54 Great task. (laughs)

00:39:56 - Yeah, it is a little bit weird if you haven't seen it.

00:40:00 Okay, so it's time for my requisite required shout out to the Unsync library, which I think is just so neat in the way that it simplifies async and await in Python.

00:40:11 We were talking about this just a little bit before I hit record, but it has basically two things that are frustrations that make this kind of stuff we're talking about a little bit harder.

00:40:23 Like one, wouldn't it be nice if you could just call an async function and it just runs?

00:40:28 Like I wanna write this to the log, but let's do that asynchronously and just go, go right to the log.

00:40:32 I don't wanna see from you again, I wanna hear from you again, just go put it in the log.

00:40:36 I'm gonna keep on working, right?

00:40:37 You can't do that with Python's async.

00:40:39 You've gotta like put it in a loop and make sure the loop is running.

00:40:43 to this fire and forget model doesn't work.

00:40:45 And the other is you can't block, you can't call dot result to make it block.

00:40:50 If it's not done, it's gonna throw an exception, right?

00:40:53 So this unsync thing lets you put an @unsync decorator on an async method, and then if you need to stop the async propagation, you just call dot result and it'll block and then give you the answer till it's done.

00:41:06 And there's all sorts of cool integration with like threads plus asyncio plus multiprocessing.

00:41:11 It's, I think this fixes a lot of those like little weird edge cases.

00:41:16 - I think I will try this after this podcast and we'll create a page on the documentation.

00:41:23 So if you need to find-

00:41:24 - Yeah, try it out and see if it's a good idea.

00:41:26 It might not be a good fit, but I think it is actually.

00:41:29 I think it would be.

00:41:30 - I will try.

00:41:31 So if it will not work, I will not.

00:41:32 (both laughing)

00:41:34 - So basically the way it works is it create, when it starts up, it creates a background thread that its only job is to run an asyncio event loop.

00:41:43 And then when you do stuff, when you call functions on this, instead of running the main thread, it just runs on that background thread.

00:41:48 When you block, it just waits for that background thread to finish its work and stuff like that.

00:41:51 So that's sort of the trick around it.

00:41:54 But super big fan of unsync.

00:41:56 I think it does a lot of good for these situations that we're talking about where you're like, okay, almost all the time, and definitely in production, I want it async.

00:42:05 But every now and then, I want it to just stop.

00:42:08 You know what I mean?

00:42:09 (laughing)

00:42:11 So let's talk about some of the other features.

00:42:14 Back to this example here, there's one thing I wanted to highlight that I think was really neat that I saw.

00:42:21 So you've got the standard, I've created a object that goes in the database and I call insert and I await that.

00:42:29 That puts it in the database, right?

00:42:30 - Yeah.

00:42:31 - So I don't see a return value here.

00:42:36 Does that actually set the ID on this thing that's being inserted after that function call?

00:42:41 - It updates.

00:42:43 - Okay, perfect.

00:42:44 Yeah, so .id is good to go after that, right?

00:42:48 - Yeah.

00:42:48 - Okay, cool.

00:42:49 And then the other one, you've got your await find one.

00:42:53 The filter syntax is the first thing I wanted to talk about, which I think is really nice.

00:42:59 So even though these things are, These things are, does it have to be one of these indexed ones or can you do these queries of this style on any of these?

00:43:13 Could I do a category or a description equals something or a name equals something?

00:43:19 - Yeah, yeah, sure.

00:43:20 You can do everything and you can do it even in the same, in the same line in find one, price less than 10, comma and name equals, I don't know, your name.

00:43:34 - Yeah.

00:43:35 - So it will work.

00:43:36 - Nice.

00:43:38 So the way that you would say, I wanna find the product or all the products that has a price less than 10, is you just say, in this case, the product is a class with a price field, just say product.price less than 10, right?

00:43:52 Just like you would in if statement or while loop or something like that.

00:43:55 - Yeah, yeah.

00:43:57 - This is really nice because The alternative is something like what you have in Mongo engine, where what you would say is you would say price underscore underscore LT equals 10.

00:44:10 Right, so you would say like separate the operators on the field with double underscores and so LT means less than and then you equal the value you want it to be less than and that is entirely not natural, it's not horrible, you can get used to it but it sure isn't the same as price less than 10, right?

00:44:30 - Yeah. - That'd be really nice.

00:44:31 - On the very beginning, when I told that I was Django developer, not Python developer, it was about this, because I knew how to do this stuff about Django, but it's not Python syntax, honestly, it's Django syntax, which moved to.

00:44:46 - Exactly, so you can do these natural queries, you can go like less than, greater than, equal, not equal to, and so on.

00:44:54 - Yeah, yeah.

00:44:55 - For if it was none, I mean, is thing is none is the most natural way, but you would just say equal, equal none.

00:45:02 Is that how you would test this?

00:45:04 - Yeah, you cannot hear, so it's not supported to use is.

00:45:08 - That's fine.

00:45:09 - You can use only equal.

00:45:11 - It's better than, you know, price equals 10 or equals none just as an assignment.

00:45:18 That's even weirder, so that's cool.

00:45:21 Then the other thing that I thought was neat is so often in these ORMs, and it is worse in the Mongo story because each record that comes back represents more of the data, right?

00:45:35 In this case, you've got a product and the product has a category, whereas those might be two separate tables in a relational database.

00:45:44 So the problem is I get one of these objects back from the database, I make a small change to it, like I wanna change the name, and then I call save and it's gonna completely write everything back to the database.

00:45:56 It's gonna overwrite everything, which can be a big problem.

00:45:59 So you've got, there's a couple of solutions you have for that.

00:46:02 One is you have the in place update operators, like set, and I'm guessing do you have like increment and decrement and add to set and those kinds of things?

00:46:15 - Yeah, yeah, literally everything from which MongoDB supports.

00:46:19 - Right, so in this case, you can say product.set and then product name is Goldbar, right?

00:46:27 Rather than what was it before?

00:46:29 It was Tony's or something like that, right?

00:46:32 And that'll do a MongoDB, you know, dollar set operation, which is an atomic operation.

00:46:39 So somebody else could be updating, say, the category at the same time, sort of transactionally safe.

00:46:45 And so this way, you're both way more efficient And it's also safer that you're not possibly overriding other changes.

00:46:53 - Yeah, yeah.

00:46:54 And also in current version, it's possible to, so Bini tracks all the changes of the object.

00:47:05 And when you call, instead of set, you can call save changes, and it will call set inside for all the changes which was happened with this object.

00:47:18 - Yeah, this was the other way that I was hinting at and it's super cool.

00:47:22 Where is this save changes?

00:47:24 There we go.

00:47:25 So on all of these documents, you can optionally have a class, an inner class called settings.

00:47:31 And then you can do things like use state management equals true.

00:47:35 And you don't have to figure out how to write those set operations or increment operations or whatever.

00:47:42 You can just make changes and call save changes and off it goes, right?

00:47:46 - Yeah, yeah.

00:47:47 So it's--

00:47:50 - I like this.

00:47:50 Yeah, this is really, really cool.

00:47:52 So I like that about this, that it gives you that option to sort of use the most natural way of making very small changes to the data, right?

00:48:04 Because so often ORMs and ODMs are, give me the object back, I make a change to it, put the whole thing back wherever it came from, you know?

00:48:12 - Yeah, yeah, they're great.

00:48:13 Yeah, I agree. And also, if you don't want to fetch object at all, and you want to set something to the object, you can use update query here, right?

00:48:27 And you will not even fetch object into your application.

00:48:32 That's a really good point, because so often with ORMs and ODMs, the set-based behaviors are super hard to do.

00:48:40 Right, like let's suppose I've got 100,000 users, I want to go and set some field to like a default value that didn't previously exist in the database.

00:48:52 Or I want to compute something that's a computed field that wasn't previously there.

00:48:56 So I've got to go to each one, make a change or something.

00:49:01 If it's always the same value, you still would need to go in the ORM stories, like do a query, get the 100,000 records back, loop over them, set the little one value on the class and call save.

00:49:14 But what you're saying is you could just do like product or in my case, users.update, value equals what you want it to and just update all of them, right?

00:49:25 Update many, you might have to call or something like that.

00:49:27 - Or you can even find something and then dot update and it will update on only.

00:49:33 - Oh, really?

00:49:34 So you could do like a find all then a dot update and it wouldn't actually pull them back from the database?

00:49:39 - It will not fetch in there.

00:49:40 - Oh my goodness, okay.

00:49:42 - Little bit magic.

00:49:43 - That's very magical.

00:49:44 That's awesome actually.

00:49:46 Then again, the other things you have on here that are really just simple is like, you can do a find and then just a to list on it.

00:49:55 You know, like I don't wanna loop over it or what I just, give me the list back.

00:49:59 That's also nice.

00:50:01 - Yeah.

00:50:02 - Yeah, let's see, how are we doing on time?

00:50:05 We're getting a little short on time.

00:50:07 Let's talk through a little bit of some, there's a really nice tutorial here that starts out with defining documents, setting up the code, which is pretty much just standard MongoDB, right?

00:50:19 Like you have to create one of these clients, but what you're really creating is just a motor client.

00:50:24 So I'm guessing you can send as like complex of a MongoDB configuration as you need to, and it doesn't affect Beanie.

00:50:30 - Yeah, and also now it's not documented yet because I'm lazy, but Anthony Shaw, you know him, I think.

00:50:40 - Anthony Shaw makes common appearances here, yes.

00:50:43 - Yeah, suggested me to add optional, so you can pass connection string instead of all this stuff with database, just init_binny and connection string, and it will work.

00:50:56 - Nice.

00:50:57 - But I can't have documentation about this because...

00:51:02 - Sure, so in the documentation, you create a motor client and then you pass the client over to Beanie, and that, or you just create the client first, right?

00:51:13 But if you just call Beanie, and then Beanie with the right connection string, it'll do that behind the scenes for you.

00:51:19 Yeah, thanks, Anthony.

00:51:20 That's really good.

00:51:22 So, but if you're working with like sharded clusters and replica sets and all the kinds of stuff that is like on the outer edge of these use cases, that should be supported, right?

00:51:34 It's just under behind the scenes.

00:51:36 You don't have to know about it.

00:51:37 The other thing that's interesting is when you initialize it, you pass it all the document classes, like product or user or whatever, right?

00:51:46 As a list.

00:51:47 - Yeah, yeah, because you have to, so under the hood, document must know to which database it's picked because so for some use cases, you can use different databases in the same application.

00:52:01 And in that case, you have to in it, for different databases with different set of models.

00:52:07 So yeah, you have to pass models there.

00:52:11 - Yeah, I do that in mine.

00:52:14 I have multiple databases, like logging and analytics and all that kind of stuff goes to one database that gets managed and backed up less frequently 'cause it's like gigs and gigs of data.

00:52:29 But if you lost it, the only person who would care in the world is me, Like I lost my history of stuff, right?

00:52:35 As opposed to the thing the website needs to run or user accounts or whatever, like those need to be backed up frequently and treated really specially.

00:52:45 So I actually have those as two separate databases based on classes.

00:52:50 So I guess what you're saying here is you can also call init beanie on multiple times with different databases and different lists of documents.

00:52:59 - Yeah, yeah.

00:53:01 - And it will work.

00:53:02 - Nice.

00:53:06 Yeah, that's really cool.

00:53:07 Can you give it like a star type of thing, like everything in this folder, in this module or this sub package?

00:53:16 - Not yet, unfortunately, but it's nice feature.

00:53:21 I think, yeah, it sounds like a feature request.

00:53:24 - Okay, sounds like a feature request.

00:53:25 Yeah, so if you could give it something like, all my models live in this sub package of my project or in this folder.

00:53:32 Like, there you go.

00:53:33 That might be nice.

00:53:35 Because one of the things that happens to me often is I'll add like a view to some part of my site and I'll forget to register it somewhere.

00:53:46 Like, why is this a 404?

00:53:47 Oh, yeah, yeah, yeah.

00:53:49 I gotta go and make sure that thing can see this file.

00:53:52 - It will raise an error, an exception, or less than you will call any endpoint.

00:53:59 Like if you try to touch any document without initialization, it will raise an error.

00:54:05 - Yeah, cool.

00:54:05 So let's see, let's talk indexes.

00:54:09 I started our conversation with my utter disbelief that there are websites that take five seconds to load.

00:54:15 And I'm like, I know they don't have more data than I have.

00:54:19 I just know they've done something wrong.

00:54:21 There's no way this has more data.

00:54:24 So indexes are critical, right?

00:54:26 What is the index story?

00:54:27 How do you create them over here?

00:54:29 - It's interesting story about indexes, honestly.

00:54:32 Like I published my first version of Beanie and one guy texted me and said, (both laughing)

00:54:41 probably it's possible to add indexes there.

00:54:44 I don't see if it's supported or not.

00:54:46 (both laughing)

00:54:48 And in a few days I added them.

00:54:50 - Yeah, that's right.

00:54:51 We covered Beanie when it first came out on Python Bytes.

00:54:53 I'm like, this is awesome, but where are the indexes?

00:54:56 I'm a bit of a stickler for those.

00:54:58 That's awesome.

00:54:59 So yeah, the way you do it is instead of saying, when you define a class, say the type is, say a str, or an int, you would say it's an indexed of int, and that just creates the index.

00:55:11 And it looks like you, you know, in Mongo, you have all these parameters and control.

00:55:16 Is it a sparse index?

00:55:18 Is it a uniqueness constraint as well?

00:55:20 Is it ascending?

00:55:22 Is it descending?

00:55:23 and whatnot, and so you can pass additional information like that it's a text index or something like that, right?

00:55:30 - Yeah, yeah, it supports all the parameters.

00:55:32 - And uniqueness, this isn't super important, right?

00:55:34 Like, your email on your user account had better be unique, otherwise a reset password is gonna get really weird.

00:55:42 (both laughing)

00:55:45 You support multi-field indexes, which is something that's pretty common, like a composite index.

00:55:50 if I'm gonna do a query where the product is in this category and it's on sale, you wanna have the index take both of those into account to be super fast, right?

00:56:00 So you have support for that?

00:56:02 - Yeah, it supports also, but it's not that neat, let's say, it's not that beautiful, but it's supported.

00:56:08 - Yeah, well, the payoff is worth it.

00:56:12 And it's also in this class called collection, right?

00:56:17 So it's kind of in its own special inner class of the model, in which case, a lot of the IDs have a little chevron, you can just collapse that thing and not look at it anymore.

00:56:28 So it's easy to hide the complexity, I guess there.

00:56:33 - Yeah, yeah.

00:56:35 - Cool.

00:56:36 All right, what else?

00:56:38 Aggregation, it sounds like that when we talk about, I'll have to get to it pretty quick.

00:56:46 when we talk about relationships and stuff, you said that this is super efficient because it's using the aggregation framework.

00:56:53 So MongoDB has like two ways to query stuff, right?

00:56:56 It's like the straight query style, and then it has something that's honestly harder to use, but more flexible called aggregations.

00:57:04 And so you guys support, your library supports aggregation queries as well, right?

00:57:10 - Yeah, yeah, right.

00:57:11 And also as before with updates, it also supports find queries together with aggregations.

00:57:18 Like you can use, like an example, for example, there are some presets of aggregations like average here, and you can use this average with find queries together, and you will see the result.

00:57:33 And also for sure, you can pass list pipeline in MongoDB terms.

00:57:38 You can pass pipeline of your aggregation steps there, and it will work.

00:57:44 - Yeah, it's not super easy to write if you haven't done it before, but yes, it will work.

00:57:50 - Yeah, and also the thing is, with aggregations, you have to set up what schema of the result will be, because with find, everybody knows it would be the same schema of the document, of the original document.

00:58:04 But with aggregations, it definitely can be any schema of results.

00:58:09 - Right, because the whole point of aggregation, other people might know something similar with MapReduce is I wanna take, say a collection of sales and I wanna get a result of show me the sales by country and the total sales for that country, right?

00:58:25 So you're not gonna get a list of sales back, you're gonna get a thing, a list of things that has a country and a total sales, right?

00:58:32 - Yeah, yeah, yeah.

00:58:34 And that's why, so you can, for sure it's optional and you cannot pass project output model.

00:58:41 And in that case, it will return dictionaries, but it's not that fancy, so it would be better to--

00:58:47 - Yeah, this is super cool.

00:58:48 I love this projection model idea.

00:58:50 Mario out in the audience says, "I created a model loader." Speaking of the passing the documents to Beanie and Knit, I created a model loader as a utility function that pulls dot separated pass and then passes it to document models.

00:59:06 Works really well.

00:59:07 - Great.

00:59:10 (both laughing)

00:59:10 - There you go, right on.

00:59:12 So let's talk about relationships because I started out talking about, you don't use the R, you use the D 'cause you model documents, not relationships.

00:59:24 And yet, Beanie supports relationships.

00:59:28 This is pretty cool.

00:59:29 - I'm super excited about this.

00:59:30 - Yeah, tell us about this.

00:59:32 - Yeah, so it took around three months to come up how to do relations.

00:59:38 I mean, MongoDB doesn't support relations.

00:59:41 (laughs)

00:59:43 But relations is a very popular feature in Orem and ODMs and I had to implement it finally.

00:59:53 So, and I did it.

00:59:55 For now it's supported limited version of relations like only top level fields are supported and only two kinds of relations like a direct relation and list of relations.

01:00:10 - Right, a one-to-one or a one-to-many, I guess.

01:00:13 - One-to-one, one-to-many, yeah.

01:00:15 And so the syntax is bytonic, I'd say.

01:00:21 It uses generic class link.

01:00:24 Inside of bracket, of square brackets, you'll pass your document.

01:00:32 - Right, so maybe you would specify, normally you would say an optional int.

01:00:36 Here you would say like link int, and that might, int doesn't make sense, but that type thing would be the relationship, right?

01:00:43 It's like the same syntax is optional basically here.

01:00:45 - Yeah, yeah, yeah.

01:00:47 It's a little bit tricky and there's a black magic under the hood, but.

01:00:52 - Not long as I don't have to know about it.

01:00:55 Thanks for creating the black magic.

01:00:56 So you could say here your model is, there's a door and a house, and then the door is of type link of door.

01:01:03 And then you have another one, you have windows where the house has many windows.

01:01:08 And you would say the windows is a list of link of window, which is, it's a little bit intense on the nesting there, but it's not bad, right?

01:01:18 It's just, it's a list of relationships, yeah?

01:01:21 - Yeah, yeah.

01:01:22 And for sure it's possible.

01:01:23 And I think later it would be implemented.

01:01:26 I will shorten this list of links to another...

01:01:31 - Links.

01:01:34 - Links.

01:01:34 - No, just kidding, don't do that.

01:01:37 Although it would be kind of awesome as a syntax.

01:01:39 I think it would be less discoverable.

01:01:41 - So yeah, and it works.

01:01:48 You can insert data inside of this linked documents to linked collections.

01:01:55 and you can fetch data from linked collections.

01:01:57 And...

01:01:58 - Yeah, and you can even have it cascade things.

01:02:02 So for example, you could have created a house object and say dot windows is this list of window objects.

01:02:09 And then you would say house dot save.

01:02:12 And if you pass the link rule, then that says, write the cascade the changes.

01:02:20 It'll also go and insert all those windows and associate them, right?

01:02:24 - Yeah, correct.

01:02:25 And I didn't use cascade term because it's not SQL database and a little bit different.

01:02:34 I mean, with relations, it would be completely different.

01:02:40 - Yeah.

01:02:41 How does this look in the database itself?

01:02:43 So if I go to MongoDB and I pull up the house, what is in its windows?

01:02:49 Is that a list of the IDs of the window objects or what is that?

01:02:53 - In MongoDB, there is a special data type called refid.

01:02:58 - Okay.

01:03:00 - It's under the hood, it's binary data type, but under the hood, it's a combination of id of the document, name of the collection and name of the database.

01:03:11 So it's a tuple.

01:03:12 - Oh, interesting.

01:03:13 Okay, so that's what in the document, what I end up with is a list of those things, yeah.

01:03:19 - Yeah, yeah.

01:03:20 And you will see a few collections, like here, house, window, and door, three collections with these objects, separated objects.

01:03:30 - Okay, cool.

01:03:33 You can also tell it that you don't want to propagate those changes, right?

01:03:38 As you save the house, which is interesting.

01:03:40 Let's talk about prefetch.

01:03:42 So I told you one of the, when I see those websites that are just dragging super slow, I go through my thing, all right, did they forget the index?

01:03:52 Are they doing some terrible seven-way join, probably without indexes?

01:03:58 Or the third thing, is it an N plus one ORM problem where they get one thing, but then they've got to go back and back and back because they're touching this related field, which you could potentially run into that problem as well.

01:04:09 So you have this prefetch idea, which is kind of like a joined load or something like that, right?

01:04:16 - Yeah, yeah, it uses lookup aggregation in terms of MongoDB.

01:04:21 It's not just find query, but aggregation, and it avoids this n plus one problem, as you said.

01:04:30 - Right, so you just do, in your find, you just say fetch links equals true, and that'll just go get the doors, the windows, everything in your house example, right?

01:04:39 - Yeah.

01:04:40 And I like the speed of this.

01:04:45 like it's much faster than do it one by one, especially for list of objects.

01:04:50 - Yeah, absolutely.

01:04:51 So you also have the ability to say, fetch all links retroactively.

01:04:57 If you've, you're like, oh, I should have done this join, but I didn't.

01:05:01 That might sound silly, right?

01:05:03 Well, why not just always do the join, right?

01:05:05 That's one, probably slower than not doing it, I would guess.

01:05:10 And two, this happens to me all the time.

01:05:13 like for example, on the courses website, I wanna show, I wanna be able to get the courses, but the courses have like chapter information and other stuff inside of them.

01:05:24 And then those have like links effectively over to say, like all the details about each chapter, like the lectures and videos and all that.

01:05:34 On say the page that lists the courses, I do not want those things, but on the course details page where it shows you like, here's all the stuff in the course and how long it is.

01:05:45 Like I definitely do want those things.

01:05:48 So in my data access layer, I have a thing that says, should you get all the data or just the top level data basically?

01:05:54 And this would be exactly the code you'd write.

01:05:56 Like, well, if you want all the data, you had say, fetch all links on it, right?

01:06:00 - Yeah, yeah, correct.

01:06:02 - This is cool.

01:06:04 Is there a way to do that on a set?

01:06:07 Like this is on one record.

01:06:08 Is there a way to say, I got 20 houses back, fetch all of their links or do I have to do it?

01:06:14 Is that 20 calls?

01:06:15 - So it would be 20 calls.

01:06:18 - That's okay.

01:06:20 I think in my example, it's also 20 calls or however many the same setup is exactly the same, but.

01:06:26 - But I will improve it.

01:06:30 I hope.

01:06:31 - Yeah, this is worth pointing out.

01:06:33 This is a brand new feature, right?

01:06:35 You announced this as one of the new features just two days ago, right?

01:06:40 - On Monday, yeah.

01:06:41 - Yeah, and for the people listening, we're recording on Wednesday morning.

01:06:45 So yeah, this is not, this is like your first pass, but I really like how this looks with the relationships and the query and whatnot.

01:06:53 It would be nice, I think, if you could have some way to kind of globally configure to save.

01:06:59 In general, if I call save, the rule to write the relationships is to not do nothing or to always write them or something, and then only have to override it potentially.

01:07:10 - Yeah, sounds like default rule.

01:07:12 - Yeah, exactly, exactly.

01:07:14 That'd be pretty cool.

01:07:15 So let's see a few other things we could talk about.

01:07:19 We talked a little bit about the event-based actions, but you wanna just kinda talk about them directly because it was like a quick, well, how do I add my default value?

01:07:29 What's the overall picture with these default or with these event actions?

01:07:33 - So yeah, a lot of, somehow a lot of people wanted this And I didn't know about this pattern before.

01:07:43 Like it's implemented something like this, implemented in ActiveRab record pattern of Rails.

01:07:52 And so finally I was inspired by this.

01:07:56 I like this word, inspired by.

01:07:58 Not stolen, but inspired by.

01:08:01 So and implemented this, yeah.

01:08:06 And now it's supported only for types of events.

01:08:11 There are events on each insert, replace, save changes and validate on save.

01:08:16 It creates an event and two events before it called and after it called.

01:08:24 And based on this events, actions already registered to the document would be called also.

01:08:34 It supports and synchronous and asynchronous methods for this.

01:08:39 And you can do a lot of stuff with this.

01:08:41 - Yeah, that's cool.

01:08:43 You can put the decorator on just an async version or a non-async version and being able to just call it correctly, right?

01:08:50 - Yeah, yeah.

01:08:51 - Yeah, that's cool.

01:08:53 I'm guessing if you're not doing any awaits, it'd be better if it was not asynchronous, but it doesn't matter that much, right?

01:09:01 - It's one half faster if it's not asynchronous.

01:09:06 - Yeah.

01:09:07 But if it's doing something where it's waiting on something else, then maybe it should be.

01:09:13 - Yeah. - Okay.

01:09:14 Another feature that just came out is cache.

01:09:19 - Yeah, cache.

01:09:21 It's also interesting feature.

01:09:26 So yeah, it's cache.

01:09:29 I don't know if I have to explain what is cache.

01:09:33 It's when you save data somewhere locally and use a copy of data for some time.

01:09:40 - Yeah, and what you're talking about is not using MongoDB as a caching backend, but caching the queries that would run through Beanie to not hit the database again if it knows the answer.

01:09:53 - Yeah, yeah, and somehow it's really important feature.

01:09:58 even for my projects.

01:10:01 Like for example, if you have to validate stuff with user and you already asked for a user in this application with this ID, but you don't know the place where you did it and you don't want to provide this object through the whole pipeline because probably it will not be used in the end of this pipeline.

01:10:21 But user is already cached in Bini and if you just will ask in the end of the pipeline again, about the same user data.

01:10:30 So it would be there.

01:10:31 And with a bigger find queries, it works the same way.

01:10:36 - Yeah, the more complicated the query, the better.

01:10:39 This makes a lot of sense, I think, for data that doesn't change much.

01:10:44 Like if you've got a bookstore, you might have categories and books, and maybe the books change often, the reviews of the books change often, the books that are in different categories change, but the categories themselves very rarely change, right?

01:10:58 So that could be something like the category query could just be like, you know what, this is cached.

01:11:03 - Yeah, yeah, definitely.

01:11:05 So for now it supports only local cache like dictionaries of Python, but I plan to add another cache backends like Redis and something like this.

01:11:17 - Yeah, that's cool.

01:11:18 Or even possibly you could put, - It might even make sense to use MongoDB itself as a cache.

01:11:25 - Yeah.

01:11:26 - Because what your cache--

01:11:29 (indistinct)

01:11:30 I mean, it'd be weird to kind of store the same thing back into it, but at the same time, if you've got a complicated query, what you're storing is like, these are the three things that came back from running that query against possibly hundreds of millions of records, right?

01:11:44 So in that case, it might make sense to just put it back in Mongo, so it's just a straight, you know, table scan reads.

01:11:50 something like Lambda architecture inside of the single database.

01:11:53 - Yeah, yeah.

01:11:57 So I wanted to ask you, your example says, okay, what we're gonna do is say sample.find num greater than 10 to list.

01:12:06 And then if you call it again with the caching on, then you get the same thing.

01:12:11 Well, it looks at the actual query, right?

01:12:15 So if I said num greater than 11, I would get, that would be a separate result of a separate cached thing, right?

01:12:21 - Yeah, yeah, totally.

01:12:23 - Cool, the other thing I guess that's worth noting is you can set an expiration date on the cache, right?

01:12:28 Like I want this to live for 10 minutes or whatever to get the answer back, yeah?

01:12:35 - Yeah, yeah.

01:12:36 - Cool, all right.

01:12:38 Let's talk about revisions and then I'm gonna propose one more idea that I think I could build out of revisions and events.

01:12:47 So what are revisions?

01:12:52 - So it's not my idea again.

01:12:56 It's another one user asked me for this and I really like users of Beanie because I have not that many ideas.

01:13:04 And yeah, what is this?

01:13:08 Sometimes you have to protect a document inside of the database of changes.

01:13:16 So yeah, sometimes you have old version of the data in your backend and you do some updates.

01:13:23 And if you update your document with this old data, you will lose data updated by another backend for the same document.

01:13:33 - And so let me give people some examples 'cause I think understanding the context is really important.

01:13:38 Like it could be even the same function basically, right?

01:13:42 So I could have a function that do complicated things.

01:13:45 I could say, get me my user object for the current user who wants to make some changes.

01:13:50 I could call, do a bunch of work, call a function with the pass, say, like the user ID over.

01:13:55 Maybe that gets the user back, makes some changes, saves it to the database.

01:14:00 And then I go to the end, I make some more changes, not realizing that, to my in-memory version, and I call save, and it overwrote what that intermediate function might have, whatever was there is gone now, you know what I mean?

01:14:12 So you would want to know, is the thing that I got back, if I'm gonna replace it in the database, is it still the same thing or is somebody somewhere behind the scenes changed it?

01:14:26 Often I think that people think about very complicated, well, some other process did some other thing, but it could just be some other part of your code that you didn't realize called save after a query.

01:14:37 - Yeah, yeah.

01:14:39 For this case, I'm using a revision ID, a special token, which generates each time when data saves into the database.

01:14:50 And when you save again, it will check if this ID is the same or it's already updated.

01:14:57 If it's updated, it will raise an error, like you have all data in memory.

01:15:03 But if it's the same, it will allow you to...

01:15:05 Nice.

01:15:06 - That's really cool. - I think it's a great practice.

01:15:09 No, it's good. It's good. It definitely is.

01:15:12 Because the alternative of this pattern is to do a blocking transaction.

01:15:18 Right? And that's also potentially possible.

01:15:21 I think MongoDB does have transactions now, but I still haven't used them.

01:15:25 I don't really have a use for that.

01:15:27 But the alternative model in databases is to say, we're going to do a transaction that blocks and anyone else who tries to do a database thing whatsoever, they just wait until we're done.

01:15:40 And that way there's no chance of them seeing it in this intermediate state.

01:15:44 A lot of the scalable systems don't end up doing that even in relational databases because this blocking model can really kill the concurrency.

01:15:55 Right? So they end up doing optimistic concurrency with these types of revisions anyway.

01:16:00 It's just, so I think it's a really cool pattern.

01:16:03 I love it.

01:16:04 - Yeah, it is great.

01:16:08 It's great.

01:16:09 It's a bit, it's not my idea, but it's great.

01:16:11 - Yeah, it's really good.

01:16:12 It's also, I guess, worth discussing, like set and increment and those types of things.

01:16:19 So if I say, like, I wanna add a category to a product, I could do like add to set on that thing and pass the, just put this thing in its category list.

01:16:30 Will that also increment the revision?

01:16:34 - So only set, I think, yeah.

01:16:39 - Okay.

01:16:40 - Because if you will use like internal methods of MongoDB, it will not understand that it needs to update another field.

01:16:46 - Got it, okay.

01:16:48 Interesting, but yeah, that's a good feature, I like it.

01:16:51 This is a big release.

01:16:53 - It's a huge one.

01:16:54 - Cool.

01:16:57 Well, we've been talking for a long time.

01:16:59 As you can tell, I'm very excited about it.

01:17:01 What else?

01:17:04 What's coming next?

01:17:04 - So next I have a big plans also.

01:17:09 I really like Pydentic.

01:17:12 I'm a huge fan of Pydentic.

01:17:14 You can see it.

01:17:16 But for some cases, Pydentic is a heavy tool.

01:17:21 And probably, I don't know how I will implement it, but I want to add support of native Python data classes here or here or to separate it smaller project like Beanie data classes.

01:17:37 I don't know yet, but anyway, I have planned to add better classes without pedantic there.

01:17:44 Just with not, let's say, fancy parsing stuff without that great validation stuff, but it's--

01:17:55 - Somewhere in between, I just wanna, you're just getting dictionaries back, good luck, and you're getting Pydantic.

01:18:01 Somewhere in the middle is you're getting classes back, but they don't necessarily, they're not as precise as, say, Pydantic.

01:18:08 - Yeah, I mean, there are cases, and people uses Beanie with these cases also, when you have a lot of JSON, huge JSONs as a document, and when you parse it on a fetching, it gives a lot of time.

01:18:29 - Yeah.

01:18:30 - So it takes a lot of time for that, just for parsing.

01:18:33 And then for encoding back to dictionary to store this dictionary.

01:18:38 - Yeah.

01:18:39 - It's not, it's not pedantic fault, definitely, because pedantic is, again, it's great.

01:18:44 But I need to avoid this step somehow, and probably I will use data classes for this.

01:18:53 - Sure, they look very similar.

01:18:55 Another scenario where I find that Pydantic is not a good fit is where I might be getting bad data, but I don't want it just to be an exception.

01:19:04 I want to be able to get all the bad data and say, here's the three errors that you made passing me this data.

01:19:11 And I'm not going to accept it, but here's what you gave me, if you're doing like form exchange, right?

01:19:18 like from an HTML form.

01:19:21 What you need to do is put the old value back in and say that value right there, that's wrong.

01:19:28 But with Pydantic, if you get the value from the form and you try to read it, it's just gonna know it's wrong.

01:19:35 And you're like, wait, but I need to give it back to them.

01:19:36 Just don't run away, come back, where'd you go?

01:19:39 And so there's situations like that where you need to kind of keep that exchange going, but you still want some sort of, you just gotta do the validation yourself.

01:19:48 But anyway, there's certainly times where Pydantic is, as cool as it is, is not the right fit for that situation.

01:19:54 - Yeah, yeah, I agree, totally, yeah.

01:19:56 Good example. - Nice.

01:19:58 Thanks.

01:19:59 All right, well, Romano, this is a very cool project.

01:20:03 I've, as you hinted at earlier, I've seen it from the beginning, at least when you open sourced it, and it's really come a long ways.

01:20:11 It's super compelling.

01:20:13 It looks like something that I could possibly use on my next project.

01:20:18 I constantly, as many people out there are, I'm sure as you are, I'm constantly resisting the urge to go, you know, I should rewrite that.

01:20:26 I should rewrite that in FastAPI or I should rewrite that in this.

01:20:29 I should rewrite my Mongo engine stuff with Beanie, but you know, maybe one day I'll break down and do it.

01:20:36 It'd be fun.

01:20:37 - Yeah.

01:20:39 Thank you.

01:20:40 Thank you.

01:20:41 - Yeah, very cool.

01:20:43 So nice work on this project.

01:20:46 You're looking for contributors and PR, would you be, PRs, would you be happy to have people make contributions?

01:20:53 - I make a bunch of issues now.

01:20:55 A lot of people found something doesn't fit to different use cases.

01:21:05 And so, yes, it would be great to have other contributors here.

01:21:09 I already have like 15 contributors.

01:21:14 - Nice, yeah.

01:21:14 Yeah, that's why.

01:21:15 - Quite a few people in the sidebar there.

01:21:18 - Each one is a hero.

01:21:20 (laughing)

01:21:21 - That's awesome.

01:21:21 - Yeah. - Cool.

01:21:24 - But I need more, more and more.

01:21:26 (laughing)

01:21:27 And especially for documentation, because I really much better in Python than in English.

01:21:34 (laughing)

01:21:36 And documentation is my weak point.

01:21:40 - Okay, cool.

01:21:41 Well, definitely a neat project.

01:21:43 So thank you for building it.

01:21:45 Now, before you get out of here, you have to answer the final two questions.

01:21:49 If you're gonna write some Python code, what editor are you using these days?

01:21:53 What did you use to create Beanie with, for example?

01:21:56 - I'm using Pesharm.

01:21:58 JetBrains also gave me ProVersion for Beanie as a support program, I think.

01:22:08 - Yeah, fantastic.

01:22:10 - It's a really great tool.

01:22:12 I'm expecting new one, I don't remember the name of, but they have new idea.

01:22:22 I don't remember the name.

01:22:24 Fleet, Fleet, yeah.

01:22:25 - Yeah, I was about to mention Fleet.

01:22:27 Fleet is interesting.

01:22:28 Fleet is like JetBrains response to VS Code.

01:22:32 - Yeah.

01:22:33 - I'm pretty excited about it.

01:22:36 You know, I really love PyCharm.

01:22:37 Nobody's gonna be surprised that I say that.

01:22:41 But if I've got just one file, like I'm gonna open that in VS Code because all the JetBrains IDE tools, they expect like a project and they're gonna create all these things.

01:22:52 I'm like, I just wanna look at the files, just the files, please, like just not too much.

01:22:55 And this is kind of like that where you can later turn on some of the IDE features, right?

01:23:01 It looks pretty cool.

01:23:02 You're gonna try it out?

01:23:04 - Not yet, I asked for it, but so JetBrains, if you hear me, please.

01:23:09 - Yes, exactly JetBrains.

01:23:11 I'm already on the early access list too.

01:23:12 And I have an email.

01:23:14 Maybe I haven't checked it this morning.

01:23:15 Maybe it's there.

01:23:17 Fantastic.

01:23:21 All right.

01:23:23 So PyCharm, maybe fleet in the future potentially.

01:23:26 - Cool.

01:23:27 - And then notable PyPI package.

01:23:29 I mean, we've talked about a bunch of libraries already.

01:23:32 - Yeah.

01:23:32 So I really like one.

01:23:34 It's not about identical FastAPI stuff, but I really, it's a great package called Yarl, Y-A-R-L.

01:23:43 Yeah, it's like, it's like a pass library, but for URLs and it's great.

01:23:58 You can combine strings with this URL stuff together and you can parse it, you can--

01:24:05 - Oh, that's cool.

01:24:06 - Yeah, so you can pass it a URL as a string, just like whatever you'd expect, but then you can say, give me the scheme, which is like HTTP, HTTPS, the host, the path, the query string.

01:24:16 - I really like how they use this divide operator.

01:24:22 You probably see in the bottom of your page now, like URL divide, full divide bar.

01:24:28 - Oh, interesting.

01:24:28 It's like Pathlib style.

01:24:31 - It's like Pathlib, yeah.

01:24:32 It's like Pathlib for URLs.

01:24:35 and it's super great.

01:24:37 - All right, this is totally new to me, awesome.

01:24:40 Good recommendation, good recommendation.

01:24:42 - Yeah, I use it in each project now.

01:24:44 I don't know how to live without this.

01:24:47 - All right, well, I'm gonna check it out for sure.

01:24:50 One quick follow up from the audience here.

01:24:53 Mario says, "Thank you for this project.

01:24:54 "I'm about to launch my FastAPI Beanie blog soon.

01:24:58 "Couldn't have done it without it." - Thank you.

01:25:02 - Yeah, and Ollie's on it.

01:25:04 He says, "Pathlibs for URLs." Indeed, it's Pathlib for URLs.

01:25:09 Cool, that's a great one.

01:25:10 All right, final call to action.

01:25:12 People wanna get started with Beanie.

01:25:13 What do you say?

01:25:14 - I would say, have fun.

01:25:20 (both laughing)

01:25:22 - Awesome.

01:25:23 Yeah, I would recommend that people go and check out the, if you go to the documentation, there's a tutorial that walks you through this pretty well, right there on the left.

01:25:34 It just starts by defining a document and then initialization and so on.

01:25:38 - Yeah, yeah, we try to do this as much simple to understand as possible.

01:25:45 - Fantastic.

01:25:46 All right, Roman, thank you for being here.

01:25:49 - Thank you very much for being here.

01:25:51 - Yeah, absolutely.

01:25:53 Everyone out watching this on YouTube, thank you so much for being here.

01:25:56 All of you who asked questions, that was really great.

01:25:58 And if you enjoyed it, be sure to like the video and subscribe to hear about more.

01:26:02 See you.

01:26:03 See you!

