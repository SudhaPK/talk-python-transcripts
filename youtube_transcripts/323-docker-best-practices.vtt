WEBVTT

00:00:00.000 --> 00:00:06.000
>> Everyone out there in the live stream, hey, how are you doing?


00:00:06.000 --> 00:00:10.560
>> Hi. Great. How are you doing? >> Very good. You ready to do this podcast?


00:00:10.560 --> 00:00:15.600
>> Yeah. >> Awesome. Let's kick it off. Those of you


00:00:15.600 --> 00:00:19.720
out there in the live stream listening, just drop a comment in the show note, in the live


00:00:19.720 --> 00:00:26.400
chat in YouTube. We'll try to make it part of the show. Welcome back to Talk Python to


00:00:26.400 --> 00:00:30.040
- It's been some time.


00:00:30.040 --> 00:00:31.440
- Feels like a year or so.


00:00:31.440 --> 00:00:33.400
I'm not sure exactly how long it's been.


00:00:33.400 --> 00:00:34.520
Last time we were on,


00:00:34.520 --> 00:00:38.140
we were talking about an entirely different topic.


00:00:38.140 --> 00:00:43.140
So you get two bits on the mind map connective


00:00:43.140 --> 00:00:45.800
sort of relationship topics here.


00:00:45.800 --> 00:00:52.160
We talked about fill and profiling data science.


00:00:52.160 --> 00:00:53.000
That was fun.


00:00:54.000 --> 00:00:57.800
- Yeah, I sort of have found myself talking


00:00:57.800 --> 00:01:00.040
about a bunch of different subjects


00:01:00.040 --> 00:01:02.860
and like some people are interested in both,


00:01:02.860 --> 00:01:04.860
some people are interested in the other.


00:01:04.860 --> 00:01:10.880
And Docker is the other thing I've spent a lot of time


00:01:10.880 --> 00:01:13.200
sort of researching and writing about.


00:01:13.200 --> 00:01:17.280
- Yeah, I think the data science profiling one


00:01:17.280 --> 00:01:20.120
was really interesting because profiling


00:01:20.120 --> 00:01:22.360
has all these challenges and much of it is more focused


00:01:22.360 --> 00:01:24.160
around profiling running applications


00:01:24.160 --> 00:01:26.260
or profiling code that's all in Python.


00:01:26.260 --> 00:01:29.920
And so if you need to profile like say Fortran code


00:01:29.920 --> 00:01:33.400
or other weird sort of mix and match libraries,


00:01:33.400 --> 00:01:36.240
then that was sort of that topic, right?


00:01:36.240 --> 00:01:39.920
- Yeah, so for feel as a memory profiler for Python


00:01:39.920 --> 00:01:43.500
and the kind of, and specifically for batch processes


00:01:43.500 --> 00:01:45.420
like data science, scientific computing.


00:01:45.420 --> 00:01:47.040
And so if you're doing scientific computing,


00:01:47.040 --> 00:01:50.880
there'll be a bunch of code in Fortran and C++ and Rust.


00:01:50.880 --> 00:01:55.440
And so you want to access that memory,


00:01:55.440 --> 00:01:56.800
like sort of profile memory


00:01:56.800 --> 00:01:58.760
across all the languages you're using.


00:01:58.760 --> 00:02:00.560
- Yeah, yeah.


00:02:00.560 --> 00:02:04.360
Because if you've got some big glob of C code,


00:02:04.360 --> 00:02:06.440
Python thinks it's just a pointer,


00:02:06.440 --> 00:02:07.640
a little tiny pointer to some,


00:02:07.640 --> 00:02:09.120
but it turns out to be huge.


00:02:09.120 --> 00:02:11.840
Guys, if people can check out that episode,


00:02:11.840 --> 00:02:13.960
if they're interested and yeah,


00:02:13.960 --> 00:02:16.920
just give us an update on what you've been doing since then.


00:02:18.720 --> 00:02:23.160
So I've actually been trying to turn Fill into a--


00:02:23.160 --> 00:02:24.920
sort of make an alternative version of it


00:02:24.920 --> 00:02:26.760
that you can run in production.


00:02:26.760 --> 00:02:28.920
Profilers often have performance overhead.


00:02:28.920 --> 00:02:32.960
So Fill will take like 40% performance off the top.


00:02:32.960 --> 00:02:38.440
Trying to make something that will run with like 1%, 2%


00:02:38.440 --> 00:02:38.960
overhead.


00:02:38.960 --> 00:02:41.840
So you can run it on production and just always get


00:02:41.840 --> 00:02:45.480
reports by your memory usage for any job.


00:02:45.480 --> 00:02:47.440
So if it's like six hours in and it crashes,


00:02:47.440 --> 00:02:51.360
that crashes or just uses too much memory, go back.


00:02:51.360 --> 00:02:53.360
- Oh, that would be fantastic.


00:02:53.360 --> 00:02:54.200
- Yeah.


00:02:54.200 --> 00:02:59.040
- And we have that for like profiling in terms of performance


00:02:59.040 --> 00:03:01.320
on some systems, you can plug them in


00:03:01.320 --> 00:03:04.320
and they'll kind of give you real time.


00:03:04.320 --> 00:03:07.200
How is my app doing in terms of,


00:03:07.200 --> 00:03:10.660
here's where it's spending its time or it got slower.


00:03:10.660 --> 00:03:13.460
Maybe it's even just measuring like request response,


00:03:13.460 --> 00:03:18.460
but memory profiling's typically been pretty intensive,


00:03:18.460 --> 00:03:21.560
so that'd be cool if you could get it down to that level.


00:03:21.560 --> 00:03:24.940
- Yeah, and this is a very good,


00:03:24.940 --> 00:03:30.820
both Phil and this project are very good pandemic projects.


00:03:30.820 --> 00:03:34.300
It's like really, it's quite difficult to do,


00:03:34.300 --> 00:03:37.100
but it's something that is sort of


00:03:37.100 --> 00:03:38.660
completely under my control.


00:03:38.660 --> 00:03:42.220
We'll get to Docker, and Docker is like,


00:03:42.220 --> 00:03:46.060
There's this giant ecosystem and they all have differing opinions about how you do things


00:03:46.060 --> 00:03:49.300
and everything's so broken around the edges.


00:03:49.300 --> 00:03:54.940
Whereas here, it's like I have a box and it's a very complicated box, but it's under my


00:03:54.940 --> 00:03:56.460
control and so I can do stuff.


00:03:56.460 --> 00:04:02.940
It's kind of relaxing in an environment where the world is not under my control.


00:04:02.940 --> 00:04:03.940
Yeah.


00:04:03.940 --> 00:04:06.860
It's been a crazy time, hasn't it?


00:04:06.860 --> 00:04:07.860
Yeah.


00:04:07.860 --> 00:04:08.860
Yeah.


00:04:08.860 --> 00:04:10.660
I feel like we're getting used to it.


00:04:10.660 --> 00:04:17.660
It's odd, but people just get used to whatever water they swim in eventually, I guess.


00:04:17.660 --> 00:04:18.660
Yeah.


00:04:18.660 --> 00:04:19.660
Yeah.


00:04:19.660 --> 00:04:20.660
All right.


00:04:20.660 --> 00:04:23.340
Well, let's talk about Docker a little bit.


00:04:23.340 --> 00:04:32.060
So it hasn't been that long since I had-- I also want to shout out quick, episode 274


00:04:32.060 --> 00:04:33.820
is when we talked about Philip.


00:04:33.820 --> 00:04:35.820
People want to go back and check that out.


00:04:35.820 --> 00:04:40.700
I had Peter McKee from Docker over there


00:04:40.700 --> 00:04:45.400
to come and talk about sort of what is Docker,


00:04:45.400 --> 00:04:46.760
give us an update on Docker, the company,


00:04:46.760 --> 00:04:50.160
and sort of set the stage for Python developers, right?


00:04:50.160 --> 00:04:51.960
To kind of get going on the dev side


00:04:51.960 --> 00:04:53.520
and just start using Docker.


00:04:53.520 --> 00:04:56.120
So that was episode 308, and that was fun.


00:04:56.120 --> 00:04:59.440
But then recently you gave a talk at PyCon


00:04:59.440 --> 00:05:01.240
called "Zero to Production Ready,


00:05:01.240 --> 00:05:05.640
"A Best Practices Process for Docker Packaging."


00:05:05.640 --> 00:05:07.640
And so I thought that was really interesting


00:05:07.640 --> 00:05:10.360
and I wanted to have you on the show


00:05:10.360 --> 00:05:15.360
so we could dive into Docker best practices for Python


00:05:15.360 --> 00:05:19.400
but also your focus is really on production,


00:05:19.400 --> 00:05:21.360
not necessarily development, right?


00:05:21.360 --> 00:05:22.200
- Yeah.


00:05:22.200 --> 00:05:23.400
- So maybe we start there.


00:05:23.400 --> 00:05:27.560
What's Docker look like for software development


00:05:27.560 --> 00:05:29.960
as a I just need to make my stuff run


00:05:29.960 --> 00:05:32.040
so I can code it and test it out


00:05:32.040 --> 00:05:35.320
versus zero downtime Kubernetes


00:05:35.320 --> 00:05:38.400
or whatever it is you're trying to do type of thing.


00:05:38.400 --> 00:05:39.580
What do those two worlds look like?


00:05:39.580 --> 00:05:43.120
And maybe tell folks about when they should care


00:05:43.120 --> 00:05:45.800
about what are the advantages or whatever.


00:05:45.800 --> 00:05:50.300
- Yeah, so what Docker gives you is a sort of package


00:05:50.300 --> 00:05:56.760
that contains all the files you need for the file system,


00:05:56.760 --> 00:06:00.520
contains Python, it contains all the system libraries


00:06:00.520 --> 00:06:02.840
you need to run your Python extensions.


00:06:02.840 --> 00:06:04.880
It contains all your Python dependencies,


00:06:04.880 --> 00:06:08.040
contains all your code, and contains a script


00:06:08.040 --> 00:06:11.240
to launch your code.


00:06:11.240 --> 00:06:15.320
And so as a starting point, this is useful for development


00:06:15.320 --> 00:06:18.520
because if you're, say, on macOS or on Windows


00:06:18.520 --> 00:06:20.600
and you're deploying to Linux, you


00:06:20.600 --> 00:06:24.960
can run something locally that is the same


00:06:24.960 --> 00:06:26.520
across different computers.


00:06:26.520 --> 00:06:29.760
Even if you are on Linux, like I have one machine that's


00:06:29.760 --> 00:06:33.520
Fedora 33, I have another machine that's Ubuntu,


00:06:33.520 --> 00:06:37.280
like they're different in a bunch of subtle


00:06:37.280 --> 00:06:38.200
and not so subtle ways.


00:06:38.200 --> 00:06:41.940
And so by having a Tucker container when I'm developing,


00:06:41.940 --> 00:06:45.960
I can have a completely consistent environment


00:06:45.960 --> 00:06:47.200
and then know that that environment,


00:06:47.200 --> 00:06:49.400
when I then take that code and run in production,


00:06:49.400 --> 00:06:51.480
it'll be exactly the same there.


00:06:51.480 --> 00:06:55.000
- Right, I had somebody reach out to me a little while ago


00:06:55.000 --> 00:06:56.960
and ask something to the effect of,


00:06:58.040 --> 00:07:00.720
I've got a bunch of different developers on my team


00:07:00.720 --> 00:07:03.320
and I wanna make sure that they all have the same version


00:07:03.320 --> 00:07:06.560
of Python and the same packages, right?


00:07:06.560 --> 00:07:09.100
And that's a legitimate thing that you might wanna do.


00:07:09.100 --> 00:07:11.840
You might wanna make sure that those are exactly the same.


00:07:11.840 --> 00:07:14.120
I think maybe in general,


00:07:14.120 --> 00:07:17.600
there's probably more of a concern about that


00:07:17.600 --> 00:07:19.520
than an actual problem there.


00:07:19.520 --> 00:07:21.500
You know, a lot of times,


00:07:21.500 --> 00:07:23.040
either these things are gonna basically work


00:07:23.040 --> 00:07:24.360
or they're gonna utterly fail.


00:07:24.360 --> 00:07:26.400
I think one of the scenarios maybe where it matters more


00:07:26.400 --> 00:07:31.080
is data science, where there's slight changes in algorithms,


00:07:31.080 --> 00:07:34.320
which might lead to different ways you train the model,


00:07:34.320 --> 00:07:36.360
which might lead to different--


00:07:36.360 --> 00:07:37.280
those kinds of changes.


00:07:37.280 --> 00:07:40.520
But say in web apps or UI apps or something like that,


00:07:40.520 --> 00:07:42.100
it's either just going to work or it's


00:07:42.100 --> 00:07:43.600
going to completely break.


00:07:43.600 --> 00:07:46.360
That said, this situation you're talking


00:07:46.360 --> 00:07:48.240
about with Docker for development


00:07:48.240 --> 00:07:51.200
kind of solves that, but to a much bigger degree, right?


00:07:51.200 --> 00:07:53.440
Because you can specify in this image,


00:07:53.440 --> 00:07:58.440
We have exactly this version of Python compiled in this way.


00:07:58.440 --> 00:08:02.080
We have these libraries installed with this version.


00:08:02.080 --> 00:08:04.560
We have these environment variables set


00:08:04.560 --> 00:08:08.600
and this subsystem of Linux installed as well,


00:08:08.600 --> 00:08:09.440
but not that other,


00:08:09.440 --> 00:08:12.040
like you can completely control it way more than just,


00:08:12.040 --> 00:08:14.040
I want the same version of Python, right?


00:08:14.040 --> 00:08:16.120
- Yeah, and you can then go further


00:08:16.120 --> 00:08:18.060
with something like Docker Compose,


00:08:18.060 --> 00:08:19.760
where Compose lets you start up


00:08:19.760 --> 00:08:21.840
a little network of containers.


00:08:21.840 --> 00:08:23.600
And then it's very easy to say, okay,


00:08:23.600 --> 00:08:27.080
I want to spin up Postgres or I want to spin up Redis.


00:08:27.080 --> 00:08:29.640
Whereas traditionally this would be a pain in the ass


00:08:29.640 --> 00:08:32.740
with Docker and Docker Compose.


00:08:32.740 --> 00:08:33.840
You can spin up a little,


00:08:33.840 --> 00:08:36.240
all your dependency servers really easily.


00:08:36.240 --> 00:08:39.000
So then even if you're not using Docker for your own code,


00:08:39.000 --> 00:08:42.000
you can use Docker for the services you depend on.


00:08:42.000 --> 00:08:42.840
- Right.


00:08:42.840 --> 00:08:44.560
I need Redis running in this way


00:08:44.560 --> 00:08:46.600
and then Postgres in that way.


00:08:46.600 --> 00:08:49.200
And I just need them all configured and to be able to talk.


00:08:49.200 --> 00:08:51.200
So Docker Compose up, right?


00:08:51.200 --> 00:08:52.040
something like that.


00:08:52.040 --> 00:08:52.880
- Yeah.


00:08:52.880 --> 00:08:53.700
- Okay.


00:08:53.700 --> 00:08:56.080
- Yeah, Docker Compose is a way to sort of run


00:08:56.080 --> 00:08:59.760
a little network of services, makes that really easily.


00:08:59.760 --> 00:09:02.360
- Yeah, another big advantage before we get off


00:09:02.360 --> 00:09:05.840
of the development side of things is onboarding new people


00:09:05.840 --> 00:09:07.560
and new hardware, right?


00:09:07.560 --> 00:09:10.600
If you've got something really complicated like that,


00:09:10.600 --> 00:09:11.840
and you get somebody on the team,


00:09:11.840 --> 00:09:13.640
instead of spending a lot of time trying to get


00:09:13.640 --> 00:09:17.360
their system put together in the right way,


00:09:17.360 --> 00:09:19.700
you just go, install Docker, do this.


00:09:20.720 --> 00:09:24.020
- Yep, and yeah, there's open source projects


00:09:24.020 --> 00:09:26.200
where like you can set up the development environment


00:09:26.200 --> 00:09:27.780
that will also provide a Docker file


00:09:27.780 --> 00:09:32.160
to just let you like run some tests easily


00:09:32.160 --> 00:09:35.840
just because you're a ongoing,


00:09:35.840 --> 00:09:37.180
you're only submitting one patch,


00:09:37.180 --> 00:09:39.320
you wanna run some like some tests on it,


00:09:39.320 --> 00:09:40.980
you don't want to go the whole thing.


00:09:40.980 --> 00:09:43.000
So it's very nice when they provide a way


00:09:43.000 --> 00:09:45.320
to run the code in Docker.


00:09:45.320 --> 00:09:47.080
- Yeah, absolutely.


00:09:47.080 --> 00:09:50.280
That said, I don't generally do my development in Docker,


00:09:50.280 --> 00:09:54.400
just have virtual environments and roll with that.


00:09:54.400 --> 00:09:56.440
So it's not always required.


00:09:56.440 --> 00:09:58.400
A couple of thoughts from folks out in the live stream.


00:09:58.400 --> 00:10:00.920
Ken Van Wick, hey, Kim, says, "Docker Compose


00:10:00.920 --> 00:10:03.440
is an excellent way to make sure all the developers are using


00:10:03.440 --> 00:10:06.200
the same tools and versions, and it's just much easier


00:10:06.200 --> 00:10:09.520
to pass around a YAML file."


00:10:09.520 --> 00:10:12.520
Yeah, Compose is--


00:10:12.520 --> 00:10:15.000
I remember when Compose first came out.


00:10:15.000 --> 00:10:16.640
It was called Fig, I think.


00:10:16.640 --> 00:10:20.800
And it took Docker from something really neat


00:10:20.800 --> 00:10:22.640
to something really useful.


00:10:22.640 --> 00:10:24.000
- Yeah, right.


00:10:24.000 --> 00:10:27.880
The promise of Docker is that I can have all these different,


00:10:27.880 --> 00:10:29.480
if I want to run, like we just described,


00:10:29.480 --> 00:10:32.560
I want to run Redis, I want to run maybe a Celery backend,


00:10:32.560 --> 00:10:34.720
I want to run Postgres,


00:10:34.720 --> 00:10:37.680
and then my dev code is going to run and talk to all that.


00:10:37.680 --> 00:10:41.120
Well, keeping those all up to date,


00:10:41.120 --> 00:10:43.120
start making sure they all build those files


00:10:43.120 --> 00:10:45.600
and they all run, and maybe they run in the right order.


00:10:45.600 --> 00:10:47.440
Well, that all of a sudden isn't fun anymore.


00:10:47.440 --> 00:10:49.440
But if you can create a compose file and just say,


00:10:49.440 --> 00:10:53.080
here's the set of containers that needs to work together,


00:10:53.080 --> 00:10:55.280
bring them all up in the right order,


00:10:55.280 --> 00:10:57.040
and make sure they're all up to date,


00:10:57.040 --> 00:10:58.480
got their recent build and so on,


00:10:58.480 --> 00:11:02.520
that's a whole other level of the promise of containers.


00:11:02.520 --> 00:11:04.280
Yeah.


00:11:04.280 --> 00:11:07.520
And also, I don't know if you know anything about this.


00:11:07.520 --> 00:11:09.600
I'll maybe take a wild guess here.


00:11:09.600 --> 00:11:11.360
But Daniel Chen out in the live stream


00:11:11.360 --> 00:11:13.880
also says, question, in Windows, is


00:11:13.880 --> 00:11:19.760
any difference between WSL2 for the Docker back end compared to Hyper-V? Or is Hyper-V


00:11:19.760 --> 00:11:24.800
more for backwards compatibility, legacy support?


00:11:24.800 --> 00:11:32.560
I in general don't use Windows that much, but basically there's two, like, since you're


00:11:32.560 --> 00:11:39.360
running Linux and Windows is not Linux, you need to have some way of running Linux. And


00:11:39.360 --> 00:11:41.800
in the past, the way you do that, you would run a virtual machine. That's what it does


00:11:41.800 --> 00:11:44.720
as in macOS 2, I believe.


00:11:44.720 --> 00:11:48.640
Windows subsystem for Linux is a way


00:11:48.640 --> 00:11:52.760
to transparently run Linux applications on Windows.


00:11:52.760 --> 00:11:54.800
And Docker supports it these days.


00:11:54.800 --> 00:11:58.800
I suspect it would be faster, but that's just a guess.


00:11:58.800 --> 00:11:59.360
Yeah.


00:11:59.360 --> 00:12:01.360
Yeah, that's my thought as well, that they would


00:12:01.360 --> 00:12:02.760
be a little more integrated.


00:12:02.760 --> 00:12:07.320
Probably you could more easily do things like mount Windows


00:12:07.320 --> 00:12:11.280
file system folders from your Docker container.


00:12:11.280 --> 00:12:13.420
maybe you still can't with the others, probably you can, but


00:12:13.420 --> 00:12:15.560
- I'd expect to be faster at least, yeah.


00:12:15.560 --> 00:12:18.080
- Yeah, it seems like if you want to run on Linux,


00:12:18.080 --> 00:12:20.040
you're probably, I think you're probably closer.


00:12:20.040 --> 00:12:21.680
It's definitely more lightweight.


00:12:21.680 --> 00:12:25.460
The Hyper-V would be running a full on Linux VM


00:12:25.460 --> 00:12:28.360
and then hosting Docker in that, I'm pretty sure.


00:12:28.360 --> 00:12:29.200
Yeah. - Yeah.


00:12:29.200 --> 00:12:33.680
- Cool, all right, well, hopefully our guests is there,


00:12:33.680 --> 00:12:35.120
Daniel are helpful for you.


00:12:35.120 --> 00:12:39.840
All right, well, let's talk about your talk


00:12:39.840 --> 00:12:40.680
that you gave at PyCon.


00:12:40.680 --> 00:12:43.520
I mean, giving talks today at conferences,


00:12:43.520 --> 00:12:44.760
like we started the show off,


00:12:44.760 --> 00:12:46.200
like it's a weird world, right?


00:12:46.200 --> 00:12:50.100
I'm giving a talk and both doing a live stream podcast


00:12:50.100 --> 00:12:53.480
on a conference tomorrow


00:12:53.480 --> 00:12:57.360
at the Manning Developer Productivity Conference.


00:12:57.360 --> 00:12:58.360
How can I do that?


00:12:58.360 --> 00:13:00.680
We record it, we publish it,


00:13:00.680 --> 00:13:02.800
and then we have a live Q&A afterwards.


00:13:02.800 --> 00:13:04.840
So the presentation of my recording


00:13:04.840 --> 00:13:07.400
will be during the Python Bytes recording tomorrow,


00:13:07.400 --> 00:13:10.720
but then the live interactive bit will be actually after.


00:13:10.720 --> 00:13:13.780
So yeah, that's the commerce world we live in.


00:13:13.780 --> 00:13:18.120
And so PyCon this year was virtual.


00:13:18.120 --> 00:13:20.920
You put together a really nice presentation


00:13:20.920 --> 00:13:22.840
sort of in this format.


00:13:22.840 --> 00:13:25.480
And yeah, like I said, I got a lot out of it


00:13:25.480 --> 00:13:27.540
and I liked what you covered there.


00:13:27.540 --> 00:13:31.200
- Yeah, and so the starting point is like,


00:13:31.200 --> 00:13:33.900
you have a service now you wanna run it in production.


00:13:35.020 --> 00:13:38.980
And this is a very dramatic departure


00:13:38.980 --> 00:13:42.780
from running things locally, because locally, the thing


00:13:42.780 --> 00:13:48.700
you're prioritizing is basically your feedback loop,


00:13:48.700 --> 00:13:50.940
like your development feedback loop.


00:13:50.940 --> 00:13:52.620
If you're a web developer, you do it


00:13:52.620 --> 00:13:55.420
when you save your code, and you reload the page


00:13:55.420 --> 00:13:57.100
to have the new stuff running.


00:13:57.100 --> 00:13:59.600
Other applications, the feedback loop's a little different.


00:13:59.600 --> 00:14:06.120
Like your goal is just as quickly as possible


00:14:06.120 --> 00:14:07.620
to interact with your code.


00:14:07.620 --> 00:14:09.040
When you're in production, you have


00:14:09.040 --> 00:14:10.880
to worry about a whole bunch of other issues


00:14:10.880 --> 00:14:13.720
because it's actually you have users


00:14:13.720 --> 00:14:15.760
who are going to be interacting with the software


00:14:15.760 --> 00:14:20.000
or the data it's emitting will be used in the real world.


00:14:20.000 --> 00:14:22.800
It's no longer just something you're working on.


00:14:22.800 --> 00:14:25.920
It's a thing that actually has some--


00:14:25.920 --> 00:14:28.680
the output actually has some weight, some meaning,


00:14:28.680 --> 00:14:29.880
some importance.


00:14:29.880 --> 00:14:34.520
And so you have to approach it in a different way.


00:14:34.520 --> 00:14:37.120
>> So some of the things that come to mind here


00:14:37.120 --> 00:14:41.840
would be downtime.


00:14:41.840 --> 00:14:44.920
In a perfect world, zero downtime.


00:14:44.920 --> 00:14:49.760
In a reasonable world, a couple of seconds of downtime.


00:14:49.760 --> 00:14:51.680
In the world of some bizarre web companies


00:14:51.680 --> 00:14:55.340
that I literally cannot understand,


00:14:55.340 --> 00:14:56.560
eight hours of downtime.


00:14:56.560 --> 00:14:58.640
Because we're deploying the new version of the site,


00:14:58.640 --> 00:14:59.480
Sunday, it'll be down.


00:14:59.480 --> 00:15:01.240
Like what?


00:15:01.240 --> 00:15:03.920
I just literally, I got this a while ago,


00:15:03.920 --> 00:15:06.120
a couple of months ago for something I was using.


00:15:06.120 --> 00:15:08.560
There's going to be hours of downtime for a site.


00:15:08.560 --> 00:15:10.880
That's just, as Explosive said,


00:15:10.880 --> 00:15:13.400
do you upgrade to the new version of the site?


00:15:13.400 --> 00:15:14.560
That should be a button folks.


00:15:14.560 --> 00:15:15.440
That should be not long.


00:15:15.440 --> 00:15:18.800
Anyway, one of the things is downtime, right?


00:15:18.800 --> 00:15:20.120
You wanna focus on that


00:15:20.120 --> 00:15:24.120
and you don't care about that at all with development.


00:15:24.120 --> 00:15:25.840
I mean, you want it to be somewhat responsive,


00:15:25.840 --> 00:15:28.200
but it doesn't matter if it's down for a moment.


00:15:28.200 --> 00:15:31.800
Another one that you made a big deal out of that can matter is security.


00:15:31.800 --> 00:15:39.160
You don't want to be in the newspaper or the news website front pages for


00:15:39.160 --> 00:15:42.600
leaking the largest data breach ever or something like that, right?


00:15:42.600 --> 00:15:52.360
Yeah, that's embarrassing. Yeah, and basically, once you're packaging for production, you're at


00:15:52.360 --> 00:15:56.200
the intersection of a whole bunch of processes. This is where it starts getting complicated.


00:15:56.200 --> 00:16:00.600
You're coding, and then you have this image, and then you might want to run some tests


00:16:00.600 --> 00:16:02.160
with it, maybe integration tests.


00:16:02.160 --> 00:16:04.280
You're going to deploy it.


00:16:04.280 --> 00:16:08.640
And then when you deploy it, you might be upgrading an existing package, existing server.


00:16:08.640 --> 00:16:09.640
It's a server.


00:16:09.640 --> 00:16:10.640
It's a batch process.


00:16:10.640 --> 00:16:11.640
Things are a little different.


00:16:11.640 --> 00:16:16.600
So there's deployment, and then things might go wrong in production, and then you might


00:16:16.600 --> 00:16:19.880
have some sort of feedback mechanism, and maybe you're going to try to reproduce the


00:16:19.880 --> 00:16:21.880
bug locally.


00:16:21.880 --> 00:16:28.920
And so all of these different technological organizational processes have some, interact


00:16:28.920 --> 00:16:30.860
in some way with your packaging.


00:16:30.860 --> 00:16:35.200
And so it basically makes it a lot more complicated.


00:16:35.200 --> 00:16:40.240
And then you add into it all the different technologies that are intersecting in packaging.


00:16:40.240 --> 00:16:43.640
And it's just, there's a lot of details to get right.


00:16:43.640 --> 00:16:44.640
Yeah.


00:16:44.640 --> 00:16:50.440
Another area that you want to get into has to do with making sure that you're running


00:16:50.440 --> 00:16:53.680
the latest version, but you're not necessarily


00:16:53.680 --> 00:16:59.880
every deployment just grabbing the latest version.


00:16:59.880 --> 00:17:02.280
So you need some way to inject stability


00:17:02.280 --> 00:17:04.440
and you need some way that that stability


00:17:04.440 --> 00:17:08.600
doesn't lock in like computer vulnerabilities


00:17:08.600 --> 00:17:10.760
or any of those kinds of issues.


00:17:10.760 --> 00:17:12.980
It also allows it to keep growing, right?


00:17:12.980 --> 00:17:17.980
- Yeah, and so the, and this is sort of a,


00:17:18.260 --> 00:17:20.740
And one of the more significant examples,


00:17:20.740 --> 00:17:22.660
but an example of the bigger picture, which


00:17:22.660 --> 00:17:25.700
is packaging is a process.


00:17:25.700 --> 00:17:28.700
And so it's not just about writing some configuration


00:17:28.700 --> 00:17:29.660
files.


00:17:29.660 --> 00:17:32.060
It's going to interact with the way you write code.


00:17:32.060 --> 00:17:33.060
And it's a thing that's--


00:17:33.060 --> 00:17:35.460
parts of it are going to continue over time.


00:17:35.460 --> 00:17:37.380
So you're not-- when you're packaging for production,


00:17:37.380 --> 00:17:39.180
you're not just writing a few config files


00:17:39.180 --> 00:17:40.420
and calling it a day.


00:17:40.420 --> 00:17:42.960
You actually need to think about and need


00:17:42.960 --> 00:17:45.540
to set up these ongoing processes for things


00:17:45.540 --> 00:17:48.100
like security updates and for things like dependency updates.


00:17:48.100 --> 00:17:50.940
- Right, it's one thing to get it running on a cluster,


00:17:50.940 --> 00:17:53.940
container cluster, it's another to say,


00:17:53.940 --> 00:17:57.060
and here's how we're going to keep the software healthy


00:17:57.060 --> 00:17:59.580
and running over time, right?


00:17:59.580 --> 00:18:04.580
- Yeah, and you need to sort of think through


00:18:04.580 --> 00:18:06.780
the implications of what you're doing


00:18:06.780 --> 00:18:10.700
and it's not just a one-off thing, it's an ongoing thing.


00:18:10.700 --> 00:18:12.420
- Yeah, absolutely.


00:18:12.420 --> 00:18:15.780
All right, let's dive into some of the details.


00:18:15.780 --> 00:18:21.140
into some of the details. So it turns out I discovered today as I was pulling up your website


00:18:21.140 --> 00:18:27.540
that you've actually written a whole bunch of stuff about production ready docker packaging


00:18:27.540 --> 00:18:33.460
and that you're actually working on a handbook. I end up doing this a lot as well. I end up


00:18:33.460 --> 00:18:39.460
I'll spend you know a month doing tons of research and examples and thinking about a course and like


00:18:39.460 --> 00:18:44.900
oh there's a couple of nice presentations or conference talks I could pull out of here and


00:18:44.900 --> 00:18:47.140
Yeah, it's a good way to do it, right?


00:18:47.140 --> 00:18:50.620
So you've been thinking a lot about this, not just for this talk, but beyond, right?


00:18:50.620 --> 00:18:55.020
Yeah, I've been spending two years on it so far.


00:18:55.020 --> 00:18:59.180
Like, I have three different products up there.


00:18:59.180 --> 00:19:00.500
I've done training.


00:19:00.500 --> 00:19:03.740
There's a lot of articles these days.


00:19:03.740 --> 00:19:05.380
Just adds up.


00:19:05.380 --> 00:19:13.420
And yeah, I've spent a lot of time looking into this, because it turns out it's--


00:19:13.420 --> 00:19:18.420
So I guess I should say, I don't like Docker packaging.


00:19:18.420 --> 00:19:21.100
- Okay.


00:19:21.100 --> 00:19:24.220
- This isn't a thing I'm doing because like, this is fun.


00:19:24.220 --> 00:19:26.380
Like, it's not actually fun.


00:19:26.380 --> 00:19:27.820
It's kind of a pain.


00:19:27.820 --> 00:19:31.300
It's just, it's very useful


00:19:31.300 --> 00:19:35.100
and it's very easy to get it wrong or to miss things.


00:19:35.100 --> 00:19:37.220
And so what I've been trying to do is to sit


00:19:37.220 --> 00:19:40.260
and say, here's this really useful thing.


00:19:40.260 --> 00:19:42.320
Here are the details you need to get right.


00:19:42.320 --> 00:19:43.780
And now that I've written it down,


00:19:43.780 --> 00:19:47.340
you don't have to waste your time trying to figure this out.


00:19:47.340 --> 00:19:51.140
Because much of it is not--


00:19:51.140 --> 00:19:54.900
it's really useful, but it's not like--


00:19:54.900 --> 00:19:57.740
you don't feel like you're a better person for having


00:19:57.740 --> 00:19:58.500
figured this out.


00:19:58.500 --> 00:20:01.540
It's just-- it's the getting--


00:20:01.540 --> 00:20:02.420
it's an obstacle.


00:20:02.420 --> 00:20:04.500
And I'm trying to get people past those obstacles


00:20:04.500 --> 00:20:06.300
so they can use this useful technology.


00:20:06.300 --> 00:20:06.800
Yeah.


00:20:06.800 --> 00:20:08.300
Well, there's a lot of stuff that you


00:20:08.300 --> 00:20:11.140
talk about that is not necessarily something that


00:20:11.140 --> 00:20:13.340
would be front of mind, like security,


00:20:13.340 --> 00:20:16.900
like how to manage the versioning over time and so on.


00:20:16.900 --> 00:20:21.260
But I think also it would be quite satisfying to have,


00:20:21.260 --> 00:20:23.060
you know, take something that's janky


00:20:23.060 --> 00:20:26.020
and maybe it does have that like one hour banner on Sunday,


00:20:26.020 --> 00:20:28.420
we're gonna be down from three to four,


00:20:28.420 --> 00:20:30.900
creating our site and be able to remove that and say,


00:20:30.900 --> 00:20:32.940
no, we just deploy a couple times a week now


00:20:32.940 --> 00:20:37.500
and we don't think about it because it's get push prod


00:20:37.500 --> 00:20:39.940
and then wait 30 seconds


00:20:39.940 --> 00:20:42.300
and then prod is now the new one, right?


00:20:42.300 --> 00:20:43.140
- Yeah.


00:20:43.140 --> 00:20:45.180
- So I think that's a very good feeling.


00:20:45.180 --> 00:20:48.720
- Yeah, and there's a bunch more you need to do that


00:20:48.720 --> 00:20:49.560
than what I talk about.


00:20:49.560 --> 00:20:50.460
I'm talking about one piece.


00:20:50.460 --> 00:20:52.740
There's also the deployment process


00:20:52.740 --> 00:20:56.140
and that there's having good observability and logging,


00:20:56.140 --> 00:20:57.800
but even just the packaging part of it,


00:20:57.800 --> 00:20:59.300
like there's a lot of details to get right


00:20:59.300 --> 00:21:00.800
that can make it a lot easier.


00:21:00.800 --> 00:21:05.420
- Yeah, so the way you started the presentation,


00:21:05.420 --> 00:21:09.100
your first thought for this was that packaging,


00:21:09.100 --> 00:21:12.380
this whole Docker as production,


00:21:12.380 --> 00:21:14.780
packaging your app in Docker for production


00:21:14.780 --> 00:21:16.940
is an iterative process.


00:21:16.940 --> 00:21:17.780
- Yep.


00:21:17.780 --> 00:21:19.940
- And maybe also layers, right?


00:21:19.940 --> 00:21:23.180
Like, so you sit, you don't necessarily start


00:21:23.180 --> 00:21:24.780
with the whole, well, we want zero downtime.


00:21:24.780 --> 00:21:27.700
You start with, can we make it run in Docker?


00:21:27.700 --> 00:21:29.660
- Yeah, and you don't have to do it


00:21:29.660 --> 00:21:30.580
as an iterative process.


00:21:30.580 --> 00:21:33.480
Like if you can manage to keep all this in your head,


00:21:33.480 --> 00:21:36.040
which honestly I can't, there's too many details.


00:21:37.100 --> 00:21:39.580
Or if I were to start dockerizing something,


00:21:39.580 --> 00:21:42.140
I would probably do a bunch of it in one go


00:21:42.140 --> 00:21:43.040
'cause I remember some of it.


00:21:43.040 --> 00:21:45.780
But if you're doing this at your job


00:21:45.780 --> 00:21:47.180
and you probably are,


00:21:47.180 --> 00:21:49.820
like someone's, there's gonna be an emergency


00:21:49.820 --> 00:21:51.380
or someone's gonna pull you over


00:21:51.380 --> 00:21:53.060
or there's gonna be a bug that you have to fix.


00:21:53.060 --> 00:21:55.860
And so you're gonna get pulled away at some point.


00:21:55.860 --> 00:22:00.860
And so what you'd like to do is build your packaging


00:22:00.860 --> 00:22:03.080
in a way where if you're interrupted, you have to stop,


00:22:03.080 --> 00:22:04.940
you have to put it on hold.


00:22:04.940 --> 00:22:07.420
you can put it aside and know you're a good stopping point.


00:22:07.420 --> 00:22:09.540
And you want to sort of prioritize


00:22:09.540 --> 00:22:10.620
the most important ways.


00:22:10.620 --> 00:22:11.980
So if you run--


00:22:11.980 --> 00:22:13.500
you may just run out of time budget.


00:22:13.500 --> 00:22:16.140
Like, you just have limited time.


00:22:16.140 --> 00:22:18.780
And you want to do the highest priority things first.


00:22:18.780 --> 00:22:20.100
And if you ever have more time--


00:22:20.100 --> 00:22:21.140
Well, it sounds like what you're describing


00:22:21.140 --> 00:22:24.180
is a little bit of what happened to the software development


00:22:24.180 --> 00:22:27.100
side of things when it went from waterfall to agile


00:22:27.100 --> 00:22:30.060
or waterfall to something better.


00:22:30.060 --> 00:22:32.440
So many projects used to say, well, what we're going to do


00:22:32.440 --> 00:22:34.360
is we're going to build it until--


00:22:34.360 --> 00:22:35.640
we're gonna work on it for six months


00:22:35.640 --> 00:22:38.160
and it's not gonna be actually usable


00:22:38.160 --> 00:22:41.400
in any meaningful way until that six month point


00:22:41.400 --> 00:22:43.880
and then maybe it drags on and it goes over budget


00:22:43.880 --> 00:22:44.720
and gets canceled.


00:22:44.720 --> 00:22:45.560
And there's just all sorts of,


00:22:45.560 --> 00:22:46.960
you know, you get no user feedback.


00:22:46.960 --> 00:22:48.640
There's all these kinds of problems


00:22:48.640 --> 00:22:49.820
trying to build software that way.


00:22:49.820 --> 00:22:51.680
So it doesn't surprise me


00:22:51.680 --> 00:22:53.360
that there would be lots of advantages


00:22:53.360 --> 00:22:56.640
to trying to apply that same sort of iterative thinking.


00:22:56.640 --> 00:22:58.960
Like let's make sure that each step along the way


00:22:58.960 --> 00:23:00.600
we have something that's useful


00:23:00.600 --> 00:23:02.720
and more useful than it was before.


00:23:02.720 --> 00:23:07.280
- Yep, and it also, even if you know


00:23:07.280 --> 00:23:09.360
you have the time budget to do all of it,


00:23:09.360 --> 00:23:11.400
having a good understanding of the priorities


00:23:11.400 --> 00:23:14.960
means you can focus on the really important things.


00:23:14.960 --> 00:23:16.480
- Yeah, yeah.


00:23:16.480 --> 00:23:18.960
- Large images are very visible.


00:23:18.960 --> 00:23:20.520
Like it's very easy, like you can look at your image


00:23:20.520 --> 00:23:22.080
and say, why is this two gigabyte?


00:23:22.080 --> 00:23:23.880
Like, this is ridiculous.


00:23:23.880 --> 00:23:25.860
And then you can go into this rabbit hole


00:23:25.860 --> 00:23:28.600
of like trying to make your image smaller.


00:23:28.600 --> 00:23:30.240
And that's a fine thing to do,


00:23:30.240 --> 00:23:35.720
But if you deploy an image that's insecure and nice and small,


00:23:35.720 --> 00:23:37.960
that's not the best trade-off.


00:23:37.960 --> 00:23:41.040
I would venture to say that your organization would not


00:23:41.040 --> 00:23:44.240
praise you for your efforts to make it small,


00:23:44.240 --> 00:23:47.040
but rather they would be pretty upset about the security


00:23:47.040 --> 00:23:48.120
problems, right?


00:23:48.120 --> 00:23:49.960
Yeah.


00:23:49.960 --> 00:23:54.400
And so security seems like a high priority,


00:23:54.400 --> 00:23:56.400
like automation's a high priority.


00:23:56.400 --> 00:23:58.200
And the order you might actually do it in


00:23:58.200 --> 00:24:02.200
might be slightly different depending on your particular domain you're working on.


00:24:02.200 --> 00:24:04.200
- Right. - But...


00:24:04.200 --> 00:24:06.200
- It's a bit of a priority stack, right?


00:24:06.200 --> 00:24:09.200
Like, what is most important to me or what is most foundational


00:24:09.200 --> 00:24:12.200
to this whole packaging and Docker process?


00:24:12.200 --> 00:24:17.200
- Yep. - So you actually put up some six points


00:24:17.200 --> 00:24:20.200
that you thought were sort of stages in your talk.


00:24:20.200 --> 00:24:24.200
Get something working, that's just... Can you use Docker at all?


00:24:24.200 --> 00:24:26.200
Obviously, if it doesn't work, it's not going to be useful.


00:24:26.200 --> 00:24:29.520
And then number two, even before continuous integration,


00:24:29.520 --> 00:24:30.960
security, right?


00:24:30.960 --> 00:24:34.320
I can see that people would overlook that,


00:24:34.320 --> 00:24:36.280
but that's not trivial, right?


00:24:36.280 --> 00:24:42.160
- Yeah, and like security is sort of a never ending thing,


00:24:42.160 --> 00:24:45.280
like, 'cause you have to deal with security updates,


00:24:45.280 --> 00:24:49.600
but, you know, if you want to,


00:24:49.600 --> 00:24:51.600
like, you don't need complete automation


00:24:51.600 --> 00:24:53.800
to like spin up a server somewhere and test something.


00:24:53.800 --> 00:24:55.120
Like if you're using Heroku,


00:24:55.120 --> 00:24:58.040
you can push a Docker image.


00:24:58.040 --> 00:25:00.880
- You can manually do a get push.


00:25:00.880 --> 00:25:05.120
- Yeah, you can push stuff, and then try it out.


00:25:05.120 --> 00:25:09.720
And, but if it's talking to a production database,


00:25:09.720 --> 00:25:11.720
and it's not secure, that's the problem.


00:25:11.720 --> 00:25:16.560
And packaging is only one small part of security,


00:25:16.560 --> 00:25:18.240
and most of it's gonna be application security,


00:25:18.240 --> 00:25:21.560
but it still comes into it, and it's still important.


00:25:21.560 --> 00:25:24.040
- Right, right, little Bobby Tables is still a problem,


00:25:24.040 --> 00:25:25.880
even if it's running in Docker.


00:25:25.880 --> 00:25:26.720
- Yes.


00:25:26.720 --> 00:25:29.640
- That's right.


00:25:29.640 --> 00:25:30.720
Okay, so number two is security


00:25:30.720 --> 00:25:33.760
and then number three is continuous integration.


00:25:33.760 --> 00:25:37.800
So making sure that like when we check in code


00:25:37.800 --> 00:25:41.680
that it's tested in Docker, I'm guessing.


00:25:41.680 --> 00:25:43.480
The test to run the system,


00:25:43.480 --> 00:25:45.960
something of a Docker compose up type of thing happens


00:25:45.960 --> 00:25:46.980
and it's all good.


00:25:46.980 --> 00:25:50.640
Then correctness and debug ability.


00:25:50.640 --> 00:25:53.080
So correctness is obvious, right?


00:25:53.080 --> 00:25:55.840
It needs to work, it needs to have fresh data,


00:25:55.840 --> 00:25:59.280
it can't have stale caches and weird things like that.


00:25:59.280 --> 00:26:01.920
But debuggability is interesting.


00:26:01.920 --> 00:26:04.280
Maybe you wanna focus on that for just a sec?


00:26:04.280 --> 00:26:08.120
- Sure, so the idea is that once you have automated builds,


00:26:08.120 --> 00:26:09.920
you might start actually running things


00:26:09.920 --> 00:26:11.840
in production for real.


00:26:11.840 --> 00:26:13.000
Even if not, you're gonna have,


00:26:13.000 --> 00:26:15.920
if you're building an image for every pull request,


00:26:15.920 --> 00:26:17.480
now you have a bunch of images.


00:26:17.480 --> 00:26:21.200
And so someone files a bug,


00:26:21.200 --> 00:26:22.800
how do you know what version of your code,


00:26:22.800 --> 00:26:25.740
like which Docker image, do they know which Docker image


00:26:25.740 --> 00:26:28.080
they were using, what version of the code it matches to?


00:26:28.080 --> 00:26:31.200
If something crashes, like are you gonna get actual,


00:26:31.200 --> 00:26:33.760
are you gonna get logs that someone can report?


00:26:33.760 --> 00:26:38.120
- If you don't go to the effort of exporting the volume


00:26:38.120 --> 00:26:40.160
that has where the logs get written,


00:26:40.160 --> 00:26:44.680
every new deploy gets a new fresh set of logs.


00:26:44.680 --> 00:26:48.000
- Yeah, so yeah, like logging to standard app


00:26:48.000 --> 00:26:50.400
or standard error is the other way you deal


00:26:50.400 --> 00:26:55.680
of logs in Docker, but you need to like put some minimal thought into like where my log


00:26:55.680 --> 00:26:56.680
is going to go.


00:26:56.680 --> 00:26:57.680
Yeah.


00:26:57.680 --> 00:27:02.440
Another thing that gets really tricky around that kind of stuff I feel has to do with the


00:27:02.440 --> 00:27:05.960
fact that there's just so many moving parts a lot of times.


00:27:05.960 --> 00:27:10.520
You know, you've got your Celery Docker container, you've got your Redis Docker container, you've


00:27:10.520 --> 00:27:14.320
got your Postgres Docker container, you've got your app Docker container.


00:27:14.320 --> 00:27:18.200
If you're doing microservices, like who knows how many.


00:27:18.200 --> 00:27:21.320
And then all of those things have logs.


00:27:21.320 --> 00:27:24.320
Do you use anything, any of the services


00:27:24.320 --> 00:27:27.120
that try to bring all those logs into one place?


00:27:27.120 --> 00:27:33.320
- I have not a huge amount of experience


00:27:33.320 --> 00:27:34.320
on a particular one.


00:27:34.320 --> 00:27:38.620
I have, or I've built a system like that,


00:27:38.620 --> 00:27:40.600
which these days I wouldn't recommend using,


00:27:40.600 --> 00:27:42.120
but it's more for this point.


00:27:42.120 --> 00:27:45.520
- Yeah, before the log as a service,


00:27:45.520 --> 00:27:47.600
log aggregation as a service was a thing.


00:27:47.600 --> 00:27:49.040
- Yeah, and I've seen it.


00:27:49.040 --> 00:27:51.480
I've worked on like airline reservation system


00:27:51.480 --> 00:27:55.280
that had one of these, and this was a like eye opener


00:27:55.280 --> 00:27:58.520
for me being able to see logs going between five services


00:27:58.520 --> 00:28:00.920
in like multiple different protocols.


00:28:00.920 --> 00:28:04.120
So you could make debugging vastly simpler.


00:28:04.120 --> 00:28:04.940
- Yeah.


00:28:04.940 --> 00:28:09.580
- So you really like anything that lets you trace


00:28:09.580 --> 00:28:14.580
across services with a tracing ID will make your,


00:28:14.580 --> 00:28:16.360
once you have more than one service,


00:28:16.360 --> 00:28:17.480
it'll make your life much easier.


00:28:17.480 --> 00:28:22.480
However, my recommendation is avoid microservices


00:28:22.480 --> 00:28:25.000
unless your company has 500 people.


00:28:25.000 --> 00:28:26.200
- Yeah. - Something like that.


00:28:26.200 --> 00:28:29.880
- Yeah, it's an amazing architectural design pattern


00:28:29.880 --> 00:28:33.120
when there needs to be autonomy


00:28:33.120 --> 00:28:34.560
for different parts of the application.


00:28:34.560 --> 00:28:39.080
Like this team works on the front end little bits here.


00:28:39.080 --> 00:28:41.680
This team works on the user authentication


00:28:41.680 --> 00:28:45.680
and identity part APIs.


00:28:45.680 --> 00:28:50.680
But looking at the most recent PSF JetBrains survey,


00:28:50.680 --> 00:28:54.180
that is not the number of employees,


00:28:54.180 --> 00:28:56.220
number of people on a team type of description


00:28:56.220 --> 00:28:58.140
for most Python developers.


00:28:58.140 --> 00:29:00.940
It's like a handful of folks.


00:29:00.940 --> 00:29:01.780
- Yeah, and if you look at--


00:29:01.780 --> 00:29:04.500
- All working on a lot of it, right?


00:29:04.500 --> 00:29:05.980
- Yeah, and if you look at the companies


00:29:05.980 --> 00:29:08.700
that are doing microservices successfully at scale,


00:29:08.700 --> 00:29:11.100
they will have a team of three to five people


00:29:11.100 --> 00:29:13.180
working on one service.


00:29:13.180 --> 00:29:15.420
So if you have a team of five people, 20 services,


00:29:15.420 --> 00:29:20.420
you are doing like 100 times more services per developer


00:29:20.420 --> 00:29:26.260
than the big companies.


00:29:26.260 --> 00:29:27.100
- Yeah.


00:29:27.100 --> 00:29:29.100
- And that's a lot of complexity


00:29:29.100 --> 00:29:30.480
you've just added to your life.


00:29:30.480 --> 00:29:32.140
And it is often unnecessary.


00:29:32.140 --> 00:29:36.940
- Here, let's, I'll pull up the survey.


00:29:36.940 --> 00:29:39.680
So Python developer survey 2020 results.


00:29:39.680 --> 00:29:42.720
If you search in that for team, not team city,


00:29:42.720 --> 00:29:44.900
employment work, working in a team


00:29:44.900 --> 00:29:47.060
versus working independently.


00:29:47.060 --> 00:29:49.820
About half the people work on a team.


00:29:49.820 --> 00:29:53.580
But if you look at the team size, 75% are two to seven.


00:29:53.580 --> 00:29:55.700
- Yeah, that should be one microservice.


00:29:55.700 --> 00:29:56.900
- Yeah, exactly. - And that's really


00:29:56.900 --> 00:29:57.980
microservices.


00:29:57.980 --> 00:30:01.300
And there are applications are actually


00:30:01.300 --> 00:30:03.340
are distributed systems where you actually,


00:30:03.340 --> 00:30:04.420
it makes sense to do more,


00:30:04.420 --> 00:30:08.060
but like any time you make something more distributed,


00:30:08.060 --> 00:30:10.700
you are adding a vast amount of complexity.


00:30:12.140 --> 00:30:14.480
So if you can avoid it, avoid it.


00:30:14.480 --> 00:30:15.220
Yeah.


00:30:15.220 --> 00:30:16.640
Well, here's the way that I think about it.


00:30:16.640 --> 00:30:20.240
I think about microservices.


00:30:20.240 --> 00:30:28.580
They have a tons of value and they move where the complexity of your application


00:30:28.580 --> 00:30:29.740
lives.


00:30:29.740 --> 00:30:35.520
So what you end up with is very simple, relatively simple, small, easy bits of


00:30:35.520 --> 00:30:35.960
code.


00:30:35.960 --> 00:30:41.700
But what you also end up with is a much more complex deployment, DevOps


00:30:41.700 --> 00:30:45.700
coordination story. So when I think about


00:30:45.700 --> 00:30:47.220
microservices, the farther you go


00:30:47.220 --> 00:30:49.380
towards microservices, the more you're


00:30:49.380 --> 00:30:50.180
taking the code complexity of a large


00:30:50.180 --> 00:30:52.260
app and


00:30:52.260 --> 00:30:53.460
architectural patterns and separation,


00:30:53.460 --> 00:30:54.740
and you're saying, "Well, we don't need any


00:30:54.740 --> 00:30:56.660
of that. Let's make it real simple." And


00:30:56.660 --> 00:30:58.740
we move that complexity to


00:30:58.740 --> 00:31:00.580
coordinating a bunch of services that


00:31:00.580 --> 00:31:01.940
are always up, that are debuggable across


00:31:01.940 --> 00:31:04.420
services,


00:31:04.420 --> 00:31:06.020
and versioned, and all those things.


00:31:06.020 --> 00:31:07.940
And when I think about that for me, I'm


00:31:07.940 --> 00:31:09.860
way better at software complexity than


00:31:07.940 --> 00:31:09.900
and I am at deployment complexity.


00:31:09.900 --> 00:31:13.140
So I'm more successful not putting it


00:31:13.140 --> 00:31:15.980
where I don't have my experience or skill set.


00:31:15.980 --> 00:31:17.980
- It's actually software complexity too,


00:31:17.980 --> 00:31:20.620
because if you call a function,


00:31:20.620 --> 00:31:22.100
you're gonna call a function.


00:31:22.100 --> 00:31:24.120
If you send a message to another service,


00:31:24.120 --> 00:31:28.020
it may never arrive and may be delayed arbitrarily.


00:31:28.020 --> 00:31:28.860
- Yeah.


00:31:28.860 --> 00:31:32.500
- And so like the communication becomes


00:31:32.500 --> 00:31:35.420
and the reliability of the thing you're calling,


00:31:35.420 --> 00:31:37.580
the switch from a function within the same process


00:31:37.580 --> 00:31:41.740
to remote service is a sort of huge increase


00:31:41.740 --> 00:31:44.420
in unpredictability and sources of error.


00:31:44.420 --> 00:31:49.440
- Yeah, that's a good point because as for many things


00:31:49.440 --> 00:31:53.480
that could go wrong with say calling some function


00:31:53.480 --> 00:31:55.820
or a sort of class level method,


00:31:55.820 --> 00:32:00.100
not having it get called is not one of the things


00:32:00.100 --> 00:32:02.780
you'd have to worry about, right?


00:32:02.780 --> 00:32:05.260
It might crash 'cause the file system isn't there,


00:32:05.260 --> 00:32:07.340
it isn't accessible, the database isn't there,


00:32:07.340 --> 00:32:10.400
but it's not that you couldn't even call it, right?


00:32:10.400 --> 00:32:11.780
That's gonna happen.


00:32:11.780 --> 00:32:12.620
- Yeah.


00:32:12.620 --> 00:32:17.180
- Before we move on, Kim says,


00:32:17.180 --> 00:32:20.700
"Filebeat, Logstash, Prometheus, and Protainer,"


00:32:20.700 --> 00:32:22.280
oh, Protainer, I've never heard of that one,


00:32:22.280 --> 00:32:24.660
"can all help with logs from Docker in various ways."


00:32:24.660 --> 00:32:26.600
Awesome, good resources to check out.


00:32:26.600 --> 00:32:31.080
Okay, last one on your quick hit list


00:32:31.080 --> 00:32:32.800
before we dive into some of the details


00:32:32.800 --> 00:32:35.920
is faster builds and smaller images.


00:32:35.920 --> 00:32:37.140
- Reproducible builds?


00:32:37.140 --> 00:32:38.620
I guess we did.


00:32:38.620 --> 00:32:39.540
Who needs reproducibility?


00:32:39.540 --> 00:32:41.340
Yeah, let's go with reproducibility.


00:32:41.340 --> 00:32:45.860
- Yeah, and so this is the static versus dynamic change


00:32:45.860 --> 00:32:47.980
of dependencies that you talked about,


00:32:47.980 --> 00:32:51.180
where on the one hand,


00:32:51.180 --> 00:32:52.620
you really don't want every time


00:32:52.620 --> 00:32:54.180
you reinstall your application


00:32:54.180 --> 00:32:55.580
to get the latest dependencies,


00:32:55.580 --> 00:32:58.620
because a new version of Django comes out,


00:32:58.620 --> 00:33:01.100
you don't want your code to suddenly start running on it


00:33:01.100 --> 00:33:02.740
because just because it came out.


00:33:02.740 --> 00:33:04.420
On the other hand--


00:33:04.420 --> 00:33:05.420
- Right, and maybe you're not aware, right?


00:33:05.420 --> 00:33:07.940
because you have the older version of Django,


00:33:07.940 --> 00:33:10.260
as you suggest, and you're working on it,


00:33:10.260 --> 00:33:13.260
you get push, it goes to CI,


00:33:13.260 --> 00:33:15.260
and then that ideally is going to like


00:33:15.260 --> 00:33:17.500
some sort of continuous delivery,


00:33:17.500 --> 00:33:19.220
and it's grabbed just the latest,


00:33:19.220 --> 00:33:21.220
which is not what you had, and then it runs with it.


00:33:21.220 --> 00:33:22.880
Like, that could be bad news.


00:33:22.880 --> 00:33:26.320
- Yeah, and this happens a lot with DevTools,


00:33:26.320 --> 00:33:28.740
and then like, oh, I'm gonna go check


00:33:28.740 --> 00:33:29.980
if there's been a new release today,


00:33:29.980 --> 00:33:31.340
and it matters less.


00:33:31.340 --> 00:33:34.140
But when it's your actual production software,


00:33:34.140 --> 00:33:36.620
That's not, oh, I wasted 20 minutes


00:33:36.620 --> 00:33:37.700
figuring out a failed build.


00:33:37.700 --> 00:33:41.940
It's my code is acting weird in production.


00:33:41.940 --> 00:33:42.980
- Yeah.


00:33:42.980 --> 00:33:44.820
- On the other hand, if you just freeze


00:33:44.820 --> 00:33:47.440
all your dependencies and never change them,


00:33:47.440 --> 00:33:49.300
then at some point you're gonna be running


00:33:49.300 --> 00:33:52.900
on a version of software from two or three


00:33:52.900 --> 00:33:54.100
or five years ago.


00:33:54.100 --> 00:34:00.380
The extreme case is like there are organizations


00:34:00.380 --> 00:34:02.300
still running on Python 2.


00:34:02.300 --> 00:34:06.240
And this becomes very problematic


00:34:06.240 --> 00:34:09.320
because upgrades become more and more terrifying


00:34:09.320 --> 00:34:10.980
the more you put them off.


00:34:10.980 --> 00:34:13.020
Because it's not just like Django,


00:34:13.020 --> 00:34:16.700
it's like you have to upgrade Python and Django


00:34:16.700 --> 00:34:19.780
and three other major libraries you depend on.


00:34:19.780 --> 00:34:24.780
And it's like this project,


00:34:24.780 --> 00:34:26.940
and it's a project that's not features


00:34:26.940 --> 00:34:29.620
or bug fixers or anything, it's just risk.


00:34:29.620 --> 00:34:31.620
But if you put it off more, then it's more risk.


00:34:31.620 --> 00:34:33.660
And so you need a process that's ongoing.


00:34:33.660 --> 00:34:35.740
So you need both in the short term


00:34:35.740 --> 00:34:40.900
to make sure your builds are identical, reproducible,


00:34:40.900 --> 00:34:42.940
and long, or mostly identical.


00:34:42.940 --> 00:34:44.860
And then in the long term, you need the process


00:34:44.860 --> 00:34:47.460
to continuously update so that upgrades are not


00:34:47.460 --> 00:34:48.420
this terrifying thing.


00:34:48.420 --> 00:34:51.500
They're just a standard part of your development process.


00:34:51.500 --> 00:34:53.820
Yeah.


00:34:53.820 --> 00:34:57.380
I had Carlton and Will on from Django Chat a while ago


00:34:57.380 --> 00:34:58.940
talking about deployment.


00:34:58.940 --> 00:35:01.340
And we came up with the idea that there are basically


00:35:01.340 --> 00:35:03.620
two types of applications.


00:35:03.620 --> 00:35:05.380
There's ones that you're going to continue


00:35:05.380 --> 00:35:07.980
to add features to and you're going to care about.


00:35:07.980 --> 00:35:09.940
And you have maybe a team dedicated to it.


00:35:09.940 --> 00:35:11.880
And for those, you never want to be that far


00:35:11.880 --> 00:35:13.440
from the latest thing.


00:35:13.440 --> 00:35:15.620
Just like you described, the farther you get,


00:35:15.620 --> 00:35:19.420
the more frightening, the more potential problems you have


00:35:19.420 --> 00:35:21.260
if we take on the latest, right?


00:35:21.260 --> 00:35:25.180
'Cause if you're on Django 2 and it's Django 4.5


00:35:25.180 --> 00:35:26.980
is out in some future world,


00:35:26.980 --> 00:35:29.100
you're like, well, we finally need to move to get that


00:35:29.100 --> 00:35:30.860
'cause the other one's gone fully unsupported.


00:35:30.860 --> 00:35:32.940
well, that's like you said, as a project.


00:35:32.940 --> 00:35:34.860
But if you're always kind of just in dev,


00:35:34.860 --> 00:35:36.060
sort of rolling into later one


00:35:36.060 --> 00:35:37.060
and then deciding to roll that out,


00:35:37.060 --> 00:35:40.340
like that's a much smaller challenge.


00:35:40.340 --> 00:35:42.100
So those should absolutely stay there.


00:35:42.100 --> 00:35:47.060
Also, we talked about a set of apps,


00:35:47.060 --> 00:35:50.580
a type of app that falls into the, please don't touch it.


00:35:50.580 --> 00:35:54.340
And if you do touch it and break it, it is now your baby.


00:35:54.340 --> 00:35:56.300
It's some horrible legacy code.


00:35:56.300 --> 00:35:57.260
The person who created it


00:35:57.260 --> 00:35:59.380
probably doesn't work at the company anymore.


00:35:59.380 --> 00:36:00.460
Nobody really likes it.


00:36:00.460 --> 00:36:03.540
It's not important, but it needs to be there.


00:36:03.540 --> 00:36:05.300
Like it's some internal app or something, right?


00:36:05.300 --> 00:36:09.380
Like maybe those, you just freeze those in time.


00:36:09.380 --> 00:36:11.940
They're very likely not public facing or something.


00:36:11.940 --> 00:36:15.760
But certainly if you care about continuing to work


00:36:15.760 --> 00:36:17.460
on this thing and adding features to it,


00:36:17.460 --> 00:36:22.340
and it matters, then keep it not too far.


00:36:22.340 --> 00:36:23.940
All right, so that's the tension.


00:36:23.940 --> 00:36:27.140
You don't want to just constantly ship the latest thing


00:36:27.140 --> 00:36:29.580
'cause maybe that's a major release of some library,


00:36:29.580 --> 00:36:31.820
but at the same time, you don't want to freeze it.


00:36:31.820 --> 00:36:32.660
- Yeah.


00:36:32.660 --> 00:36:37.020
- Quick comment back to the monolith.


00:36:37.020 --> 00:36:39.780
Tolin says, "Can you speak to microservices


00:36:39.780 --> 00:36:46.020
"versus monolith, in particular for ML applications?"


00:36:46.020 --> 00:36:49.260
I think that's a little bit different.


00:36:49.260 --> 00:36:51.260
I hadn't really thought of it from an ML perspective.


00:36:51.260 --> 00:36:52.660
You got thoughts?


00:36:52.660 --> 00:36:55.180
- My decent rule of thumb is,


00:36:55.180 --> 00:36:56.780
are you working on a web application


00:36:56.780 --> 00:36:58.060
where there's hundreds of developers


00:36:58.060 --> 00:37:00.460
working on that application?


00:37:00.460 --> 00:37:04.140
And if the answer is yes, then someone in the organization


00:37:04.140 --> 00:37:08.340
is going to bring up microservices.


00:37:08.340 --> 00:37:12.700
Anything smaller than that, just don't think about it.


00:37:12.700 --> 00:37:19.300
It's like-- there's-- and I tend to feel--


00:37:19.300 --> 00:37:21.500
once you're small enough, I tend to feel the same way


00:37:21.500 --> 00:37:22.940
about Kubernetes.


00:37:22.940 --> 00:37:24.260
There is a lot of--


00:37:24.260 --> 00:37:27.540
technologies for a company with 5,000 people or 500 people


00:37:27.540 --> 00:37:30.180
or 50 people or five people or one person,


00:37:30.180 --> 00:37:31.340
each organizational size,


00:37:31.340 --> 00:37:32.740
you're gonna want different technologies


00:37:32.740 --> 00:37:35.180
because different architectures,


00:37:35.180 --> 00:37:36.160
because,


00:37:36.160 --> 00:37:40.060
or I say applications would have 500 developers


00:37:40.060 --> 00:37:41.220
or five developers,


00:37:41.220 --> 00:37:43.900
because your ability to specialize,


00:37:43.900 --> 00:37:46.300
your ability to build infrastructure are different.


00:37:46.300 --> 00:37:47.260
And so,


00:37:47.260 --> 00:37:51.880
if it's a thing that an organization


00:37:51.880 --> 00:37:53.500
that has thousands of developers working,


00:37:53.500 --> 00:37:56.340
like, are you building Pinterest?


00:37:56.340 --> 00:37:57.260
Probably not.


00:37:57.260 --> 00:38:00.520
then the technology choices Pinterest makes


00:38:00.520 --> 00:38:02.200
may not be relevant to you.


00:38:02.200 --> 00:38:04.280
- Yeah, I think it may be another consideration


00:38:04.280 --> 00:38:07.080
is how much is part of that functionality shared, right?


00:38:07.080 --> 00:38:10.280
Are you building an API that has some models


00:38:10.280 --> 00:38:12.340
that make some prediction that a whole bunch


00:38:12.340 --> 00:38:15.320
of your company and different apps and websites


00:38:15.320 --> 00:38:16.840
and such might need?


00:38:16.840 --> 00:38:19.520
Then, you know, maybe that's its own thing.


00:38:19.520 --> 00:38:24.080
But if it's only being shared in one place, maybe not.


00:38:24.080 --> 00:38:27.960
There's an interesting article that was from 2019.


00:38:27.960 --> 00:38:29.960
It might be worth people checking out.


00:38:29.960 --> 00:38:36.480
Called "Give Me Back My Monolith" from Craig Kirsten.


00:38:36.480 --> 00:38:38.600
Anyway, I'm not going to go into it here,


00:38:38.600 --> 00:38:40.180
but it's kind of an interesting read.


00:38:40.180 --> 00:38:41.840
People can check that out if they want.


00:38:41.840 --> 00:38:46.600
All right.


00:38:46.600 --> 00:38:49.000
Can we talk about faster builds and small images now?


00:38:49.000 --> 00:38:49.500
We're there?


00:38:49.500 --> 00:38:50.200
I think we are.


00:38:50.200 --> 00:38:50.700
Cool.


00:38:50.700 --> 00:38:52.120
Yeah, tell us about that.


00:38:52.120 --> 00:38:54.880
people who are new to Docker haven't done a lot with Docker.


00:38:54.880 --> 00:38:59.320
There's a lot of things you can do to result


00:38:59.320 --> 00:39:04.320
in a smaller, physically a smaller image size, right?


00:39:04.320 --> 00:39:06.840
A smaller file on disk.


00:39:06.840 --> 00:39:09.840
- Yeah, it's very easy to get a giant image in Docker


00:39:09.840 --> 00:39:13.340
because the Docker image format is basically


00:39:13.340 --> 00:39:15.480
in many ways like a git history.


00:39:15.480 --> 00:39:18.800
So every time you make a change, it's not overriding,


00:39:18.800 --> 00:39:21.600
it's adding, so there's a history there.


00:39:21.600 --> 00:39:22.600
The history is always there.


00:39:22.600 --> 00:39:24.140
So if you delete a file, it doesn't


00:39:24.140 --> 00:39:26.160
make the Docker image any smaller


00:39:26.160 --> 00:39:27.720
if it was added in a previous layer.


00:39:27.720 --> 00:39:29.880
If it was added in a different layer, that's right.


00:39:29.880 --> 00:39:30.520
Yeah.


00:39:30.520 --> 00:39:33.040
And so if you structure things right,


00:39:33.040 --> 00:39:36.000
there's a bunch you can do to make your images smaller.


00:39:36.000 --> 00:39:39.280
And similarly, Docker has a bunch


00:39:39.280 --> 00:39:44.560
of features to allow you to not have


00:39:44.560 --> 00:39:47.160
to run pip install every single time you rebuild your image


00:39:47.160 --> 00:39:49.760
because the dependencies haven't changed.


00:39:49.760 --> 00:39:52.800
So it can just cache those files for you,


00:39:52.800 --> 00:39:54.360
but you have to set it up right.


00:39:54.360 --> 00:39:57.600
And you can go from a half an hour build


00:39:57.600 --> 00:40:04.600
to a one minute build, depending on how you build your Docker


00:40:04.600 --> 00:40:05.120
image.


00:40:05.120 --> 00:40:08.960
So Elipy Linux being my current favorite example,


00:40:08.960 --> 00:40:12.280
although maybe that's going to get fixed over the next year.


00:40:12.280 --> 00:40:14.780
One of the things that's super interesting about that as well


00:40:14.780 --> 00:40:19.780
the ordering as well as the grouping of those commands


00:40:19.780 --> 00:40:21.980
can really matter.


00:40:21.980 --> 00:40:25.880
So for example, if the first thing that you do


00:40:25.880 --> 00:40:29.100
in your Docker file is to copy over your source code,


00:40:29.100 --> 00:40:32.780
then the next thing to do is to do an apps update,


00:40:32.780 --> 00:40:35.580
apt upgrade, then the next thing to do


00:40:35.580 --> 00:40:40.580
is to install the dependencies and so on and so on, right?


00:40:40.580 --> 00:40:43.140
Every time any file that you're working on,


00:40:43.140 --> 00:40:45.600
even like an unrelated CSS file changes,


00:40:45.600 --> 00:40:48.040
everything below that has to be rebuilt, right?


00:40:48.040 --> 00:40:48.880
- Yeah.


00:40:48.880 --> 00:40:49.840
- And if you make a point to say,


00:40:49.840 --> 00:40:51.640
"Well, let's reorder that."


00:40:51.640 --> 00:40:55.080
So the very last thing we do is copy our files over.


00:40:55.080 --> 00:40:57.160
Then as you make changes,


00:40:57.160 --> 00:40:59.760
those other layers will just be up to date.


00:40:59.760 --> 00:41:02.040
And one cool trick that I've seen


00:41:02.040 --> 00:41:04.100
that you can make that even better is


00:41:04.100 --> 00:41:05.600
somewhere in that intermediate bit,


00:41:05.600 --> 00:41:07.840
you could even copy your requirements


00:41:07.840 --> 00:41:11.900
or pyproject.toml file over and then install those


00:41:11.900 --> 00:41:13.740
and then copy the rest of your code over,


00:41:13.740 --> 00:41:15.980
which looks like a stupid duplication.


00:41:15.980 --> 00:41:17.420
Like, why are you just copy this one file?


00:41:17.420 --> 00:41:19.140
You already copied it in the next one,


00:41:19.140 --> 00:41:21.540
but you can cache that pip install,


00:41:21.540 --> 00:41:24.660
pip compile step, make it faster.


00:41:24.660 --> 00:41:28.540
- Yeah, yeah, but basically if you understand


00:41:28.540 --> 00:41:30.340
how Docker caching works,


00:41:30.340 --> 00:41:32.940
then you can sort of structure a Docker file


00:41:32.940 --> 00:41:36.180
in the right way, and then you get caching.


00:41:36.180 --> 00:41:38.780
And then you need extra steps to get it working in CI,


00:41:38.780 --> 00:41:40.860
but you can get much faster builds.


00:41:40.860 --> 00:41:43.220
- So the fast scene is super clear.


00:41:43.220 --> 00:41:44.720
Tell us about smaller though.


00:41:44.720 --> 00:41:47.780
What are you really focused on for smaller?


00:41:47.780 --> 00:41:49.380
- So a lot of it,


00:41:49.380 --> 00:41:53.980
so some of it is just things where various packaging tools


00:41:53.980 --> 00:41:57.980
are optimized for development by default.


00:41:57.980 --> 00:42:01.400
So if you do pip install and you do something like numpy,


00:42:01.400 --> 00:42:05.380
this can be, or if you did say,


00:42:05.380 --> 00:42:09.820
let's go the big packages, like things like TensorFlow,


00:42:09.820 --> 00:42:12.520
like some of these packages are hundreds of megabytes,


00:42:12.520 --> 00:42:14.720
like they're just huge.


00:42:14.720 --> 00:42:16.540
So you download the package,


00:42:16.540 --> 00:42:19.540
and then it unpacks it and installs all the files.


00:42:19.540 --> 00:42:20.380
And then by default,


00:42:20.380 --> 00:42:23.460
Pip will keep a copy of that downloaded file.


00:42:23.460 --> 00:42:25.620
- Probably the intermediate build output.


00:42:25.620 --> 00:42:26.900
- The wheel file you download.


00:42:26.900 --> 00:42:28.340
- Potentially all that stuff, yeah.


00:42:28.340 --> 00:42:30.460
- It'll just keep a copy of the wheel file.


00:42:30.460 --> 00:42:34.700
The idea is, like you might be doing another virtual end


00:42:34.700 --> 00:42:37.100
in another two hours,


00:42:37.100 --> 00:42:38.540
and so when you do pip install this time,


00:42:38.540 --> 00:42:39.880
It doesn't have to download it.


00:42:39.880 --> 00:42:41.820
It can just use the cache version.


00:42:41.820 --> 00:42:43.960
And for development, that's great.


00:42:43.960 --> 00:42:47.120
But for a Docker image, you are never


00:42:47.120 --> 00:42:49.000
going to call a pip install again.


00:42:49.000 --> 00:42:52.040
So keeping this file is just like an extra 400 megabytes


00:42:52.040 --> 00:42:52.760
of disk space.


00:42:52.760 --> 00:42:55.160
And so there's a command line option for a pip install.


00:42:55.160 --> 00:42:58.480
It says --new cached here.


00:42:58.480 --> 00:42:59.760
And then it doesn't keep a copy.


00:42:59.760 --> 00:43:04.360
And now you're free to put a bunch of space


00:43:04.360 --> 00:43:07.440
adding, which can be fairly considerable if you're


00:43:07.440 --> 00:43:10.880
doing certain, especially for data science tools.


00:43:10.880 --> 00:43:13.080
>> You added up across all the dependencies


00:43:13.080 --> 00:43:15.400
and their expansive dependencies and so on.


00:43:15.400 --> 00:43:21.720
>> Yeah. That's just not storing files you don't need.


00:43:21.720 --> 00:43:25.680
>> Yeah. One of the mind shifts you got to get


00:43:25.680 --> 00:43:28.040
into to work with this stuff is,


00:43:28.040 --> 00:43:32.800
you will never ever change the Docker configuration.


00:43:32.800 --> 00:43:35.480
It's not like, "Oh, there's updates to Linux.


00:43:35.480 --> 00:43:37.480
So I'm going to go in and like apt update it,


00:43:37.480 --> 00:43:39.000
or there's an update to my requirements.


00:43:39.000 --> 00:43:41.360
So I'm going to reinstall the requirements.


00:43:41.360 --> 00:43:42.920
You recreate a new Docker image


00:43:42.920 --> 00:43:44.860
and you throw away the old Docker image, right?


00:43:44.860 --> 00:43:47.020
So there's a lot of the things that are there


00:43:47.020 --> 00:43:50.240
to make that next step, right?


00:43:50.240 --> 00:43:53.160
Pip installing again, work well,


00:43:53.160 --> 00:43:56.640
are just liabilities and negative effects


00:43:56.640 --> 00:43:58.440
on your Docker image, right?


00:43:58.440 --> 00:44:02.380
- Yeah, because Docker images are sort of designed


00:44:02.380 --> 00:44:04.200
to be treated as immutable artifacts.


00:44:05.360 --> 00:44:10.860
is sort of great, but also like you're dealing with a whole bunch of tools that don't really


00:44:10.860 --> 00:44:18.440
have that assumption. And so you have to figure out ways to make those two conflicting goals


00:44:18.440 --> 00:44:19.720
work together.


00:44:19.720 --> 00:44:25.940
Yeah. Another interesting thing that Peter brought up, Peter McKee, in the other episode


00:44:25.940 --> 00:44:32.360
we did not too long ago, was intermediate frameworks and all sorts of stuff. It doesn't


00:44:32.360 --> 00:44:38.200
apply super well to the Python space, but maybe there's certain aspects, especially in the data


00:44:38.200 --> 00:44:44.520
science side, that might. So for example, if you're going to install like the development setup for


00:44:44.520 --> 00:44:48.600
Python, not just the ability to run, but to do pip installs and do all sorts of things.


00:44:48.600 --> 00:44:53.800
The example he gave was if you're going to have something that runs in Go,


00:44:53.800 --> 00:44:58.520
well, what are the steps you might install, might do is like, well, we're going to install the Go


00:44:58.520 --> 00:45:02.840
compiler and all that business, and we're going to compile the artifact and you would try to run it.


00:45:02.840 --> 00:45:07.800
It's like we could create a separate container that will take the code and compile it and give


00:45:07.800 --> 00:45:13.400
you the binary, just copy the binary without the compiler back in there. So maybe there's some


00:45:13.400 --> 00:45:16.920
techniques like that. I don't know. I mean, I don't see it quite as well in Python because we


00:45:16.920 --> 00:45:24.280
can't fully package it up as reliably. But yeah, so a common, so this happens a bunch if you're


00:45:24.280 --> 00:45:27.000
like compiling your own custom C extensions.


00:45:27.000 --> 00:45:28.000
Yeah.


00:45:28.000 --> 00:45:31.080
So one way you can deal with that is like you can have a thing that generates wheels


00:45:31.080 --> 00:45:35.240
and then like you build your Docker images, download the compiled wheel.


00:45:35.240 --> 00:45:40.000
But if you want to do it in your Docker image, you're going to have to install a compiler,


00:45:40.000 --> 00:45:45.240
but then you know, that compiler package is going to be in your final image.


00:45:45.240 --> 00:45:49.480
So it just makes your image bigger, you don't need GCC.


00:45:49.480 --> 00:45:54.000
And so you can use a multi stage build, which is probably what he was describing.


00:45:54.000 --> 00:45:56.760
- Yeah, and so the one easy way to do that


00:45:56.760 --> 00:46:00.080
is you create a virtualenv, install all your code,


00:46:00.080 --> 00:46:02.480
and then you copy just the virtualenv


00:46:02.480 --> 00:46:04.160
into a new Docker image.


00:46:04.160 --> 00:46:07.400
And then the new Docker image just has the resulting


00:46:07.400 --> 00:46:08.240
self-contained virtualenv.


00:46:08.240 --> 00:46:09.680
It doesn't have any of the compilers


00:46:09.680 --> 00:46:10.880
that you needed to build it.


00:46:10.880 --> 00:46:14.120
- Right, no matter what else might have been over there.


00:46:14.120 --> 00:46:14.960
- Yeah.


00:46:14.960 --> 00:46:16.320
- Yeah, maybe you could even use something like pex


00:46:16.320 --> 00:46:18.160
if you really care to compile that


00:46:18.160 --> 00:46:21.040
or to bundle that into a zip and then run that directly.


00:46:21.040 --> 00:46:22.920
I'm not sure, but possibly.


00:46:22.920 --> 00:46:24.980
Kim out there in the live stream says,


00:46:24.980 --> 00:46:28.200
"--no cache, Jir has made my evening, thanks.


00:46:28.200 --> 00:46:29.040
I never thought about it,


00:46:29.040 --> 00:46:31.440
the intermediate files from pip only from apt."


00:46:31.440 --> 00:46:37.440
Yeah, then also Docker on build option


00:46:37.440 --> 00:46:39.360
can help a bit with that scenario,


00:46:39.360 --> 00:46:40.520
but not including the dev tools.


00:46:40.520 --> 00:46:41.360
Okay, that's cool.


00:46:41.360 --> 00:46:43.520
- We may have deprecated on builds.


00:46:43.520 --> 00:46:47.040
I could be misremembering.


00:46:47.040 --> 00:46:49.520
- That would be too bad, 'cause I just learned about it.


00:46:49.520 --> 00:46:50.880
(laughs)


00:46:50.880 --> 00:46:53.940
Okay, so those are the six things that you talk about


00:46:53.940 --> 00:46:56.360
in this iterative process or this layered process.


00:46:56.360 --> 00:46:58.920
Like step one, your first deliverable,


00:46:58.920 --> 00:47:03.320
your first package of this as Docker sprint


00:47:03.320 --> 00:47:06.740
would be get something working in either the single container


00:47:06.740 --> 00:47:09.560
or the suite of containers from Docker Compose.


00:47:09.560 --> 00:47:11.320
Step two is make sure they're secure.


00:47:11.320 --> 00:47:12.980
Step three, getting them running in CI.


00:47:12.980 --> 00:47:16.800
Step four, make sure that they're correct and debuggable.


00:47:16.800 --> 00:47:18.720
Number five is reproducibility


00:47:19.640 --> 00:47:22.940
with that balance of not exactly the latest,


00:47:22.940 --> 00:47:24.320
but not super old and stale,


00:47:24.320 --> 00:47:27.720
and then finally fast builds and small images.


00:47:27.720 --> 00:47:28.560
- Yep.


00:47:28.560 --> 00:47:31.240
And then along the way,


00:47:31.240 --> 00:47:34.560
there's a whole bunch of different things you can do,


00:47:34.560 --> 00:47:36.720
depending what tools you're using


00:47:36.720 --> 00:47:39.080
and what your priorities are.


00:47:39.080 --> 00:47:43.800
And maybe give some examples if we have time.


00:47:43.800 --> 00:47:44.640
- Yeah, absolutely.


00:47:44.640 --> 00:47:45.460
We got a little bit of time.


00:47:45.460 --> 00:47:46.300
I thought that'd be fun.


00:47:46.300 --> 00:47:49.040
So we could dive into just get something working,


00:47:49.040 --> 00:47:54.040
which is like a couple of lines in Docker,


00:47:54.040 --> 00:47:57.380
like see Docker symbol.


00:47:57.380 --> 00:47:59.640
- Yeah, you choose a base image,


00:47:59.640 --> 00:48:02.380
copy your code and run pip install


00:48:02.380 --> 00:48:04.420
and say this is what I want you to run when you start up.


00:48:04.420 --> 00:48:06.780
And for many applications, I'll do the trick.


00:48:06.780 --> 00:48:11.940
- So I'm always wondering what is a good container base


00:48:11.940 --> 00:48:13.920
to start from, right?


00:48:13.920 --> 00:48:18.920
So you have this Python 3.9 Slim Buster version


00:48:18.980 --> 00:48:20.220
as the base.


00:48:20.220 --> 00:48:22.820
- Yeah, so.


00:48:22.820 --> 00:48:24.180
- There's a bunch of different options, right?


00:48:24.180 --> 00:48:25.900
What do you think?


00:48:25.900 --> 00:48:28.320
- So the first thing is you want a,


00:48:28.320 --> 00:48:30.500
these are all based on Linux distributions typically.


00:48:30.500 --> 00:48:32.020
And so you want a Linux distribution


00:48:32.020 --> 00:48:33.740
that's some sort of long-term support


00:48:33.740 --> 00:48:37.180
where like they are both guaranteeing backwards compatibility


00:48:37.180 --> 00:48:39.740
in terms of like binary ABIs,


00:48:39.740 --> 00:48:41.620
but also in terms of features,


00:48:41.620 --> 00:48:43.720
but they're also doing security backwards.


00:48:43.720 --> 00:48:47.660
So like Debian stable, Ubuntu long-term support,


00:48:47.660 --> 00:48:49.980
Red Hat Enterprise Linux, they all


00:48:49.980 --> 00:48:53.460
are going to give you this stability guarantee.


00:48:53.460 --> 00:48:56.140
They'll say, we'll give you a stable operating system


00:48:56.140 --> 00:48:58.660
with security updates to it.


00:48:58.660 --> 00:49:02.060
So you want something that's based on one of those probably.


00:49:02.060 --> 00:49:07.940
And then you typically are going to want an up-to-date Python.


00:49:07.940 --> 00:49:13.140
And these distributions will sometimes


00:49:13.140 --> 00:49:17.300
like backport new versions of Python.


00:49:17.300 --> 00:49:18.660
And so you can use that.


00:49:18.660 --> 00:49:22.820
So you can say, I'm going to use Ubuntu long-term support


00:49:22.820 --> 00:49:26.660
from 2020, and it has Python 3.8,


00:49:26.660 --> 00:49:28.340
and maybe they just added 3.9.


00:49:28.340 --> 00:49:29.100
I'm not sure.


00:49:29.100 --> 00:49:30.660
I saw something to that effect.


00:49:30.660 --> 00:49:33.380
And then you can go with that.


00:49:33.380 --> 00:49:39.700
Or Docker maintains these things for the official, in quotes,


00:49:39.700 --> 00:49:42.220
"Docker images" for Python.


00:49:42.220 --> 00:49:45.460
Basically, what they do is they take a Debian stable,


00:49:45.460 --> 00:49:47.940
And then they compile all the different versions


00:49:47.940 --> 00:49:48.780
of Python for us.


00:49:48.780 --> 00:49:52.180
You can get 3.7 or 3.8 or 3.9 and 3.10 when it comes out,


00:49:52.180 --> 00:49:54.100
regardless of what's in Debian stable.


00:49:54.100 --> 00:49:56.700
So it's Debian stable plus an extra Python.


00:49:56.700 --> 00:50:01.700
So Python colon 3.9 is Debian stable plus 3.9.


00:50:01.700 --> 00:50:04.000
Then they have two variants.


00:50:04.000 --> 00:50:06.980
One has a bunch of extra packages and one has fewer.


00:50:06.980 --> 00:50:10.140
The one with fewer packages is the dash slim.


00:50:10.140 --> 00:50:12.140
And then the dash buster is which version


00:50:12.140 --> 00:50:14.660
of Debian you're using.


00:50:14.660 --> 00:50:16.900
And the reason you don't have to specify that,


00:50:16.900 --> 00:50:20.300
but like maybe like at the end of the year,


00:50:20.300 --> 00:50:21.300
maybe early next year,


00:50:21.300 --> 00:50:23.820
there's gonna be a new version of Debian stable.


00:50:23.820 --> 00:50:27.980
And so you don't want overnight to go from Debian 10


00:50:27.980 --> 00:50:30.300
to Debian 11 as your base image, probably.


00:50:30.300 --> 00:50:32.900
- You would probably want to just


00:50:32.900 --> 00:50:35.260
at least do that consciously, right?


00:50:35.260 --> 00:50:37.300
- And so putting the, yeah,


00:50:37.300 --> 00:50:39.300
saying dash buster means I want to stick


00:50:39.300 --> 00:50:41.420
to Debian 10 buster.


00:50:41.420 --> 00:50:42.980
And for those who don't know,


00:50:42.980 --> 00:50:46.960
Debian Linux releases are based on Toy Story characters.


00:50:46.960 --> 00:50:52.020
- Nice, so yeah, Buster's one of them, right?


00:50:52.020 --> 00:50:55.820
- Yeah, and I don't remember what the next one is.


00:50:55.820 --> 00:50:59.260
There's Debian Unstable, which is named Sid.


00:50:59.260 --> 00:51:01.580
It's always Debian Unstable, and it's always Sid.


00:51:01.580 --> 00:51:02.680
They never release it.


00:51:02.680 --> 00:51:05.540
- That's cool.


00:51:05.540 --> 00:51:09.740
All right, so in this example, the Docker file says,


00:51:09.740 --> 00:51:13.140
from Python colon 3.9 dash slim dash buster,


00:51:13.140 --> 00:51:16.540
which means all the stuff that you described there.


00:51:16.540 --> 00:51:17.940
And then you copy your files over,


00:51:17.940 --> 00:51:21.900
you run pip install to run install the dependencies.


00:51:21.900 --> 00:51:24.380
And then you just basically start your app


00:51:24.380 --> 00:51:25.220
as the entry point.


00:51:25.220 --> 00:51:27.380
And that is, hey, we got something working.


00:51:27.380 --> 00:51:29.780
This is probably an oversimplification.


00:51:29.780 --> 00:51:31.580
There might be a database thing


00:51:31.580 --> 00:51:34.780
that also needs to start up and run its bits and so on.


00:51:34.780 --> 00:51:36.940
But yeah, that's pretty much it, right?


00:51:36.940 --> 00:51:39.740
It's pretty simple, typically pretty simple


00:51:39.740 --> 00:51:40.780
to just get everything's working


00:51:40.780 --> 00:51:43.700
because it's just install some packages


00:51:43.700 --> 00:51:45.700
and then run this test to tell it to run the script


00:51:45.700 --> 00:51:47.260
when you run a container.


00:51:47.260 --> 00:51:51.180
- Yeah, it's pretty much whatever you need to do


00:51:51.180 --> 00:51:53.740
to get a new machine set up to run this,


00:51:53.740 --> 00:51:55.900
do that in this file and you're good to go.


00:51:55.900 --> 00:52:01.340
- Yeah, and I guess I'm seeing a comment on the chat


00:52:01.340 --> 00:52:04.140
and I should add that as far as I can tell,


00:52:04.140 --> 00:52:09.140
Docker on build is not deprecated, but I'm not sure.


00:52:09.140 --> 00:52:10.320
- All right, all right.


00:52:10.320 --> 00:52:12.880
Sounds good.


00:52:12.880 --> 00:52:15.600
So getting it working is super straightforward,


00:52:15.600 --> 00:52:19.100
but getting something secure is interesting.


00:52:19.100 --> 00:52:23.440
I think, let me go back.


00:52:23.440 --> 00:52:24.920
I think we might be skipping around a bit,


00:52:24.920 --> 00:52:28.200
but you're talking about having that version specified there


00:52:28.200 --> 00:52:30.240
of Slim Buster.


00:52:32.760 --> 00:52:37.020
I know how we'll get new dependencies


00:52:37.020 --> 00:52:38.280
for the Python code up there.


00:52:38.280 --> 00:52:39.980
And if there's some kind of security problem,


00:52:39.980 --> 00:52:43.360
what will probably happen is Dependabot on GitHub


00:52:43.360 --> 00:52:45.940
will send me a PR that says,


00:52:45.940 --> 00:52:48.140
warning, warning, your version of web framework


00:52:48.140 --> 00:52:49.620
has such and such CVE.


00:52:49.620 --> 00:52:51.280
We've created a PR.


00:52:51.280 --> 00:52:52.580
You accept it.


00:52:52.580 --> 00:52:54.180
You push it back to the right branch.


00:52:54.180 --> 00:52:55.580
That kicks off the whole process


00:52:55.580 --> 00:52:57.460
and everything goes again, right?


00:52:57.460 --> 00:53:02.460
So that keeps like the flow of the somewhat fresh code


00:53:02.460 --> 00:53:05.880
and dependencies going through your system.


00:53:05.880 --> 00:53:10.880
However, how do I keep that same thing happening for Linux?


00:53:10.880 --> 00:53:16.640
Suppose Linux has some security vulnerability


00:53:16.640 --> 00:53:17.840
in the version that I've got,


00:53:17.840 --> 00:53:21.960
or I've got Nginx running and it has something like that


00:53:21.960 --> 00:53:22.800
I need to update.


00:53:22.800 --> 00:53:26.080
Like what is the trigger that helps me know?


00:53:26.080 --> 00:53:28.360
Like what is the process that helps me know?


00:53:28.360 --> 00:53:31.280
Oh, you need to, even if this is a somewhat stable,


00:53:31.280 --> 00:53:34.880
stale project that we haven't touched for a month, you need to somehow go give it a


00:53:34.880 --> 00:53:40.440
kick to like force it to get the latest and do that again. Because there's no auto app


00:53:40.440 --> 00:53:43.840
update upgrade running there.


00:53:43.840 --> 00:53:49.600
Yeah. So one, one thing to notice some people assume that the Debian, like the official


00:53:49.600 --> 00:53:55.560
Python or even official Debian or whatever, the official base images from Docker get security


00:53:55.560 --> 00:54:02.760
updates every time they come out, they don't. Some of them get updated fairly frequently.


00:54:02.760 --> 00:54:06.640
Some of them, like the CentOS one, which I guess people are probably swishing away from,


00:54:06.640 --> 00:54:11.720
but for a while, a lot of people were probably using it. The CentOS base image will not be


00:54:11.720 --> 00:54:19.600
updated for months at a time. And so they are relying on, and the Debian ones, well,


00:54:19.600 --> 00:54:24.520
I have seen them lag on security updates by two weeks. So Debian has released a new security


00:54:24.520 --> 00:54:27.220
update but the Docker image hasn't been updated.


00:54:27.220 --> 00:54:30.700
Which is not ideal because you're telling all the hackers, "Here's the problem that


00:54:30.700 --> 00:54:34.300
you can just go look for in systems that lag on getting their patches."


00:54:34.300 --> 00:54:41.880
Yeah, and so you as someone who is creating a Docker image cannot rely on the base images


00:54:41.880 --> 00:54:43.660
to be up to date.


00:54:43.660 --> 00:54:49.300
You need to install security updates when you build your Docker image.


00:54:49.300 --> 00:54:51.180
What's that look like?


00:54:51.180 --> 00:54:55.100
Step two is apt update, apt upgrade, dash Y, or something like that?


00:54:55.100 --> 00:54:58.500
Yeah, apt get update, and then apt get minus Y upgrade.


00:54:58.500 --> 00:55:02.820
You can add a few more command line options to make your image smaller, but yeah, it's


00:55:02.820 --> 00:55:04.860
basically do an upgrade.


00:55:04.860 --> 00:55:08.260
But there's a problem.


00:55:08.260 --> 00:55:12.340
Docker has, as we talked about, has this caching thing where if you rebuild an image and nothing's


00:55:12.340 --> 00:55:15.260
changed, it will just use a cache layer.


00:55:15.260 --> 00:55:19.220
So when you rebuild your image, if you're using caching to speed up builds, it'll look


00:55:19.220 --> 00:55:24.300
at Docker, look at the app get update, app get upgrade and say, "Well, this is unchanged,


00:55:24.300 --> 00:55:25.300
same command."


00:55:25.300 --> 00:55:26.300
And so it'll just use a cache.


00:55:26.300 --> 00:55:31.260
- Yeah, and you absolutely will very likely be doing that because it's like five minutes


00:55:31.260 --> 00:55:35.380
versus three seconds to restart and build and test your app.


00:55:35.380 --> 00:55:38.280
So everyone is gonna be using the caching.


00:55:38.280 --> 00:55:40.500
Maybe not in CI/CD, but everywhere else.


00:55:40.500 --> 00:55:44.300
- I mean, you probably typically will want it in CI/CD too.


00:55:44.300 --> 00:55:49.460
And so the result is that if you've set up caching to speed things up, that caching will


00:55:49.460 --> 00:55:54.000
ensure you don't get security updates.


00:55:54.000 --> 00:56:00.740
And so basically what you have to do is just have this process where once a day or once


00:56:00.740 --> 00:56:07.540
a week or in response to CVs coming out, you rebuild your image from scratch without caching.


00:56:07.540 --> 00:56:12.660
So you can just say every night at 3 a.m. when no one's working, we are going to rebuild


00:56:12.660 --> 00:56:16.140
our image from scratch without caching.


00:56:16.140 --> 00:56:22.260
And so our image will always have the latest security


00:56:22.260 --> 00:56:22.900
updates.


00:56:22.900 --> 00:56:25.520
And then if you're in a system that has continuous deployment,


00:56:25.520 --> 00:56:28.220
you can then just automatically deploy that.


00:56:28.220 --> 00:56:31.460
And then--


00:56:31.460 --> 00:56:32.940
>>Victor: Wait, how do you make the little banner that


00:56:32.940 --> 00:56:35.140
says you're going to be down Sunday from 3 to 5


00:56:35.140 --> 00:56:36.380
when you do that part?


00:56:36.380 --> 00:56:37.540
Just kidding.


00:56:37.540 --> 00:56:39.500
>>Mark: Yeah, so this is easier if you


00:56:39.500 --> 00:56:43.580
have a process that you trust enough


00:56:43.580 --> 00:56:46.380
to do automatic deploys any time you want.


00:56:46.380 --> 00:56:50.100
But you basically have to rebuild your image


00:56:50.100 --> 00:56:54.140
from scratch without caching, either whenever a security


00:56:54.140 --> 00:56:57.300
update comes out or just on a regular basis


00:56:57.300 --> 00:57:00.780
and redeploy if it's a server.


00:57:00.780 --> 00:57:04.380
Because you have these immutable artifacts that--


00:57:04.380 --> 00:57:07.900
if you're running a VM, you can just


00:57:07.900 --> 00:57:12.260
like a cron job that installs security updates nightly.


00:57:12.260 --> 00:57:15.500
Like there's unattended upgrades package in Debian.


00:57:15.500 --> 00:57:17.020
For Docker images, you can't do that.


00:57:17.020 --> 00:57:20.260
And so you have to rebuild from scratch with security updates


00:57:20.260 --> 00:57:21.060
and then redeploy.


00:57:21.060 --> 00:57:27.300
Yeah, I'm glad you pointed out the caching,


00:57:27.300 --> 00:57:29.100
because it's not enough to go out and say,


00:57:29.100 --> 00:57:31.340
oh, every once a day or once a week,


00:57:31.340 --> 00:57:32.540
we'll just do a Docker build.


00:57:32.540 --> 00:57:33.800
Oh, it's up to date, actually.


00:57:33.800 --> 00:57:36.060
We're good.


00:57:36.060 --> 00:57:36.900
- Not so much.


00:57:36.900 --> 00:57:38.700
- Yeah.


00:57:38.700 --> 00:57:39.520
- Yeah, and that's why I brought this up


00:57:39.520 --> 00:57:40.360
'cause I think it's tricky.


00:57:40.360 --> 00:57:42.200
Like there's a natural flow that like kicks


00:57:42.200 --> 00:57:44.800
that refresh cycle off for code,


00:57:44.800 --> 00:57:47.820
but not for the infrastructure itself,


00:57:47.820 --> 00:57:49.740
unless you think about it, so.


00:57:49.740 --> 00:57:52.220
- Yeah, so you need to explicitly think about


00:57:52.220 --> 00:57:53.260
and set up these processes,


00:57:53.260 --> 00:57:55.940
either some way to get notified of CVs,


00:57:55.940 --> 00:58:00.940
or you can probably, if you have a bunch of registries


00:58:00.940 --> 00:58:04.460
have security scanners,


00:58:04.460 --> 00:58:07.540
will scan your images for security problems.


00:58:07.540 --> 00:58:09.900
And so you can run those in a schedule maybe.


00:58:09.900 --> 00:58:14.220
- Honestly, the easiest though is probably just do


00:58:14.220 --> 00:58:17.820
a forced rebuild 5 a.m. or something.


00:58:17.820 --> 00:58:20.780
And that next time every developer that comes in


00:58:20.780 --> 00:58:23.700
and runs the command Docker compose up,


00:58:23.700 --> 00:58:24.700
it's gonna do a Docker build,


00:58:24.700 --> 00:58:25.940
it's gonna see the things out of date


00:58:25.940 --> 00:58:28.780
and it'll just trigger a let's get the fresh.


00:58:28.780 --> 00:58:29.620
- Yeah.


00:58:29.620 --> 00:58:31.620
- Yeah.


00:58:31.620 --> 00:58:34.540
And yeah, it turns out that security scanners also


00:58:34.540 --> 00:58:38.260
have some bad defaults.


00:58:38.260 --> 00:58:42.260
So you'll get-- there's a lot of security problems


00:58:42.260 --> 00:58:45.620
that are not really problems, like the upstream maintainer


00:58:45.620 --> 00:58:50.020
has closed it as won't fix, or it's not


00:58:50.020 --> 00:58:52.480
going to get fixed in Debian stable until the next release


00:58:52.480 --> 00:58:53.020
of Debian stable.


00:58:53.020 --> 00:58:54.620
And so the Debian maintainers basically


00:58:54.620 --> 00:58:56.460
have decided that it is not worth fixing.


00:58:56.460 --> 00:58:59.020
And so there's nothing you can do.


00:58:59.020 --> 00:59:00.740
Most security scanners will flag those.


00:59:00.740 --> 00:59:03.140
So you run a scanner on an updated image,


00:59:03.140 --> 00:59:07.500
and it'll say, you have 60 security vulnerabilities.


00:59:07.500 --> 00:59:09.780
But if you turn on the flag that says,


00:59:09.780 --> 00:59:11.580
only tell me about security vulnerabilities


00:59:11.580 --> 00:59:13.740
that I can actually fix, that actually


00:59:13.740 --> 00:59:15.780
have updates from Debian, and then you run that,


00:59:15.780 --> 00:59:18.100
and it'll say you're fine.


00:59:18.100 --> 00:59:20.500
And that is probably a much more realistic assessment


00:59:20.500 --> 00:59:23.340
of your risk, because it's like, there


00:59:23.340 --> 00:59:26.020
are bugs that are never going to be fixed,


00:59:26.020 --> 00:59:30.180
because the glibc maintainers have said, no, won't fix.


00:59:30.180 --> 00:59:31.260
This is not our problem.


00:59:31.260 --> 00:59:33.020
It's like--


00:59:33.020 --> 00:59:35.700
Yeah, I suspect you could also get notified about things


00:59:35.700 --> 00:59:38.540
that are not observable, really.


00:59:38.540 --> 00:59:41.140
So, oh, there's a problem in the system,


00:59:41.140 --> 00:59:44.100
but we actually have a firewall blocking that port,


00:59:44.100 --> 00:59:45.780
and we have no interaction with it, right?


00:59:45.780 --> 00:59:48.460
It's like, how much do you worry about those kinds of things?


00:59:48.460 --> 00:59:50.700
I mean, you may as well upgrade and redeploy,


00:59:50.700 --> 00:59:53.180
because maybe one day your firewall will fail.


00:59:53.180 --> 00:59:57.900
But there's a whole bunch of just utter noise


00:59:57.900 --> 01:00:01.200
if you don't configure your security scanner correctly.


01:00:01.200 --> 01:00:02.040
- Yeah.


01:00:02.040 --> 01:00:05.120
All right, wrapping up this bit of the topic.


01:00:05.120 --> 01:00:08.640
Kim says, "Forced rebuild is great for your own images


01:00:08.640 --> 01:00:09.820
"based on Debian or other OS.


01:00:09.820 --> 01:00:12.440
"You probably still need some kind of scanning."


01:00:12.440 --> 01:00:14.180
Yeah, if you're not able to build it yourself.


01:00:14.180 --> 01:00:15.360
Yeah, makes sense.


01:00:15.360 --> 01:00:18.200
All right, we got a little bit of time


01:00:18.200 --> 01:00:20.080
to touch on a couple of things.


01:00:20.080 --> 01:00:24.240
One of the areas, stage two, was security.


01:00:24.240 --> 01:00:50.240
You always want different layers. I talked about a firewall. We're talking about security updates and patches, but there's layers of security you want. And one of the very straightforward ones is you probably don't want to run this as root. And like certain systems will even warn you about this. So if I try to pseudo brew something on my Mac, it'll complain like you should never ever run brew as root. What are you doing? Are you crazy? Stop doing that.


01:00:50.240 --> 01:00:55.040
I think micro whiskey might warn that you're running this route.


01:00:55.040 --> 01:01:00.160
If you look at the logs when you started up, so when I run Docker,


01:01:00.160 --> 01:01:03.120
and I just get that simple get started one, what does that run as?


01:01:03.120 --> 01:01:06.480
Yes, so by default, Docker runs as root.


01:01:06.480 --> 01:01:08.480
And that Oh, okay.


01:01:08.480 --> 01:01:13.280
That kind of makes sense because all these system packages are designed to be installed as root.


01:01:13.280 --> 01:01:17.920
And so if you're going to install system packages or install security updates, you have to be a root by default.


01:01:17.920 --> 01:01:19.020
- Yeah.


01:01:19.020 --> 01:01:21.480
- But as soon as you've switched


01:01:21.480 --> 01:01:23.940
to like installing your Python code,


01:01:23.940 --> 01:01:26.120
you should stop being root and create a new user


01:01:26.120 --> 01:01:28.420
and switch to that user because otherwise


01:01:28.420 --> 01:01:30.000
your application will be running as root


01:01:30.000 --> 01:01:32.600
and root inside a container is more restricted,


01:01:32.600 --> 01:01:36.900
but it's still not as restricted as a normal user.


01:01:36.900 --> 01:01:39.940
And different runtime systems might take


01:01:39.940 --> 01:01:43.660
more aggressive steps to restrict what you can do.


01:01:43.660 --> 01:01:45.280
And so sometimes it might be okay,


01:01:45.280 --> 01:01:47.400
but just a good best practice.


01:01:47.400 --> 01:01:48.680
you don't know where your things are gonna run,


01:01:48.680 --> 01:01:51.280
things might change around, just don't run as root.


01:01:51.280 --> 01:01:53.880
- What you're saying is basically,


01:01:53.880 --> 01:01:55.520
if you run as root in a Docker container,


01:01:55.520 --> 01:01:58.680
and somebody takes over your container,


01:01:58.680 --> 01:02:00.360
well, the worst thing they can do is like,


01:02:00.360 --> 01:02:02.200
crash around inside of the container,


01:02:02.200 --> 01:02:04.800
it's not like they now have full access to the machine.


01:02:04.800 --> 01:02:08.800
But, maybe those writes are propagated onward,


01:02:08.800 --> 01:02:11.500
like maybe they can do something else to,


01:02:11.500 --> 01:02:13.300
I don't know, decrypt something


01:02:13.300 --> 01:02:15.080
that then gets them further in the network.


01:02:15.080 --> 01:02:16.840
Like there's challenges that can happen, right?


01:02:16.840 --> 01:02:21.120
So it is much easier to escape a container


01:02:21.120 --> 01:02:23.480
and onto the host if you're running as root.


01:02:23.480 --> 01:02:28.600
Because like in Linux, security access is granted


01:02:28.600 --> 01:02:30.400
by these things called capabilities.


01:02:30.400 --> 01:02:33.520
And if you're root,


01:02:33.520 --> 01:02:35.520
you have a little bit more capabilities.


01:02:35.520 --> 01:02:40.000
It gives you a larger attack service on Linux kernel.


01:02:40.000 --> 01:02:41.760
And so if there's a bug in the Linux kernel,


01:02:41.760 --> 01:02:44.040
it's easier to take it over if you're root.


01:02:46.280 --> 01:02:49.220
There are other things you can do to restrict all capabilities


01:02:49.220 --> 01:02:51.960
to containers, even if you're running as a normal user.


01:02:51.960 --> 01:02:55.760
So if you're running the ping utility, for example,


01:02:55.760 --> 01:02:58.480
it gets a little bit of extra--


01:02:58.480 --> 01:03:02.480
it gets an extra capability often so that it can do a ping.


01:03:02.480 --> 01:03:05.320
And then if there's a bug in the ping command,


01:03:05.320 --> 01:03:09.000
then you can insert code into it somehow.


01:03:09.000 --> 01:03:10.920
Then it'll execute it with elevated privileges


01:03:10.920 --> 01:03:12.880
and you can do more stuff.


01:03:12.880 --> 01:03:13.380
And so--


01:03:13.380 --> 01:03:14.280
Yeah.


01:03:14.280 --> 01:03:15.160
You don't want that.


01:03:15.160 --> 01:03:20.000
Yeah, and so he wants to run as a normal user that


01:03:20.000 --> 01:03:22.520
will restrict the attack surface on the Linux kernel,


01:03:22.520 --> 01:03:26.400
like removing all capabilities or restrict the attack surface


01:03:26.400 --> 01:03:27.960
even more.


01:03:27.960 --> 01:03:29.360
And you do these things.


01:03:29.360 --> 01:03:32.720
And for many applications, it won't really matter too much.


01:03:32.720 --> 01:03:37.760
But it's not a lot of work.


01:03:37.760 --> 01:03:40.200
And it's a little bit more assurance


01:03:40.200 --> 01:03:42.040
that if someone does somehow take over,


01:03:42.040 --> 01:03:43.480
they'll limit the damage they can


01:03:43.480 --> 01:03:45.480
because they're only restricted to this container.


01:03:45.480 --> 01:03:47.480
Yeah. Okay, good advice.


01:03:47.480 --> 01:03:49.480
And that uses the add user Docker command.


01:03:49.480 --> 01:03:51.480
Very cool.


01:03:51.480 --> 01:03:54.480
And then, let's see, what was the next one here?


01:03:54.480 --> 01:03:56.480
We talked about the security updates.


01:03:56.480 --> 01:03:58.480
That's a challenge.


01:03:58.480 --> 01:04:03.480
So, what do I need to think about


01:04:03.480 --> 01:04:05.480
for continuous integration and automated builds,


01:04:05.480 --> 01:04:07.480
specifically with regard to Docker?


01:04:07.480 --> 01:04:10.480
Is there anything special?


01:04:10.480 --> 01:04:14.640
- So first it's just doing the actual work of automating it.


01:04:14.640 --> 01:04:18.320
So like, it's really nice if every time you push


01:04:18.320 --> 01:04:21.160
to your Git repository, every time you pull a request,


01:04:21.160 --> 01:04:22.800
it builds a Docker image for you.


01:04:22.800 --> 01:04:26.700
Because then like you can test it,


01:04:26.700 --> 01:04:29.260
maybe you can write additional tests


01:04:29.260 --> 01:04:30.480
to actually use a Docker image,


01:04:30.480 --> 01:04:33.260
do integration tests, that sort of thing.


01:04:33.260 --> 01:04:34.460
- Yeah, like for example,


01:04:34.460 --> 01:04:37.520
there is a really cool framework or library,


01:04:37.520 --> 01:04:39.180
I can't remember exactly what it is,


01:04:39.180 --> 01:04:41.100
we talked about on Python Bytes,


01:04:41.100 --> 01:04:44.620
that instead of trying to mock out, say, your database,


01:04:44.620 --> 01:04:47.600
or it's mostly databases,


01:04:47.600 --> 01:04:51.660
there's a Docker, there's like a testing library


01:04:51.660 --> 01:04:53.980
you can use that will bring up a Docker container


01:04:53.980 --> 01:04:56.060
running Mongo or Postgres or something,


01:04:56.060 --> 01:04:57.260
and then fill it with test data,


01:04:57.260 --> 01:04:59.700
and you just connect those things and say,


01:04:59.700 --> 01:05:01.380
yeah, you can talk to the database, you don't care,


01:05:01.380 --> 01:05:03.580
it's test data, you might as well.


01:05:03.580 --> 01:05:07.140
- Yeah, testing with a real database


01:05:07.140 --> 01:05:07.980
is so much easier these days,


01:05:07.980 --> 01:05:10.860
data, it should just be the default.


01:05:10.860 --> 01:05:14.900
If you're doing deploy with Postgres, you shouldn't test with SQLite because they're


01:05:14.900 --> 01:05:21.300
different enough that there'll be bugs that you're going to miss.


01:05:21.300 --> 01:05:28.380
And so once you have that automation of building for every pull request, you start having this


01:05:28.380 --> 01:05:35.140
issue where you don't want the image you built for the feature 1, 2, 3 branch to overwrite


01:05:35.140 --> 01:05:36.500
your production image.


01:05:36.500 --> 01:05:38.780
That would be awkward.


01:05:38.780 --> 01:05:39.620
- Yeah.


01:05:39.620 --> 01:05:40.540
- And so...


01:05:40.540 --> 01:05:42.220
- But you would still like continuous integration


01:05:42.220 --> 01:05:44.660
to do its job and say, you checked in this thing,


01:05:44.660 --> 01:05:46.380
it was okay or not okay.


01:05:46.380 --> 01:05:47.220
Yeah?


01:05:47.220 --> 01:05:49.700
- And it's useful to have like images uploaded


01:05:49.700 --> 01:05:51.380
for every pull request that you can download


01:05:51.380 --> 01:05:53.140
and maybe play around with it.


01:05:53.140 --> 01:05:56.020
But you don't want feature branches images


01:05:56.020 --> 01:05:58.300
to interfere with your production image.


01:05:58.300 --> 01:06:01.020
And so one easy way to deal with that


01:06:01.020 --> 01:06:05.380
is to name your Docker images based on the Git branch.


01:06:05.380 --> 01:06:08.980
So you can just use the Git branch as the part after the colon, the tag.


01:06:08.980 --> 01:06:12.580
So it can be like your image colon main if it's the main branch,


01:06:12.580 --> 01:06:16.260
or your image colon feature one, two, three, it's the feature one, two, three branch.


01:06:16.260 --> 01:06:20.820
>> Yeah, that works really well with GitFlow feature branch style of programming as well.


01:06:20.820 --> 01:06:22.700
I create an issue,


01:06:22.700 --> 01:06:25.780
then I create a branch named something along those lines,


01:06:25.780 --> 01:06:27.900
and then I create a PR along those lines, and now guess what?


01:06:27.900 --> 01:06:30.540
Here's the container that goes with that thing, right?


01:06:30.540 --> 01:06:31.540
Yeah.


01:06:31.540 --> 01:06:32.540
Yeah.


01:06:32.540 --> 01:06:39.380
You can also do things like name your Docker image based on the git commit.


01:06:39.380 --> 01:06:42.980
So you can sort of go from git commit to corresponding Docker image really easily.


01:06:42.980 --> 01:06:43.980
Yeah.


01:06:43.980 --> 01:06:45.380
Yeah, that's a really cool idea.


01:06:45.380 --> 01:06:48.740
I did find that package, by the way, in case people are interested.


01:06:48.740 --> 01:06:52.140
It's called test containers dash Python.


01:06:52.140 --> 01:06:53.140
Yeah.


01:06:53.140 --> 01:06:59.460
Anyway, the idea is you just say like with my SQL container, do your tests.


01:06:59.460 --> 01:07:01.140
that literally creates a Docker container


01:07:01.140 --> 01:07:02.640
with your test data and all that stuff.


01:07:02.640 --> 01:07:04.300
So people can check that out.


01:07:04.300 --> 01:07:05.300
That's kind of cool.


01:07:05.300 --> 01:07:10.460
All right, well, we're getting a little bit short on time here.


01:07:10.460 --> 01:07:13.500
What else do you want to throw out for people


01:07:13.500 --> 01:07:16.660
who are thinking about a lot of these best practices?


01:07:16.660 --> 01:07:17.700
We touched on a lot of them,


01:07:17.700 --> 01:07:19.500
but I know there's plenty more to go.


01:07:19.500 --> 01:07:21.020
Like, for example, of faster builds,


01:07:21.020 --> 01:07:25.500
you talk about, say, pre-compiling the PYC files.


01:07:26.460 --> 01:07:29.740
- Oh yeah, that's more for, that actually do slower builds,


01:07:29.740 --> 01:07:31.340
but it'll give you a faster startup.


01:07:31.340 --> 01:07:32.940
- That's what I mean, yeah, sorry.


01:07:32.940 --> 01:07:37.280
- So since this comes up a bunch,


01:07:37.280 --> 01:07:40.900
Alpine Linux is not a thing you want,


01:07:40.900 --> 01:07:42.740
is often not a thing you want to use


01:07:42.740 --> 01:07:44.740
for your Docker-based image.


01:07:44.740 --> 01:07:47.900
And the reason is, Alpine Linux is highly recommended


01:07:47.900 --> 01:07:50.340
for if you want small images.


01:07:50.340 --> 01:07:52.180
And it's kind of nice because you install,


01:07:52.180 --> 01:07:54.100
like installing the Alpine packages somehow,


01:07:54.100 --> 01:07:54.940
I don't know what they do,


01:07:54.940 --> 01:07:58.860
It's vastly faster than installing Debian packages.


01:07:58.860 --> 01:08:01.860
And you get small images, and it's kind of nice.


01:08:01.860 --> 01:08:05.580
The problem is Alpine Linux uses a different standard C


01:08:05.580 --> 01:08:07.420
library than most Linux distributions.


01:08:07.420 --> 01:08:08.980
Most Linux distributions use glibc.


01:08:08.980 --> 01:08:14.100
Alpine uses musl, or musl.


01:08:14.100 --> 01:08:15.820
I don't know how to pronounce it.


01:08:15.820 --> 01:08:19.980
And binary wheels are compiled by default


01:08:19.980 --> 01:08:21.140
on Linux for glibc.


01:08:21.140 --> 01:08:22.340
And so they are--


01:08:22.340 --> 01:08:26.260
If you install Python packages on Alpine Linux,


01:08:26.260 --> 01:08:27.540
you will not get binary wheels.


01:08:27.540 --> 01:08:30.300
You're going to have to compile them from scratch.


01:08:30.300 --> 01:08:31.860
And so what happens is people say,


01:08:31.860 --> 01:08:33.100
oh, I'm going to use Alpine Linux.


01:08:33.100 --> 01:08:34.980
It's going to make my images smaller.


01:08:34.980 --> 01:08:38.220
And then they try to install like a Postgres package,


01:08:38.220 --> 01:08:40.380
which is pre-compiled and doesn't work.


01:08:40.380 --> 01:08:43.340
They're like, okay, so now I have to install a compiler


01:08:43.340 --> 01:08:45.260
and I'll install the Postgres headers.


01:08:45.260 --> 01:08:48.100
Now you have this image that has the compiler


01:08:48.100 --> 01:08:49.900
and the Postgres headers in it,


01:08:49.900 --> 01:08:52.080
and you have to compile stuff.


01:08:52.080 --> 01:08:55.360
And when you get to data science or scientific computing,


01:08:55.360 --> 01:08:57.600
you're compiling these massive packages.


01:08:57.600 --> 01:08:59.280
It takes a really long time to compile.


01:08:59.280 --> 01:09:01.120
Your builds are super slow.


01:09:01.120 --> 01:09:03.840
And you can do a whole bunch of work


01:09:03.840 --> 01:09:08.720
to then use a multi-stage build so your image is small.


01:09:08.720 --> 01:09:11.280
And then you can use caching so the builds are fast.


01:09:11.280 --> 01:09:15.920
Or you can just use a different Linux distribution


01:09:15.920 --> 01:09:17.360
and use binary builds.


01:09:17.360 --> 01:09:19.120
Yeah, don't cause yourself the challenge.


01:09:19.120 --> 01:09:21.080
Just use something else.


01:09:21.080 --> 01:09:24.400
But there is a PEP that I believe


01:09:24.400 --> 01:09:29.920
was accepted to start the process of building wheels


01:09:29.920 --> 01:09:32.400
for Alpine.


01:09:32.400 --> 01:09:34.320
And I've started seeing some packaging tools


01:09:34.320 --> 01:09:35.540
have started adding support.


01:09:35.540 --> 01:09:38.840
And so it may be that in a year or two,


01:09:38.840 --> 01:09:41.600
it'll be just like everyone builds binary wheels


01:09:41.600 --> 01:09:44.480
for many Linux, just a glibc.


01:09:44.480 --> 01:09:48.000
People might start building binary wheels for Alpine.


01:09:48.000 --> 01:09:52.040
And when that happens, there'll be much less of an issue.


01:09:52.040 --> 01:09:56.280
Until then, avoid using Alpine Linux as your base image.


01:09:56.280 --> 01:09:58.160
Yeah.


01:09:58.160 --> 01:10:01.360
You want to close it out with a PYC thing?


01:10:01.360 --> 01:10:01.840
Sure.


01:10:01.840 --> 01:10:06.960
So when you start up a Python program,


01:10:06.960 --> 01:10:10.440
it loads in your Python source files and then compiles them.


01:10:10.440 --> 01:10:12.440
And compilation here is not really


01:10:12.440 --> 01:10:13.980
the same as compiling a C extension.


01:10:13.980 --> 01:10:16.120
It's basically a one-to-one translation.


01:10:16.120 --> 01:10:20.280
It compiles them to bytecode and writes them out as PYC files.


01:10:20.280 --> 01:10:24.120
And then the next time you start,


01:10:24.120 --> 01:10:25.880
it can just load the PYC file, and that


01:10:25.880 --> 01:10:28.600
will make your application start up quickly.


01:10:28.600 --> 01:10:30.960
And so if you're doing some sort of--


01:10:30.960 --> 01:10:32.720
many applications, it doesn't matter.


01:10:32.720 --> 01:10:35.520
If you're doing a serverless kind of thing,


01:10:35.520 --> 01:10:38.960
where you want things to start up really quickly,


01:10:38.960 --> 01:10:42.600
having to compile the PYC is--


01:10:42.600 --> 01:10:44.160
it's going to add some startup time.


01:10:44.160 --> 01:10:45.280
And so what you can do is--


01:10:45.280 --> 01:10:47.760
- Any times where the container lifetime,


01:10:47.760 --> 01:10:49.600
the life cycle is short, right?


01:10:49.600 --> 01:10:51.320
Let's say with a web app, you would start it


01:10:51.320 --> 01:10:52.680
and it would run for hours.


01:10:52.680 --> 01:10:53.840
So it doesn't matter, right?


01:10:53.840 --> 01:10:56.520
- Yeah, so it's like it took you another 20 milliseconds


01:10:56.520 --> 01:10:58.000
to start, meh.


01:10:58.000 --> 01:11:01.040
It's gonna be run for three days.


01:11:01.040 --> 01:11:04.040
But if you're doing a serverless thing


01:11:04.040 --> 01:11:08.760
where like 20 milliseconds might be a significant chunk


01:11:08.760 --> 01:11:10.360
of the latency of your service.


01:11:10.360 --> 01:11:12.440
So when you build your Docker image,


01:11:12.440 --> 01:11:14.720
you can pre-compile all your PYC files


01:11:14.720 --> 01:11:17.840
and then it'll be in the image and you won't have it,


01:11:17.840 --> 01:11:19.040
and then your startup will be faster.


01:11:19.040 --> 01:11:20.760
And the reason you have to actually think about this


01:11:20.760 --> 01:11:23.760
is that Docker images are immutable.


01:11:23.760 --> 01:11:25.040
So like your container starts up,


01:11:25.040 --> 01:11:27.360
it compiles and writes the PYCs,


01:11:27.360 --> 01:11:29.960
but those PYCs never make it to the original image.


01:11:29.960 --> 01:11:31.080
Every time you start the image,


01:11:31.080 --> 01:11:33.640
it starts with the same immutable artifact,


01:11:33.640 --> 01:11:35.280
unlike your local home directory.


01:11:35.280 --> 01:11:39.120
And so if you really want the fastest startup,


01:11:39.120 --> 01:11:42.560
you can make your image a bit larger and compile the PYCs.


01:11:42.560 --> 01:11:45.320
- Basically that becomes a step in your Docker build files


01:11:45.320 --> 01:11:47.480
to compile the PYCs ahead of time.


01:11:47.480 --> 01:11:48.320
- Yeah.


01:11:48.320 --> 01:11:49.560
- Okay.


01:11:49.560 --> 01:11:51.760
Awesome, great advice, many, many tips.


01:11:51.760 --> 01:11:54.560
I think we're gonna have to leave it there.


01:11:54.560 --> 01:11:56.720
We're getting basically running out of time,


01:11:56.720 --> 01:11:58.560
but yeah, really nice talk.


01:11:58.560 --> 01:12:00.520
I'll link to your talk that you did at PyCon


01:12:00.520 --> 01:12:01.680
and thanks for coming here


01:12:01.680 --> 01:12:03.520
and sharing the audio version with us.


01:12:03.520 --> 01:12:05.120
- No, thanks for inviting me.


01:12:05.120 --> 01:12:06.080
- Of course.


01:12:06.080 --> 01:12:06.920
Before you get out of here though,


01:12:06.920 --> 01:12:08.080
there's the final two questions.


01:12:08.080 --> 01:12:09.460
If you're gonna write some Python code,


01:12:09.460 --> 01:12:11.360
what editor do you use?


01:12:11.360 --> 01:12:15.300
I use SpaceMax, which is kind of like they took Emacs


01:12:15.300 --> 01:12:17.000
and they configured it like 20 years.


01:12:17.000 --> 01:12:20.160
That's like you're jumping 20 years into the future.


01:12:20.160 --> 01:12:21.840
It's like it's Emacs, but with all the things


01:12:21.840 --> 01:12:23.900
you need pre-configured to actually


01:12:23.900 --> 01:12:28.080
have a nice development environment.


01:12:28.080 --> 01:12:30.280
And it has VI bindings and Emacs bindings.


01:12:30.280 --> 01:12:31.480
I use the Emacs bindings.


01:12:31.480 --> 01:12:34.240
But if you like VM, you can use the VI bindings.


01:12:34.240 --> 01:12:35.600
- Yeah, cool.


01:12:35.600 --> 01:12:38.320
Their subtitle and sub-subtitles,


01:12:38.320 --> 01:12:40.280
a community-driven Emacs distribution.


01:12:40.280 --> 01:12:42.360
The best editor is neither Emacs nor Vim.


01:12:42.360 --> 01:12:44.320
It's Emacs and Vim.


01:12:44.320 --> 01:12:46.440
- I honestly don't use the Vim bindings at all.


01:12:46.440 --> 01:12:48.260
I'm using it for like,


01:12:48.260 --> 01:12:53.320
it does all the IDE stuff you want out of the box.


01:12:53.320 --> 01:12:57.160
And so it's just, it's a much more modern experience.


01:12:57.160 --> 01:12:59.280
- Okay, really cool.


01:12:59.280 --> 01:13:01.180
And then notable PyPI package?


01:13:01.180 --> 01:13:07.520
- Py03, which is a way to create Python extensions in Rust.


01:13:07.880 --> 01:13:12.880
I've used it to create most of our fill, my memory profiler.


01:13:12.880 --> 01:13:15.940
Also I wrapped some Rust library with it.


01:13:15.940 --> 01:13:19.640
It's really, really nice way to create


01:13:19.640 --> 01:13:24.080
fast, safe extensions for Python.


01:13:24.080 --> 01:13:27.480
And it comes, there's a packaging tool called Maturin,


01:13:27.480 --> 01:13:30.640
M-A-T-U-R-I-N, which was probably the nicest


01:13:30.640 --> 01:13:33.300
Python packaging experience I've ever had.


01:13:33.300 --> 01:13:35.540
Like you add like three lines,


01:13:35.540 --> 01:13:37.380
like you had a PyProject line file,


01:13:37.380 --> 01:13:40.040
which is like three lines, you add like a tiny bit


01:13:40.040 --> 01:13:42.740
of metadata, and now you can build wheels


01:13:42.740 --> 01:13:45.260
and you can pip install and it just works.


01:13:45.260 --> 01:13:50.260
And it's just amazingly smooth development experience.


01:13:50.260 --> 01:13:53.080
- Oh, that's fantastic.


01:13:53.080 --> 01:13:53.920
- Yeah.


01:13:53.920 --> 01:13:56.700
- So basically if you're gonna write C extensions,


01:13:56.700 --> 01:13:58.860
maybe reconsider that and write them in Rust


01:13:58.860 --> 01:14:00.600
and use this, possibly?


01:14:00.600 --> 01:14:05.000
- Yeah, it's like Rust is,


01:14:05.000 --> 01:14:07.520
like gives you the same performance


01:14:07.520 --> 01:14:10.280
that you would get from C or C++, but it's much safer.


01:14:10.280 --> 01:14:16.440
And it, as someone who used to write C++ long ago,


01:14:16.440 --> 01:14:20.700
like I've learned it over the past couple of years


01:14:20.700 --> 01:14:23.280
and it's like, it is the language


01:14:23.280 --> 01:14:25.480
I always wanted C++ to be.


01:14:25.480 --> 01:14:26.440
- Yeah, I hear you.


01:14:26.440 --> 01:14:28.720
I did a lot of C++ as well.


01:14:28.720 --> 01:14:29.960
It was always bringing in these things


01:14:29.960 --> 01:14:31.680
like smart pointers and other stuff.


01:14:31.680 --> 01:14:32.760
It's like, why does it have to be hard?


01:14:32.760 --> 01:14:34.280
Can't we just like make this better?


01:14:34.280 --> 01:14:35.940
- And it's not a simple language


01:14:35.940 --> 01:14:38.040
because if you want performance, you need to do work.


01:14:38.040 --> 01:14:39.960
And it has a very different paradigm,


01:14:39.960 --> 01:14:42.520
but it's really lovely language.


01:14:42.520 --> 01:14:44.680
You'll write much safer code.


01:14:44.680 --> 01:14:48.320
And Py03 makes it really nice to write Python extensions.


01:14:48.320 --> 01:14:49.860
- Yeah, cool, cool.


01:14:49.860 --> 01:14:52.440
And then Taldin's out there has a interesting comment.


01:14:52.440 --> 01:14:53.920
Is that like an isotope?


01:14:53.920 --> 01:15:01.680
- I think it's a reference to like oxidization.


01:15:01.680 --> 01:15:03.240
- Yeah, yeah, 'cause rust.


01:15:03.240 --> 01:15:06.880
- Yeah, there's a lot of oxidizing happening around--


01:15:06.880 --> 01:15:08.280
- There's also PyOxidizer.


01:15:08.280 --> 01:15:10.040
- Yeah, there's PyOxidizer.


01:15:10.040 --> 01:15:10.880
- Yeah.


01:15:10.880 --> 01:15:14.720
- That's like a completely different project,


01:15:14.720 --> 01:15:17.040
but yeah, it's another REST fun.


01:15:17.040 --> 01:15:18.280
- Packaging, yeah, exactly.


01:15:18.280 --> 01:15:19.920
Very, very cool.


01:15:19.920 --> 01:15:21.940
All right, final call to action.


01:15:21.940 --> 01:15:24.000
People are interested in this, they wanna go deeper.


01:15:24.000 --> 01:15:26.720
You've got some various things


01:15:26.720 --> 01:15:28.480
that you can find on your website,


01:15:28.480 --> 01:15:30.440
pythonspeed.com/docker.


01:15:30.440 --> 01:15:31.320
- Yeah. - Where do they go?


01:15:31.320 --> 01:15:32.380
What do you tell them?


01:15:32.380 --> 01:15:34.740
- Yeah, so if you go to pythonspeed.com/docker,


01:15:34.740 --> 01:15:38.020
there's a whole bunch of free articles


01:15:38.020 --> 01:15:39.860
about various best practices.


01:15:39.860 --> 01:15:42.740
If you're specifically interested in the process


01:15:42.740 --> 01:15:44.980
we covered today, there's a PyCon talk,


01:15:44.980 --> 01:15:48.980
but also if you go to pythonspeed.com/dockerprocess,


01:15:48.980 --> 01:15:51.260
it's also linked on that page.


01:15:51.260 --> 01:15:54.940
It's like a introduction to Dockerizing for production.


01:15:54.940 --> 01:15:57.620
It's basically like a little mini ebook I wrote


01:15:57.620 --> 01:16:02.620
That's about 10 pages, but it goes over this process


01:16:02.620 --> 01:16:04.580
that we talked about today and sort of prose


01:16:04.580 --> 01:16:07.380
and talks about sort of the decisions you have to make


01:16:07.380 --> 01:16:10.620
and how it integrates with your organizational processes.


01:16:10.620 --> 01:16:11.440
- That's super cool.


01:16:11.440 --> 01:16:14.980
Yeah, and on that site, the slash Docker part,


01:16:14.980 --> 01:16:16.920
like it has a bunch of articles


01:16:16.920 --> 01:16:18.260
and it has a very small scroll bar


01:16:18.260 --> 01:16:19.340
and a lot of stuff below it.


01:16:19.340 --> 01:16:21.420
So yeah, there's a lot of things going on.


01:16:21.420 --> 01:16:24.220
People can go check out for more resources there, right?


01:16:24.220 --> 01:16:26.720
- Yeah, and I have a bunch of paid products


01:16:26.720 --> 01:16:28.840
If anyone's interested about Docker packaging


01:16:28.840 --> 01:16:32.680
from the intro to much more detailed one,


01:16:32.680 --> 01:16:34.800
and if you use the code, talkpython,


01:16:34.800 --> 01:16:38.080
you can get a 15% discount.


01:16:38.080 --> 01:16:39.800
- Oh, fantastic, awesome.


01:16:39.800 --> 01:16:41.760
Yeah, so be sure to do that.


01:16:41.760 --> 01:16:43.000
Thank you so much for being on the show


01:16:43.000 --> 01:16:47.080
and sharing a lot of your hard-earned Docker experience.


01:16:47.080 --> 01:16:48.480
- Yeah, thanks for inviting me.


01:16:48.480 --> 01:16:49.680
- You bet.


01:16:49.680 --> 01:16:51.160
Yeah, see ya.


01:16:51.160 --> 01:16:52.320
Yeah, you too, bye.


01:16:52.320 --> 01:16:55.200
Bye everyone out there in the live stream.


01:16:55.200 --> 01:16:56.280
Thanks for being here.


01:16:56.280 --> 01:17:06.280
[BLANK_AUDIO]

