WEBVTT

00:00:00.000 --> 00:00:04.000
- Hello YouTube, hello Barry, Erman, Carl.


00:00:04.000 --> 00:00:04.960
Welcome to the show.


00:00:04.960 --> 00:00:07.400
- Hey, hello.


00:00:07.400 --> 00:00:10.520
- It's wonderful to have you all here.


00:00:10.520 --> 00:00:14.800
I'm very excited about the work that you're all doing


00:00:14.800 --> 00:00:17.160
around Python performance.


00:00:17.160 --> 00:00:19.520
We're gonna focus on imports and this pep


00:00:19.520 --> 00:00:21.760
that you three proposed today,


00:00:21.760 --> 00:00:24.520
but it's really just the tip of the iceberg


00:00:24.520 --> 00:00:26.840
in terms of a bunch of cool stuff that's going on.


00:00:26.840 --> 00:00:28.720
So I'm very excited to dive into that


00:00:28.720 --> 00:00:29.840
with the three of you.


00:00:29.840 --> 00:00:31.300
Now, before we get to it though,


00:00:31.300 --> 00:00:33.700
let's just do a quick round of introductions.


00:00:33.700 --> 00:00:35.300
Barry, you've been on the show before


00:00:35.300 --> 00:00:40.300
talking about 1994 Python stuff and other things.


00:00:40.300 --> 00:00:44.380
So maybe just a quick introduction for yourself.


00:00:44.380 --> 00:00:46.860
- Yeah, Barry Warsaw.


00:00:46.860 --> 00:00:50.900
So I'm still here, still hanging around, I guess.


00:00:50.900 --> 00:00:56.700
You know, I should mention, you know,


00:00:56.700 --> 00:00:59.120
as we get into this pep though,


00:00:59.120 --> 00:01:00.720
I'm really just the sponsor.


00:01:00.720 --> 00:01:04.920
I gotta hand a lot of thanks to Hermon and Carl


00:01:04.920 --> 00:01:06.360
for doing all the work on it.


00:01:06.360 --> 00:01:13.120
Most peps these days require a core developer to sponsor.


00:01:13.120 --> 00:01:17.280
So I'm just super interested in the topic.


00:01:17.280 --> 00:01:19.560
I think it's a super clever approach.


00:01:19.560 --> 00:01:24.320
And so I think it'll help specific needs


00:01:24.320 --> 00:01:25.160
that I have at work.


00:01:25.160 --> 00:01:27.760
And so I was really eager to...


00:01:27.760 --> 00:01:31.640
eager to sponsor it.


00:01:31.640 --> 00:01:34.640
- Yeah, fantastic.


00:01:34.640 --> 00:01:36.440
All right, very cool.


00:01:36.440 --> 00:01:37.600
Hermann, how about you?


00:01:37.600 --> 00:01:45.040
- Well, I'm just working at Meta with Carl


00:01:45.040 --> 00:01:50.040
and I wrote the initial approach for Lazy Imports


00:01:50.040 --> 00:01:52.020
and well, here I am.


00:01:52.020 --> 00:01:54.320
- Right on.


00:01:56.080 --> 00:01:58.340
- Carl, quick introduction.


00:01:58.340 --> 00:02:04.440
- I've been around the Python community for a while.


00:02:04.440 --> 00:02:08.080
I think the first maybe semi-notable thing that I did


00:02:08.080 --> 00:02:12.760
was write the first version of pip uninstall back in 2009.


00:02:12.760 --> 00:02:16.040
That led to being a maintainer of pip and virtualen


00:02:16.040 --> 00:02:19.840
for a while, and I worked on the Django core team


00:02:19.840 --> 00:02:21.080
for a while.


00:02:21.080 --> 00:02:24.320
And so yeah, I've been doing Python things for a long time


00:02:24.320 --> 00:02:25.840
and I've been working at Meta since--


00:02:25.840 --> 00:02:27.840
- Those are a lot of big projects there.


00:02:27.840 --> 00:02:30.600
- Yeah, they're projects that I was using


00:02:30.600 --> 00:02:32.560
and so I was interested in working on them


00:02:32.560 --> 00:02:34.500
and same goes for Python itself.


00:02:34.500 --> 00:02:36.760
- Yeah, absolutely.


00:02:36.760 --> 00:02:37.880
Sorry, I kind of cut you off there.


00:02:37.880 --> 00:02:40.640
You said working at Meta since 2016, is that what you said?


00:02:40.640 --> 00:02:43.520
- Yeah, I've been working at Meta since 2016.


00:02:43.520 --> 00:02:47.360
Working mostly on how Meta uses Python,


00:02:47.360 --> 00:02:48.680
how Instagram uses Python.


00:02:48.680 --> 00:02:50.800
- Yeah.


00:02:50.800 --> 00:02:53.400
There've been some really cool looks inside what's going on,


00:02:53.400 --> 00:02:57.440
especially at Instagram there with some of the typing talks


00:02:57.440 --> 00:03:02.440
that Lucas gave, as well as sort of suspending


00:03:02.440 --> 00:03:05.160
the garbage collector for other various things.


00:03:05.160 --> 00:03:07.880
And a lot-- or was that you guys?


00:03:07.880 --> 00:03:10.480
I think it was, right?


00:03:10.480 --> 00:03:11.480
Yeah, we had a whole--


00:03:11.480 --> 00:03:13.240
A lot of stuff coming out of there.


00:03:13.240 --> 00:03:13.920
A whole saga.


00:03:13.920 --> 00:03:15.380
We turned off the garbage collector,


00:03:15.380 --> 00:03:16.960
turned back on the garbage collector.


00:03:16.960 --> 00:03:19.840
There's been multiple blog posts along the way


00:03:19.840 --> 00:03:24.240
explaining why we've done each of those silly sounding things.


00:03:24.240 --> 00:03:25.920
>> Sure, I mean, they seem insane.


00:03:25.920 --> 00:03:28.360
Well, a lot of the projects that,


00:03:28.360 --> 00:03:29.880
a lot of the stuff that's coming out here,


00:03:29.880 --> 00:03:32.080
it has to do with the Cinder project, right?


00:03:32.080 --> 00:03:35.200
>> Yeah.


00:03:35.200 --> 00:03:37.160
>> And you may be, I don't know who's best


00:03:37.160 --> 00:03:38.560
to give the introduction for Cinder,


00:03:38.560 --> 00:03:43.560
but Cinder's a really cool project about, you know,


00:03:43.560 --> 00:03:46.280
taking a whole bunch of optimizations


00:03:46.280 --> 00:03:48.160
and specializations you all have done


00:03:48.160 --> 00:03:50.920
and sort of sharing that back with the community


00:03:50.920 --> 00:03:51.920
a little bit, right?


00:03:51.920 --> 00:03:57.960
- Yeah, so we started Cinder in I think 2017 or 2018.


00:03:57.960 --> 00:03:59.680
There was actually two projects


00:03:59.680 --> 00:04:01.080
kind of started simultaneously.


00:04:01.080 --> 00:04:04.280
We realized around that time that the trajectory


00:04:04.280 --> 00:04:09.040
for Instagram's kind of server footprint


00:04:09.040 --> 00:04:11.600
was not really sustainable just in terms of how much


00:04:11.600 --> 00:04:14.640
server CPU time we were spending running Python code.


00:04:14.640 --> 00:04:16.440
And so we kicked off two projects.


00:04:16.440 --> 00:04:19.380
One was called, it's now called Sky Bison.


00:04:19.380 --> 00:04:23.220
It was like a ground up rewritten Python interpreter,


00:04:23.220 --> 00:04:27.140
you know, using all the modern dynamic language VM ideas,


00:04:27.140 --> 00:04:28.580
like a moving garbage collector


00:04:28.580 --> 00:04:30.180
and all these different things.


00:04:30.180 --> 00:04:32.740
We weren't the first people to try that.


00:04:32.740 --> 00:04:36.940
And we also weren't the first people to fail.


00:04:36.940 --> 00:04:39.720
That project was wound down last year,


00:04:39.720 --> 00:04:41.380
just weren't able to get the performance,


00:04:41.380 --> 00:04:43.740
particularly trying to emulate compatibility


00:04:43.740 --> 00:04:46.020
with the C API and all the C extensions,


00:04:46.020 --> 00:04:50.180
which is the same reason many prior rewrite efforts


00:04:50.180 --> 00:04:51.220
didn't go very far.


00:04:51.220 --> 00:04:53.860
So at the same time as we'd kicked off SkyBison,


00:04:53.860 --> 00:04:55.740
we had sort of kicked off what we thought


00:04:55.740 --> 00:04:58.320
was a short-term project of just like,


00:04:58.320 --> 00:05:00.060
what can we squeeze out of CPython?


00:05:00.060 --> 00:05:02.220
Where can we get a little more performance out of it?


00:05:02.220 --> 00:05:04.000
And that turned into Cinder,


00:05:04.000 --> 00:05:06.300
and then ended up kind of becoming our primary approach


00:05:06.300 --> 00:05:07.640
to Python performance.


00:05:07.640 --> 00:05:13.660
- Isn't it always the story that the C interop stuff


00:05:13.660 --> 00:05:16.900
is the big sticking point here.


00:05:16.900 --> 00:05:17.740
- Yeah.


00:05:17.740 --> 00:05:19.100
- I mean, Barry, you must have seen a whole bunch


00:05:19.100 --> 00:05:21.980
of examples from a core dev perspective.


00:05:21.980 --> 00:05:23.140
All right.


00:05:23.140 --> 00:05:23.980
- Yeah.


00:05:23.980 --> 00:05:24.800
- We could just change the guild,


00:05:24.800 --> 00:05:28.580
but the C API, we could just, but you know.


00:05:28.580 --> 00:05:29.620
- Yeah, yeah.


00:05:29.620 --> 00:05:33.820
I mean, it's both, you know, Python's, you know,


00:05:33.820 --> 00:05:35.780
advantage, you know, pros and cons, right?


00:05:35.780 --> 00:05:39.500
Like the approachability and the usability


00:05:39.500 --> 00:05:44.260
the C API has led directly to the incredible ecosystem


00:05:44.260 --> 00:05:47.120
of extension modules, right?


00:05:47.120 --> 00:05:50.980
But those also are also the hindrance for moving,


00:05:50.980 --> 00:05:52.860
you know, ahead in a revolutionary way


00:05:52.860 --> 00:05:55.900
with the interpreter, I think, you know.


00:05:55.900 --> 00:05:57.900
- Right, you kind of got to live within the box,


00:05:57.900 --> 00:06:01.020
with the walls that are put up by those constraints.


00:06:01.020 --> 00:06:02.340
But I do think it's super important.


00:06:02.340 --> 00:06:03.940
You know, a lot of people would maybe just think,


00:06:03.940 --> 00:06:04.820
well, we'll just get rid of it.


00:06:04.820 --> 00:06:06.380
Like, let's just try to move beyond it.


00:06:06.380 --> 00:06:09.800
but when you hear people say that Python is slow


00:06:09.800 --> 00:06:11.380
or it has these other problems,


00:06:11.380 --> 00:06:13.200
so often what you'll see as well,


00:06:13.200 --> 00:06:15.820
and what I did was I did a for loop in Python


00:06:15.820 --> 00:06:18.160
and did some math and that was slow.


00:06:18.160 --> 00:06:19.860
It's like, well, but if a thing is slow,


00:06:19.860 --> 00:06:22.180
so often that gets rewritten in C


00:06:22.180 --> 00:06:23.940
and then all of a sudden it's faster than,


00:06:23.940 --> 00:06:26.180
I don't know what Java or whatever else it is


00:06:26.180 --> 00:06:28.020
they're trying, you know, Node,


00:06:28.020 --> 00:06:29.120
but they're trying to compare it to.


00:06:29.120 --> 00:06:32.320
And so there's this kind of crazy switch


00:06:32.320 --> 00:06:35.800
that gets flipped for like really high performance.


00:06:35.800 --> 00:06:39.920
and then maybe acceptable most of the time performance.


00:06:39.920 --> 00:06:43.920
And it's this interop with C that is the thing,


00:06:43.920 --> 00:06:45.080
that's the escape hatch.


00:06:45.080 --> 00:06:51.200
- Yeah, and LinkedIn, we don't have the same kind


00:06:51.200 --> 00:06:55.080
of workloads that they have at Meta,


00:06:55.080 --> 00:06:58.480
but we've done analysis.


00:06:58.480 --> 00:07:00.480
One of the reasons why I was particularly interested


00:07:00.480 --> 00:07:02.800
in this project is because we write a lot


00:07:02.800 --> 00:07:04.840
of our CLIs in Python.


00:07:04.840 --> 00:07:09.840
And so, we've had proponents of other languages say,


00:07:09.840 --> 00:07:11.920
complain, "Hey, Python's really slow.


00:07:11.920 --> 00:07:13.600
"I write a CLI in Python."


00:07:13.600 --> 00:07:16.080
And then it takes a long time to start up.


00:07:16.080 --> 00:07:18.520
But if you actually do the analysis,


00:07:18.520 --> 00:07:22.520
what you find is that people are not writing,


00:07:22.520 --> 00:07:25.880
a lot of the internal libraries that those CLIs import


00:07:25.880 --> 00:07:27.620
do things like they go hit the network


00:07:27.620 --> 00:07:29.280
and they go try to do the service


00:07:29.280 --> 00:07:31.560
and create really expensive resources


00:07:31.560 --> 00:07:33.080
at module scope time, right?


00:07:33.080 --> 00:07:35.440
So like those are the types of analysis


00:07:35.440 --> 00:07:36.800
that you really need to do to say,


00:07:36.800 --> 00:07:39.600
is it really Python or is it the way we use Python?


00:07:39.600 --> 00:07:42.340
You know, for us, it's a little of both for sure,


00:07:42.340 --> 00:07:46.200
but often it's sort of the way Python is being used


00:07:46.200 --> 00:07:50.080
in a non-idiomatic or not in the highest performance way.


00:07:50.080 --> 00:07:50.920
Right?


00:07:50.920 --> 00:07:52.960
So a little bit of rewrite of some internal code


00:07:52.960 --> 00:07:54.080
can get you a long way.


00:07:54.080 --> 00:07:56.400
- It sure can.


00:07:56.400 --> 00:07:58.840
I also want to just give a quick shout out


00:07:58.840 --> 00:08:02.240
back on episode 347, I talked with Dino Vila


00:08:02.240 --> 00:08:03.900
like all about the Cinder project.


00:08:03.900 --> 00:08:04.840
So if you want to check that out,


00:08:04.840 --> 00:08:07.280
they can definitely go find that.


00:08:07.280 --> 00:08:11.280
But there's a lot of cool things that were taken out of Cinder


00:08:11.280 --> 00:08:12.440
and are being proposed.


00:08:12.440 --> 00:08:17.200
And I guess that sort of brings us to our main topic for today


00:08:17.200 --> 00:08:21.200
is imports and the PEP 690 that you all have proposed,


00:08:21.200 --> 00:08:23.280
which I am also excited for.


00:08:23.280 --> 00:08:26.640
I think imports are one of those things that


00:08:26.640 --> 00:08:29.560
are a little bit mysterious to people


00:08:29.560 --> 00:08:33.240
because they have conceptions coming from other languages,


00:08:33.240 --> 00:08:35.560
especially compiled languages that are very different


00:08:35.560 --> 00:08:37.020
than what the reality is.


00:08:37.020 --> 00:08:41.240
So I do want to talk a whole bunch


00:08:41.240 --> 00:08:42.560
about what you're offering here,


00:08:42.560 --> 00:08:46.720
what you're proposing here in this lazy imports pep.


00:08:46.720 --> 00:08:49.120
But before we do, let's maybe just set the stage


00:08:49.120 --> 00:08:54.080
with what happens when I write import requests


00:08:54.080 --> 00:08:56.040
or I write import fast API,


00:08:56.040 --> 00:08:59.800
or even something built in like import collections?


00:08:59.800 --> 00:09:02.720
Who wants to take this one?


00:09:02.720 --> 00:09:03.880
Tell people what really happens


00:09:03.880 --> 00:09:06.440
when the import statement runs, is there.


00:09:06.440 --> 00:09:11.240
- I don't know.


00:09:11.240 --> 00:09:14.420
I guess I'll say,


00:09:14.420 --> 00:09:19.160
there was a time where the import system


00:09:19.160 --> 00:09:21.200
for Python was written in C


00:09:21.200 --> 00:09:23.560
and it was even more mysterious, I think at that point.


00:09:23.560 --> 00:09:26.560
And I don't remember when it was,


00:09:26.560 --> 00:09:31.140
but Brett Cannon rewrote the import system into Python.


00:09:31.140 --> 00:09:32.900
And then about that time,


00:09:32.900 --> 00:09:36.260
I sort of went through sort of line by line


00:09:36.260 --> 00:09:38.760
and tried to understand, I mean, because right,


00:09:38.760 --> 00:09:42.620
like imports are probably one of the oldest features


00:09:42.620 --> 00:09:43.460
of Python, right?


00:09:43.460 --> 00:09:44.340
They've been around so long


00:09:44.340 --> 00:09:47.220
and there's so many corner cases, right?


00:09:47.220 --> 00:09:51.700
It's a very complex system and has lots of features,


00:09:51.700 --> 00:09:56.980
lots of hooks, lots of places where you can hook in your own behavior and really


00:09:56.980 --> 00:09:59.260
understanding how all of that fits together.


00:09:59.260 --> 00:10:04.140
I think I probably took a couple of months to sort of walk through the entire


00:10:04.140 --> 00:10:05.580
system line by line and document it.


00:10:05.580 --> 00:10:11.500
Fortunately now, if you go to the language reference guide, I think it goes into all


00:10:11.500 --> 00:10:14.180
the gory detail about how imports work.


00:10:14.180 --> 00:10:19.660
Everything from namespace packages to, you know, concrete packages and all the file


00:10:19.660 --> 00:10:23.900
system hooks and meta path hooks and blah, blah, blah, blah.


00:10:23.900 --> 00:10:24.400
Right?


00:10:24.400 --> 00:10:26.900
So yeah.


00:10:26.900 --> 00:10:29.940
Yeah, definitely a lot going on.


00:10:29.940 --> 00:10:32.660
I think the key thing, though, that you are hinting at there


00:10:32.660 --> 00:10:37.020
is this is a runtime type of behavior.


00:10:37.020 --> 00:10:39.380
This is a runtime experience.


00:10:39.380 --> 00:10:40.700
Carl, you're shaking your head.


00:10:40.700 --> 00:10:42.500
What would you want to add to this?


00:10:42.500 --> 00:10:44.580
What Barry was saying here.


00:10:44.580 --> 00:10:48.020
Well, yeah, I mean, I think what a lot of people don't--


00:10:48.020 --> 00:10:51.380
I mean, maybe don't consciously realize initially


00:10:51.380 --> 00:10:55.580
about imports is that it's just executing some more code.


00:10:55.580 --> 00:10:58.740
So it's like, you can almost think of imports in Python


00:10:58.740 --> 00:11:00.780
as like syntax sugar for a function call


00:11:00.780 --> 00:11:04.180
where the body of the function is the module level code


00:11:04.180 --> 00:11:07.540
of some module and the return value is the module object


00:11:07.540 --> 00:11:10.080
that you end up getting back from the import.


00:11:10.080 --> 00:11:10.940
But like it really is,


00:11:10.940 --> 00:11:14.580
it's just causing some more code to be executed


00:11:14.580 --> 00:11:17.820
where the result is a module object that has stuff on it


00:11:17.820 --> 00:11:19.100
that you can use.


00:11:19.100 --> 00:11:21.500
And one of the consequences of that


00:11:21.500 --> 00:11:25.860
is that literally anything can happen when you import a module.


00:11:25.860 --> 00:11:29.700
I mean, like Barry was saying, it could go off and talk


00:11:29.700 --> 00:11:30.340
to the internet.


00:11:30.340 --> 00:11:33.900
I think people have even written stuff that automatically


00:11:33.900 --> 00:11:35.500
goes and finds modules on the internet


00:11:35.500 --> 00:11:38.660
and downloads them just in time to import them.


00:11:38.660 --> 00:11:40.580
But yeah, that's the key point is that--


00:11:40.580 --> 00:11:41.500
BRIAN KARDELL: You don't have it installed?


00:11:41.500 --> 00:11:42.540
Let us fix that for you.


00:11:42.540 --> 00:11:43.040
[LAUGHTER]


00:11:43.040 --> 00:11:44.460
[INTERPOSING VOICES]


00:11:44.460 --> 00:11:46.980
So yeah, it could be arbitrarily slow.


00:11:46.980 --> 00:11:47.740
It could fail.


00:11:47.740 --> 00:11:51.180
It could do anything.


00:11:51.180 --> 00:11:51.900
Yeah.


00:11:51.900 --> 00:11:52.540
Yeah.


00:11:52.540 --> 00:11:55.860
If people have a conception of an import statement being


00:11:55.860 --> 00:12:01.460
like a using statement in C# or an include statement in C++,


00:12:01.460 --> 00:12:02.620
that's not--


00:12:02.620 --> 00:12:06.900
that's kind of effectively the same intent,


00:12:06.900 --> 00:12:10.980
but the behavior is massively different, right?


00:12:10.980 --> 00:12:13.180
In C++, it says, here's some symbols


00:12:13.180 --> 00:12:16.620
that should also be used for compilation.


00:12:16.620 --> 00:12:18.580
In Python, it's literally saying,


00:12:18.580 --> 00:12:20.540
let's just execute this file top to bottom.


00:12:20.540 --> 00:12:22.620
And usually execution means define a function,


00:12:22.620 --> 00:12:25.580
define a function, define a local variable, define a class,


00:12:25.580 --> 00:12:29.820
but it could mean run some random thing,


00:12:29.820 --> 00:12:32.860
search the file system, all sorts of stuff.


00:12:32.860 --> 00:12:35.000
And it leads to things like this,


00:12:35.000 --> 00:12:41.900
the if dunder name equal dunder main, right?


00:12:41.900 --> 00:12:42.740
- Yeah, yeah.


00:12:42.740 --> 00:12:48.800
- This is a big confusion that people run into.


00:12:48.800 --> 00:12:51.620
Why is this weird thing in Python?


00:12:51.620 --> 00:12:54.380
Why do they recommend it, right?


00:12:54.380 --> 00:12:57.140
And it's just because when you do an import statement,


00:12:57.140 --> 00:12:58.140
it just runs top to bottom.


00:12:58.140 --> 00:12:59.420
And if you put behavior in there,


00:12:59.420 --> 00:13:01.780
well, that behavior happens, right?


00:13:01.780 --> 00:13:03.780
So here's your way to sort of skip that.


00:13:03.780 --> 00:13:08.660
Just as a sidebar, you all have been involved


00:13:08.660 --> 00:13:09.920
for a long time.


00:13:09.920 --> 00:13:14.920
Should Python have had a deaf main sort of entry point thing


00:13:14.920 --> 00:13:16.580
like so many languages have?


00:13:16.580 --> 00:13:19.600
I'm not saying it should or shouldn't,


00:13:19.600 --> 00:13:21.600
I just wanna hear your thoughts on this.


00:13:21.600 --> 00:13:27.360
- I don't know, I think this is just one of those


00:13:27.360 --> 00:13:29.480
quirky things about the,


00:13:29.480 --> 00:13:31.360
not even really even about the language,


00:13:31.360 --> 00:13:33.840
it's just a quirky thing about the Python,


00:13:33.840 --> 00:13:35.360
the way you use Python.


00:13:35.360 --> 00:13:37.320
And to me, it's like one of those things,


00:13:37.320 --> 00:13:41.060
you learn it and then you just use it.


00:13:41.060 --> 00:13:45.720
But actually, I think I tend to use this much, much less now,


00:13:45.720 --> 00:13:48.660
now that we have things like packages and entry points


00:13:48.660 --> 00:13:50.360
and things like that.


00:13:50.360 --> 00:13:53.620
To me, I almost am defining a main function


00:13:53.620 --> 00:13:56.060
and then in my package metadata, I say,


00:13:56.060 --> 00:13:57.500
well, there's my entry point


00:13:57.500 --> 00:14:00.760
and the packaging system just does it magically.


00:14:00.760 --> 00:14:03.500
So this is kind of a convenience


00:14:03.500 --> 00:14:06.100
and I don't think you really actually run into it


00:14:06.100 --> 00:14:11.100
as often nowadays as you probably did years ago.


00:14:11.100 --> 00:14:13.820
- Sure, all my apps that are supposed


00:14:13.820 --> 00:14:15.100
to be run directly like that,


00:14:15.100 --> 00:14:16.820
they all have a def main somewhere.


00:14:16.820 --> 00:14:18.380
And then this just calls the main


00:14:18.380 --> 00:14:20.820
with this symbol here, right?


00:14:20.820 --> 00:14:23.020
Erman, what do you think?


00:14:23.020 --> 00:14:25.980
- Yeah, I totally agree.


00:14:25.980 --> 00:14:27.740
It's probably not something


00:14:27.740 --> 00:14:30.360
we should be using as much right now.


00:14:30.360 --> 00:14:32.500
Yeah.


00:14:32.500 --> 00:14:34.620
- Sure.


00:14:34.620 --> 00:14:36.540
Of course, the really interesting thing here, right,


00:14:36.540 --> 00:14:39.380
is that it's Dunder named, right?


00:14:39.380 --> 00:14:43.380
Like that's a deeper concept about Python


00:14:43.380 --> 00:14:45.500
that you should really understand is that


00:14:45.500 --> 00:14:48.880
modules are objects and they have this attribute


00:14:48.880 --> 00:14:50.300
called Dunder name.


00:14:50.300 --> 00:14:54.100
And that Dunder name, that attribute is set to some string.


00:14:54.100 --> 00:15:00.260
And when you call a, when you not import a file,


00:15:00.260 --> 00:15:04.000
but call a file using the Python executable,


00:15:04.000 --> 00:15:08.800
that file gets this string, dunder main,


00:15:08.800 --> 00:15:10.620
assigned to that attribute, right?


00:15:10.620 --> 00:15:14.700
So kind of like understanding a little deeper


00:15:14.700 --> 00:15:17.620
about how Python works is really important, I think,


00:15:17.620 --> 00:15:20.620
to be able to use it effectively.


00:15:20.620 --> 00:15:23.180
- It is, and you hinted on being more idiomatic


00:15:23.180 --> 00:15:26.300
to get better performance, and I totally agree with you.


00:15:26.300 --> 00:15:30.100
All right, so now knowing kind of what it means


00:15:30.100 --> 00:15:33.060
to do an import, let's talk about your pep.


00:15:33.060 --> 00:15:37.180
Who wants to introduce the PEP here?


00:15:37.180 --> 00:15:40.820
Armand, you're number one author here, so how about you go first?


00:15:40.820 --> 00:15:41.820
Yeah, sure.


00:15:41.820 --> 00:15:48.020
Well, we all started long before the PEP.


00:15:48.020 --> 00:15:56.820
In 2020, when I joined Meta, it was just one month before the pandemic hit.


00:15:56.820 --> 00:16:00.460
So I started working in Instagram code base at the time.


00:16:00.460 --> 00:16:07.100
And well, there have been a lot of problems, constant problems there with the reload speeds


00:16:07.100 --> 00:16:13.100
in the development server, and Instagram, and also in another ton of other command line


00:16:13.100 --> 00:16:14.940
tools as well.


00:16:14.940 --> 00:16:22.580
So while I worked in Instagram codebase for a couple years trying to fight and dodge the


00:16:22.580 --> 00:16:28.220
startup performance problems that we were encountering all the time.


00:16:28.220 --> 00:16:33.220
And when you get into codebases, the size of Instagram is,


00:16:33.220 --> 00:16:37.620
there are a whole bunch of problems that become apparent.


00:16:37.620 --> 00:16:39.620
One of those is-- - Yeah, most people


00:16:39.620 --> 00:16:42.500
don't work at the scale in terms of lines of code


00:16:42.500 --> 00:16:44.860
or number of servers or anything like that.


00:16:44.860 --> 00:16:47.740
You're definitely pushing the outer envelope there.


00:16:47.740 --> 00:16:50.460
- Yeah, there are thousands and thousands of modules


00:16:50.460 --> 00:16:52.020
working here.


00:16:52.020 --> 00:16:56.060
So one of the problems that start to become apparent


00:16:56.060 --> 00:16:58.140
is startup speed.


00:16:58.140 --> 00:17:04.340
And the other problem is that refactoring modules


00:17:04.340 --> 00:17:07.360
becomes really, really hard.


00:17:07.360 --> 00:17:12.140
So if you try to modify something to get it working better,


00:17:12.140 --> 00:17:15.300
it suddenly starts getting,


00:17:15.300 --> 00:17:17.860
you suddenly start getting import cycles


00:17:17.860 --> 00:17:20.780
and other things when you just move around imports


00:17:20.780 --> 00:17:23.780
or try to split modules.


00:17:23.780 --> 00:17:26.120
So it gets really tricky and hard.


00:17:26.120 --> 00:17:27.620
It's complicated.


00:17:27.620 --> 00:17:28.460
So,


00:17:28.460 --> 00:17:32.580
but the start speed,


00:17:32.580 --> 00:17:38.740
when you run a module that imports other modules,


00:17:38.740 --> 00:17:40.720
and these modules are run,


00:17:40.720 --> 00:17:46.380
then those in turn import other modules,


00:17:46.380 --> 00:17:48.060
and this goes on and on.


00:17:48.060 --> 00:17:50.580
So all transitive dependencies are involved.


00:17:50.580 --> 00:17:53.220
- Right, right.


00:17:53.220 --> 00:17:57.840
If you just import one thing, it seems minor, but then that could import two things and


00:17:57.840 --> 00:17:59.720
those two things could import four things.


00:17:59.720 --> 00:18:04.520
And then it just, if you're talking thousands of modules, it can explode.


00:18:04.520 --> 00:18:08.860
And pep eight says import goes at the top first thing, right?


00:18:08.860 --> 00:18:13.480
It's like just to get started before you can even figure out what your code is going to


00:18:13.480 --> 00:18:17.840
do, you would do all the imports, which is the transit of closure of every import basically.


00:18:17.840 --> 00:18:18.840
Right?


00:18:18.840 --> 00:18:19.840
Exactly.


00:18:19.840 --> 00:18:24.600
So just send a subloading every single module.


00:18:24.600 --> 00:18:26.840
Nobody is going to be used immediately,


00:18:26.840 --> 00:18:29.800
or it's never going to be used at all.


00:18:29.800 --> 00:18:35.160
So this was a never-ending battle with this Instagram


00:18:35.160 --> 00:18:35.920
server.


00:18:35.920 --> 00:18:40.760
And as soon as I realized that I was doing repetitive work that


00:18:40.760 --> 00:18:50.600
was very complex and produced very fragile changes.


00:18:50.600 --> 00:18:52.120
And that was really hard to maintain.


00:18:52.120 --> 00:18:57.280
And at the end, it didn't really yield the improvements


00:18:57.280 --> 00:18:58.040
that we needed.


00:18:58.040 --> 00:19:03.800
So I thought I set sail to write Lazy Imports.


00:19:03.800 --> 00:19:09.240
And that's when we started implementing that.


00:19:09.240 --> 00:19:14.080
Well, the pip is, you know,


00:19:14.080 --> 00:19:18.320
when we try to show to the world what we did


00:19:18.320 --> 00:19:20.920
and the results that we were having,


00:19:20.920 --> 00:19:25.840
when we get to the US PyCon 2020 in Salt Lake City,


00:19:25.840 --> 00:19:31.080
I was planning to discuss this at the Language Summit,


00:19:31.080 --> 00:19:34.120
but at the end, Carl ended up giving


00:19:34.120 --> 00:19:36.160
the really good overview there,


00:19:37.480 --> 00:19:39.240
explaining what it was.


00:19:39.240 --> 00:19:43.080
I don't know, Kyle, can you add?


00:19:43.080 --> 00:19:48.140
- Yeah, we were,


00:19:48.140 --> 00:19:54.000
I think Hermann proposed a talk for the language summit


00:19:54.000 --> 00:19:56.960
at this last PyCon 2022 in Salt Lake City


00:19:56.960 --> 00:19:58.240
for the language summit,


00:19:58.240 --> 00:19:59.840
and there just wasn't space in the schedule.


00:19:59.840 --> 00:20:02.040
So the language summit organizers


00:20:02.040 --> 00:20:03.360
had to pick some things to leave out.


00:20:03.360 --> 00:20:07.840
And so they didn't squeeze in Lazy Imports.


00:20:07.840 --> 00:20:11.480
But then at the language summit, a couple of different people


00:20:11.480 --> 00:20:12.840
brought up Lazy Imports, that they


00:20:12.840 --> 00:20:14.600
had heard that we had done this and wanted


00:20:14.600 --> 00:20:15.520
to know more about it.


00:20:15.520 --> 00:20:17.360
And there was a lightning talks slot


00:20:17.360 --> 00:20:18.920
at the end of the language summit.


00:20:18.920 --> 00:20:20.580
So in the middle of the afternoon,


00:20:20.580 --> 00:20:22.160
sitting there at the language summit,


00:20:22.160 --> 00:20:24.960
I just put together about 10 slides on what Lazy Imports is


00:20:24.960 --> 00:20:26.120
and how it works.


00:20:26.120 --> 00:20:28.760
And I gave a quick lightning talk.


00:20:28.760 --> 00:20:32.880
And on the way back to my seat from giving the lightning talk,


00:20:32.880 --> 00:20:36.240
Guido leaned over and said, "Just write the PEP already."


00:20:36.240 --> 00:20:40.960
So I was a little bit of a positive encouragement


00:20:40.960 --> 00:20:42.000
and a nudge.


00:20:42.000 --> 00:20:44.040
- Yeah, that's encouragement.


00:20:44.040 --> 00:20:45.360
- So then Hermann was at the sprints


00:20:45.360 --> 00:20:47.360
and so the two of us sat down together at the sprints


00:20:47.360 --> 00:20:49.560
on the first day and said, "All right, let's write a PEP."


00:20:49.560 --> 00:20:51.560
So we put together PEP 690.


00:20:51.560 --> 00:20:54.360
- And he said, "Hey, oh, Barry's walking by, grab him."


00:20:54.360 --> 00:20:59.800
- Well, I mean, this is something that's been on my radar


00:20:59.800 --> 00:21:01.520
at LinkedIn for quite a while, like I said,


00:21:01.520 --> 00:21:04.320
because we have tons of CLIs written in Python.


00:21:04.320 --> 00:21:06.980
And I think the thing that, you know,


00:21:06.980 --> 00:21:09.220
like this is not the first attempt at lazy imports.


00:21:09.220 --> 00:21:12.880
Like, you know, there's been lots of different approaches,


00:21:12.880 --> 00:21:14.640
but I think what really kind of struck,


00:21:14.640 --> 00:21:15.580
certainly what struck me,


00:21:15.580 --> 00:21:17.240
and I suspect what struck Guido


00:21:17.240 --> 00:21:20.680
was the really clever implementation


00:21:20.680 --> 00:21:23.160
of this particular approach to it.


00:21:23.160 --> 00:21:24.480
I don't know who came up with that,


00:21:24.480 --> 00:21:28.060
but whoever did it was like really a stroke of genius.


00:21:30.000 --> 00:21:33.080
because it really gives you the transparency


00:21:33.080 --> 00:21:35.840
that I think you need to make this a success.


00:21:35.840 --> 00:21:39.580
So maybe Carl or Hermann can talk about that a little bit.


00:21:39.580 --> 00:21:42.320
- Yeah, well, let's first define just like


00:21:42.320 --> 00:21:44.440
what is the pep proposing?


00:21:44.440 --> 00:21:47.760
So we've described traditionally what it means


00:21:47.760 --> 00:21:51.120
when you say import thing, it executes all the Python


00:21:51.120 --> 00:21:52.680
and if there's some inline behaviors


00:21:52.680 --> 00:21:54.000
that runs those behaviors


00:21:54.000 --> 00:21:56.520
and that all happens at the top.


00:21:56.520 --> 00:21:57.360
How is this different?


00:21:57.360 --> 00:22:00.840
What change is this proposing to the CPython runtime?


00:22:00.840 --> 00:22:04.640
- Hermann?


00:22:04.640 --> 00:22:16.200
- Probably can go for this, Karl.


00:22:16.200 --> 00:22:17.300
- Okay, I can take it.


00:22:17.300 --> 00:22:20.400
Yeah, I mean, the basic idea is just


00:22:20.400 --> 00:22:24.440
that when you hit an import statement,


00:22:24.440 --> 00:22:28.080
is say, import foo, instead of immediately at that point


00:22:28.080 --> 00:22:31.000
going off and finding the foo module, the source code,


00:22:31.000 --> 00:22:33.640
and executing the entire module top to bottom


00:22:33.640 --> 00:22:35.480
and doing all that work, and then, of course,


00:22:35.480 --> 00:22:37.480
all the transitive imports from that,


00:22:37.480 --> 00:22:40.560
and et cetera, et cetera, that all we do when we hit import


00:22:40.560 --> 00:22:44.360
foo is we basically remember, all right, we


00:22:44.360 --> 00:22:45.800
have this name foo.


00:22:45.800 --> 00:22:48.440
It refers to a module somewhere.


00:22:48.440 --> 00:22:51.000
We're going to put off the work of figuring out


00:22:51.000 --> 00:22:53.240
what that module is and actually executing it.


00:22:53.240 --> 00:22:56.720
And we're just going to remember that whenever foo is used,


00:22:56.720 --> 00:22:58.520
that means we need to go find out what it is


00:22:58.520 --> 00:22:59.600
and actually execute it.


00:22:59.600 --> 00:23:02.040
So then that name foo will just kind of sit there


00:23:02.040 --> 00:23:05.440
in the global namespace of whichever module imported it.


00:23:05.440 --> 00:23:09.840
And oftentimes, foo won't even be used or referenced anywhere


00:23:09.840 --> 00:23:12.840
in the module body of the module that imported it.


00:23:12.840 --> 00:23:15.360
So we can go through the whole way importing that module,


00:23:15.360 --> 00:23:17.000
and foo just continues to sit there


00:23:17.000 --> 00:23:20.800
as kind of this deferred pending import.


00:23:20.800 --> 00:23:23.060
And then later at runtime, maybe somebody


00:23:23.060 --> 00:23:25.120
calls a function from our module.


00:23:25.120 --> 00:23:28.700
And within that function, we have a call to foo.bar


00:23:28.700 --> 00:23:30.220
or something like that, a reference


00:23:30.220 --> 00:23:31.760
to some attribute of the module.


00:23:31.760 --> 00:23:34.980
And at that moment, the first time we actually, at runtime,


00:23:34.980 --> 00:23:38.420
run into a reference to the name foo,


00:23:38.420 --> 00:23:40.900
that's the moment when we'll suddenly say, OK,


00:23:40.900 --> 00:23:41.620
hold everything.


00:23:41.620 --> 00:23:44.660
We need to go off, figure out what foo is, import it.


00:23:44.660 --> 00:23:47.320
Now we actually have the proper foo module.


00:23:47.320 --> 00:23:49.620
And now we can go ahead and figure out what foo.bar is


00:23:49.620 --> 00:23:50.380
and move on.


00:23:50.380 --> 00:23:55.700
So that's kind of the essence of PEP 690, is to try to do that.


00:23:55.700 --> 00:23:58.940
Defer imports until the moment when they're first referenced,


00:23:58.940 --> 00:24:03.700
but try to do it transparently so that as much as possible,


00:24:03.700 --> 00:24:07.100
apart from side effects of the import itself,


00:24:07.100 --> 00:24:09.460
you really can't tell the difference in your code


00:24:09.460 --> 00:24:12.180
that the import was delayed.


00:24:12.180 --> 00:24:14.340
>>Right, the runtime behavior might


00:24:14.340 --> 00:24:15.740
be a little bit different.


00:24:15.740 --> 00:24:19.820
Ideally, faster and using less memory, which would be great.


00:24:19.820 --> 00:24:25.360
But other than that, your code shouldn't--


00:24:25.360 --> 00:24:29.360
but maybe italics-- shouldn't know the difference.


00:24:29.360 --> 00:24:35.160
If you're doing good coding styles and good patterns,


00:24:35.160 --> 00:24:37.440
basically not creating side effects during imports,


00:24:37.440 --> 00:24:39.280
you shouldn't be able to tell the difference.


00:24:39.280 --> 00:24:43.360
And so if you've got, say, a function that uses JSON parsing


00:24:43.360 --> 00:24:47.400
but that only periodically gets called under some pass,


00:24:47.400 --> 00:24:50.840
you could avoid import JSON effectively


00:24:50.840 --> 00:24:52.980
unless you need that bit of functionality.


00:24:52.980 --> 00:24:56.220
And for larger projects that can really cascade, right?


00:24:56.220 --> 00:24:57.980
- Right, that's the whole idea.


00:24:57.980 --> 00:25:00.440
So if you think of like a command line program


00:25:00.440 --> 00:25:03.900
that maybe has like 10 sub commands, right?


00:25:03.900 --> 00:25:06.460
And each of those sub commands


00:25:06.460 --> 00:25:08.620
might do something fairly different


00:25:08.620 --> 00:25:11.120
and they might have very different dependencies.


00:25:11.120 --> 00:25:14.500
So on any given time that you run that command line program,


00:25:14.500 --> 00:25:16.700
if you're only using one sub command,


00:25:16.700 --> 00:25:18.340
you don't actually need any of the dependencies


00:25:18.340 --> 00:25:19.740
of the other nine subcommands.


00:25:19.740 --> 00:25:21.980
So with lazy imports, you can avoid,


00:25:21.980 --> 00:25:23.940
you can basically pay for what you use


00:25:23.940 --> 00:25:27.260
every time you run a program and only pay for what you use.


00:25:27.260 --> 00:25:28.260
- Yeah, that's fantastic.


00:25:28.260 --> 00:25:29.580
I really liked the idea.


00:25:29.580 --> 00:25:32.780
And the transparent aspect of it is,


00:25:32.780 --> 00:25:34.980
what Barry was fond of is that


00:25:34.980 --> 00:25:38.900
we write code the way we traditionally wrote.


00:25:38.900 --> 00:25:41.580
We write import requests or import JSON


00:25:41.580 --> 00:25:42.900
or whatever at the top.


00:25:42.900 --> 00:25:46.700
and it's up to a special dictionary


00:25:46.700 --> 00:25:50.460
that replaces a standard dictionary that holds the globals.


00:25:50.460 --> 00:25:52.060
It says when you access one of these things,


00:25:52.060 --> 00:25:55.420
if it's not yet materialized and really imported,


00:25:55.420 --> 00:25:56.780
go do that and then hand it off.


00:25:56.780 --> 00:25:59.320
Otherwise just hand off the module, right?


00:25:59.320 --> 00:26:00.320
Something like that?


00:26:00.320 --> 00:26:02.580
- Yeah, yeah.


00:26:02.580 --> 00:26:04.660
I think you've said it really well.


00:26:04.660 --> 00:26:05.500
- Thanks.


00:26:05.500 --> 00:26:08.900
- It's actually a standard dictionary for the module,


00:26:08.900 --> 00:26:11.940
but it's just a specialized lookup function, essentially.


00:26:11.940 --> 00:26:13.140
- Got it. - Right.


00:26:13.140 --> 00:26:16.140
So when that deferred object gets installed


00:26:16.140 --> 00:26:18.700
into the modules dictionary,


00:26:18.700 --> 00:26:20.940
and this is, I think it's really key because


00:26:20.940 --> 00:26:26.140
at the point at which that the dictionary lookup function


00:26:26.140 --> 00:26:28.140
finds this deferred object,


00:26:28.140 --> 00:26:30.180
that's when the object is resolved.


00:26:30.180 --> 00:26:33.680
And what that really means is that at the Python level,


00:26:33.680 --> 00:26:36.340
and even if you're a extension writer


00:26:36.340 --> 00:26:39.180
accessing the modules dictionary,


00:26:39.180 --> 00:26:41.700
you never see those deferred objects.


00:26:41.700 --> 00:26:43.420
So they're completely hidden,


00:26:43.420 --> 00:26:48.220
both from the C extension author and Python developer.


00:26:48.220 --> 00:26:49.060
It's just complete,


00:26:49.060 --> 00:26:52.460
and that's where the transparency really shines.


00:26:52.460 --> 00:26:54.580
- Yeah, that's where, yeah.


00:26:54.580 --> 00:26:57.980
Yeah, 'cause if you're gonna force a new programming model


00:26:57.980 --> 00:27:01.220
onto people, all of a sudden, they're gonna not like it.


00:27:01.220 --> 00:27:04.080
And we saw how easy that was to go from two to three.


00:27:04.080 --> 00:27:05.860
- Yeah.


00:27:05.860 --> 00:27:09.540
- Right, so let's not try that again.


00:27:09.540 --> 00:27:10.780
Oh, it was so easy.


00:27:10.780 --> 00:27:12.900
I guess before we get further into this,


00:27:12.900 --> 00:27:16.020
it's worth pointing out that this is in draft status.


00:27:16.020 --> 00:27:19.780
It was created about a month and a week ago,


00:27:19.780 --> 00:27:22.100
so it's not super old.


00:27:22.100 --> 00:27:23.580
It's in draft.


00:27:23.580 --> 00:27:28.020
If it appears, it'll be in 3.12 probably.


00:27:28.020 --> 00:27:29.380
What's the status of the PEP?


00:27:29.380 --> 00:27:33.140
It's basically proposed and under discussion?


00:27:33.140 --> 00:27:34.980
>>Yeah, it's being currently discussed.


00:27:39.700 --> 00:27:46.480
I think I went and looked recently and saw that in discuss.python.org, in the peps category,


00:27:46.480 --> 00:27:52.500
I think the pep690 thread has more posts than any other thread there.


00:27:52.500 --> 00:27:55.900
So it's been thoroughly discussed.


00:27:55.900 --> 00:28:01.060
But at this point, I think to some extent, the discussion is on hold while we work on


00:28:01.060 --> 00:28:06.540
getting an implementation against the Python main branch.


00:28:06.540 --> 00:28:10.860
our implementation in Cinder. Cinder is unfortunately still based on Python 3.8.


00:28:10.860 --> 00:28:15.980
We're currently working on upgrading it to 3.10. But there's some changes in the underlying


00:28:15.980 --> 00:28:24.380
dictionary and in other things between 3.8 and now 3.12 alpha. So the implementation needs some


00:28:24.380 --> 00:28:29.740
reworking. And we need to get that available for people to look at and play with to really move to


00:28:29.740 --> 00:28:34.860
the next stage in discussion. >> Yeah. Just a side note. So with


00:28:34.860 --> 00:28:38.540
Projects like Cinder and stuff, it's based on 3.8,


00:28:38.540 --> 00:28:39.100
which is great.


00:28:39.100 --> 00:28:40.400
There's a lot of good features.


00:28:40.400 --> 00:28:43.260
I mean, basically 3.6 and beyond, you get f-strings,


00:28:43.260 --> 00:28:44.260
you get async and away.


00:28:44.260 --> 00:28:46.500
You get a lot of amazing stuff there.


00:28:46.500 --> 00:28:50.380
But this shift from 10 to 11, there's


00:28:50.380 --> 00:28:53.220
a big performance boost that's sort of coming along there.


00:28:53.220 --> 00:28:56.420
Are you guys looking to sort of bring all of this stuff


00:28:56.420 --> 00:28:59.620
into 11 as sort of a stable point?


00:28:59.620 --> 00:29:02.740
Or what's the story there?


00:29:02.740 --> 00:29:04.380
>>Tomtom: For Cinder in general?


00:29:04.380 --> 00:29:05.620
Yeah, yeah.


00:29:05.620 --> 00:29:06.820
Yeah, yeah.


00:29:06.820 --> 00:29:11.020
So I mean, we're currently upgrading to 3.10


00:29:11.020 --> 00:29:13.900
just to go two versions at a time


00:29:13.900 --> 00:29:17.140
instead of trying to leap three versions in one bound.


00:29:17.140 --> 00:29:18.680
And also because, as you said, there's


00:29:18.680 --> 00:29:20.580
a lot of changes between 3.10 and 3.11.


00:29:20.580 --> 00:29:26.740
So we want to kind of isolate those and get 3.10 stable first


00:29:26.740 --> 00:29:29.260
and get it in production for Instagram and everything.


00:29:29.260 --> 00:29:30.500
So that's our current target.


00:29:30.500 --> 00:29:33.300
And then once that's done, we'll probably


00:29:33.300 --> 00:29:35.940
look at 3.12 next.


00:29:35.940 --> 00:29:39.460
But yeah, we do wanna bring Cinder up to date


00:29:39.460 --> 00:29:42.100
and also really looking at trying to upstream


00:29:42.100 --> 00:29:44.520
a lot of the things that are in Cinder


00:29:44.520 --> 00:29:46.340
so that more people can benefit from them


00:29:46.340 --> 00:29:48.100
and to reduce the amount of work we have to do


00:29:48.100 --> 00:29:50.580
to be constantly rebasing all of our stuff


00:29:50.580 --> 00:29:51.780
on newer versions of Python.


00:29:51.780 --> 00:29:53.420
So our goal, hopefully--


00:29:53.420 --> 00:29:55.620
- Every one of these you get accepted.


00:29:55.620 --> 00:29:57.400
Yeah, sorry, everything that you get accepted


00:29:57.400 --> 00:29:59.740
is just one fewer thing you have to maintain.


00:29:59.740 --> 00:30:02.180
You can't do it to Barry, let Barry do it.


00:30:02.180 --> 00:30:03.980
[LAUGHTER]


00:30:03.980 --> 00:30:06.180
>> Well, I mean, we hope to continue to help maintain


00:30:06.180 --> 00:30:07.180
these things upstream too.


00:30:07.180 --> 00:30:08.180
>> Yes, of course.


00:30:08.180 --> 00:30:08.900
Yeah, of course.


00:30:08.900 --> 00:30:11.780
But if you can make it part of the broader community thing,


00:30:11.780 --> 00:30:12.900
it's no longer your team.


00:30:12.900 --> 00:30:15.900
It's the community's benefit.


00:30:15.900 --> 00:30:17.580
Yeah.


00:30:17.580 --> 00:30:19.140
OK, let's talk a little bit about some


00:30:19.140 --> 00:30:22.380
of the different forms of imports


00:30:22.380 --> 00:30:23.420
and how they affect this.


00:30:23.420 --> 00:30:26.180
Because out in the audience, Hybrid Robotics


00:30:26.180 --> 00:30:29.260
asks, when you do from library import function,


00:30:29.260 --> 00:30:31.420
does this really save memory?


00:30:31.420 --> 00:30:34.280
I think that maybe sets the stage for talking about


00:30:34.280 --> 00:30:37.240
when there's different styles of imports we can do,


00:30:37.240 --> 00:30:39.420
obviously, we can just do import library,


00:30:39.420 --> 00:30:42.740
we could do from library import function


00:30:42.740 --> 00:30:44.680
or import star, all these different things.


00:30:44.680 --> 00:30:47.080
And there's rules in the pep about


00:30:47.080 --> 00:30:50.460
how that controls the laziness or the alternative,


00:30:50.460 --> 00:30:53.320
I guess the current default way is called eager loading


00:30:53.320 --> 00:30:54.580
or eager imports, right?


00:30:54.580 --> 00:30:57.760
- I think it's really good that HyperRobotic


00:30:57.760 --> 00:31:00.620
brought up this question of from library import function,


00:31:00.620 --> 00:31:03.740
because that's actually a key way that PEP 690 is different


00:31:03.740 --> 00:31:06.340
from the existing ways of doing lazy imports.


00:31:06.340 --> 00:31:08.460
So there are existing things out there.


00:31:08.460 --> 00:31:11.500
There's a lazy import loader in the standard library,


00:31:11.500 --> 00:31:13.140
and there's something called demand import


00:31:13.140 --> 00:31:15.580
on the package index that came out of Mercurial.


00:31:15.580 --> 00:31:17.340
And all of these things take the approach


00:31:17.340 --> 00:31:19.380
of having a custom module object


00:31:19.380 --> 00:31:22.740
that when you do a get attribute on it,


00:31:22.740 --> 00:31:25.500
it has a dunder get attr or dunder get attribute


00:31:25.500 --> 00:31:28.420
implementation that waits for an attribute access


00:31:28.420 --> 00:31:30.880
and then goes out and does the import.


00:31:30.880 --> 00:31:34.120
And that works for import foo, but it doesn't make


00:31:34.120 --> 00:31:38.680
from foo import bar lazy, because from foo import bar


00:31:38.680 --> 00:31:41.000
gets the foo module, and then you immediately


00:31:41.000 --> 00:31:42.720
access the bar attribute on it.


00:31:42.720 --> 00:31:46.640
And so if you're using this lazy module object style,


00:31:46.640 --> 00:31:48.100
then effectively it's just eager,


00:31:48.100 --> 00:31:50.100
because you get the attribute off it right away,


00:31:50.100 --> 00:31:51.640
and that makes the import happen.


00:31:51.640 --> 00:31:53.840
And the difference with PEP 690 is


00:31:53.840 --> 00:31:58.440
that with from foo import bar, we just stick a lazy object


00:31:58.440 --> 00:32:00.720
into the namespace of the importing module


00:32:00.720 --> 00:32:03.160
under the name bar instead of under the name foo.


00:32:03.160 --> 00:32:06.080
But it's still a lazy object, and the import still


00:32:06.080 --> 00:32:09.360
won't happen until something later actually


00:32:09.360 --> 00:32:10.880
uses the name bar.


00:32:10.880 --> 00:32:13.400
So even in the case of from foo import bar,


00:32:13.400 --> 00:32:15.120
we're still able to make it lazy,


00:32:15.120 --> 00:32:19.760
and it still will save memory, at least until or unless you


00:32:19.760 --> 00:32:23.320
actually use the imported thing.


00:32:23.320 --> 00:32:26.040
Yeah, that's a great summary. I would like to point out maybe just


00:32:26.040 --> 00:32:30.440
not entirely sure where they're coming from here. So


00:32:30.440 --> 00:32:36.920
today, if you write from library import function versus just import library or from library import


00:32:36.920 --> 00:32:40.520
star, you're not really saving any memory. It basically is doing the same thing, right? The


00:32:40.520 --> 00:32:46.200
module object is created, it's imported, all the stuff is done. It's just what symbols are defined


00:32:46.200 --> 00:32:51.880
for you, right? It's more of a syntax thing than it is a memory thing right now. Yeah.


00:32:52.920 --> 00:32:55.240
- Yeah, yeah, that's correct.


00:32:55.240 --> 00:32:57.880
- Yeah, but in the thing you're proposing,


00:32:57.880 --> 00:33:01.280
this will still be the lazy version, which is great.


00:33:01.280 --> 00:33:04.320
- Yes, yes.


00:33:04.320 --> 00:33:09.640
- Yeah, so there's different ways in which we do import.


00:33:09.640 --> 00:33:13.320
Sometimes people even do imports inside of try blocks.


00:33:13.320 --> 00:33:16.040
So like try to import this thing,


00:33:16.040 --> 00:33:19.080
and if it's not there, maybe try to shim it in


00:33:19.080 --> 00:33:22.600
or report that this module is a dependency or other things.


00:33:22.600 --> 00:33:27.840
And it's literally the import statement that is supposed to succeed or fail that communicates back


00:33:27.840 --> 00:33:30.360
Whether or not that was okay, right?


00:33:30.360 --> 00:33:33.360
And with this lazy version you're going to change


00:33:33.360 --> 00:33:38.920
It's not going to fail within that tribe lock because within the tribe lock it's going to create a deferred


00:33:38.920 --> 00:33:41.600
Lazy thing and that'll always work, right?


00:33:41.600 --> 00:33:45.080
Well


00:33:45.080 --> 00:33:51.760
It actually could also fail in certain circumstances, but for the most part it should just work


00:33:51.760 --> 00:33:58.600
If you have an import inside a try block or inside a class or inside a function, all those


00:33:58.600 --> 00:34:00.400
imports are eager imports.


00:34:00.400 --> 00:34:01.400
>> Right, exactly.


00:34:01.400 --> 00:34:06.480
So what I was getting at is that you're actually specifying that if there's an import within


00:34:06.480 --> 00:34:12.360
a try except or within a with block, you're actually not letting that be lazy.


00:34:12.360 --> 00:34:14.400
You're making them be eager, right?


00:34:14.400 --> 00:34:15.400
>> That's right.


00:34:15.400 --> 00:34:16.400
Yeah, exactly.


00:34:16.400 --> 00:34:20.760
Although imports inside this important thing are also lazy.


00:34:20.760 --> 00:34:25.760
So if any of those fail, and you're expecting those to fail,


00:34:25.760 --> 00:34:30.080
it could not throw an exception there


00:34:30.080 --> 00:34:32.960
in that reason, in that case.


00:34:32.960 --> 00:34:33.800
- Okay.


00:34:33.800 --> 00:34:39.880
And then also from thing import star has to be eager.


00:34:39.880 --> 00:34:42.400
Why does that one have to be eager?


00:34:42.400 --> 00:34:45.480
- Yeah, because we don't have the current names


00:34:45.480 --> 00:34:48.280
of that are being imported.


00:34:48.280 --> 00:34:53.280
And so there's no way to add these lazy objects


00:34:53.280 --> 00:34:54.800
to these names.


00:34:54.800 --> 00:34:56.600
So we need to just import everything


00:34:56.600 --> 00:34:59.800
and see what are the names that are being imported.


00:34:59.800 --> 00:35:02.120
That's the main reason for it.


00:35:02.120 --> 00:35:03.580
- Yeah, right.


00:35:03.580 --> 00:35:05.800
Because when you say star,


00:35:05.800 --> 00:35:09.280
you don't know what to put into the modules symbol table.


00:35:09.280 --> 00:35:10.120
Right?


00:35:10.120 --> 00:35:13.320
So you've got to actually do the import


00:35:13.320 --> 00:35:15.440
to figure out the star.


00:35:15.440 --> 00:35:16.600
That's pretty interesting.


00:35:16.600 --> 00:35:19.920
So there's some interesting examples


00:35:19.920 --> 00:35:22.360
you have in the pep that people can check out about.


00:35:22.360 --> 00:35:27.720
Here's sort of a fake slow module that just


00:35:27.720 --> 00:35:30.560
does time.sleep, but it effectively


00:35:30.560 --> 00:35:32.360
shows that it could be slow.


00:35:32.360 --> 00:35:35.800
You can run it like do an import,


00:35:35.800 --> 00:35:37.280
and it'll run instantly, basically,


00:35:37.280 --> 00:35:38.640
because it's not actually--


00:35:38.640 --> 00:35:41.280
if you're not accessing that module, really, at that point,


00:35:41.280 --> 00:35:42.880
it's pretty much instant.


00:35:42.880 --> 00:35:45.880
I guess one thing to point out here-- and this is--


00:35:45.880 --> 00:35:47.520
I don't know how I feel about this,


00:35:47.520 --> 00:35:50.800
but maybe we could talk about it a bit.


00:35:50.800 --> 00:35:54.160
The proposal is that this is not the default behavior


00:35:54.160 --> 00:35:58.680
for Python indefinitely into the future,


00:35:58.680 --> 00:36:02.240
that you have to pass a -l flag to the interpreter


00:36:02.240 --> 00:36:05.720
or set an environment variable or something along those lines.


00:36:05.720 --> 00:36:10.360
Do you want to talk about why make it opt in instead of maybe


00:36:10.360 --> 00:36:10.860
opt out?


00:36:13.560 --> 00:36:15.560
- Yeah, probably, I wish it wasn't,


00:36:15.560 --> 00:36:18.120
I wish it was a default.


00:36:18.120 --> 00:36:21.200
That's what I would wish to.


00:36:21.200 --> 00:36:23.320
But the thing, the reality is that


00:36:23.320 --> 00:36:27.200
there are a lot of applications and modules


00:36:27.200 --> 00:36:30.440
that are using or relying on import side effects.


00:36:30.440 --> 00:36:33.600
So we can just expect those


00:36:33.600 --> 00:36:39.000
to be lazy import compatible anytime soon.


00:36:39.000 --> 00:36:42.080
- So you're saying there's a lot of bad code out there?


00:36:42.080 --> 00:36:43.520
Is that what you're saying?


00:36:43.520 --> 00:36:44.520
No.


00:36:44.520 --> 00:36:48.040
But if it has side effects, right?


00:36:48.040 --> 00:36:52.640
If it's like, oh, because you imported this, we've initialized the database connection.


00:36:52.640 --> 00:36:59.400
Well, I guess, I guess the way you know, there's actually some really good discussion on the


00:36:59.400 --> 00:37:01.920
discourse thread about this.


00:37:01.920 --> 00:37:07.720
And I feel like this is, this is actually an important aspect of the PEP.


00:37:07.720 --> 00:37:13.220
one of the things that was sort of pointed out in this discussion is that,


00:37:13.220 --> 00:37:20.720
you know, like I'm, I both author libraries and I author applications,


00:37:20.720 --> 00:37:27.720
right? As a library author, I can't really reason about whether I can sort


00:37:27.720 --> 00:37:32.720
of say, yeah, maybe my library is unsafe for lazy, but I can never really say,


00:37:32.720 --> 00:37:37.720
assert that my module is safe for laziness


00:37:37.720 --> 00:37:41.180
and be certain that in all the ways


00:37:41.180 --> 00:37:43.220
that all my downstream consumers


00:37:43.220 --> 00:37:45.440
are gonna use my library, right?


00:37:45.440 --> 00:37:47.460
That it's always gonna be safe for lazy import.


00:37:47.460 --> 00:37:49.660
So as a library author,


00:37:49.660 --> 00:37:54.100
it's not really something that I can necessarily assert,


00:37:54.100 --> 00:37:54.940
right?


00:37:54.940 --> 00:37:57.460
But as an application author,


00:37:57.460 --> 00:38:01.560
I should have, I'm really in the only position


00:38:01.560 --> 00:38:05.600
to reason about how my dependencies are used


00:38:05.600 --> 00:38:07.120
inside my application.


00:38:07.120 --> 00:38:10.840
So in my mind, it's my responsibility


00:38:10.840 --> 00:38:13.280
as an application author to say,


00:38:13.280 --> 00:38:15.200
I know how all my dependencies are used


00:38:15.200 --> 00:38:18.360
and therefore I can assert that lazy imports


00:38:18.360 --> 00:38:20.200
are safe for my application.


00:38:20.200 --> 00:38:22.720
So by using it, by having the,


00:38:22.720 --> 00:38:25.060
I'm a little uncertain about the environment variable,


00:38:25.060 --> 00:38:28.920
but I feel pretty strongly like the flag.


00:38:28.920 --> 00:38:30.680
It's the responsibility of the--


00:38:30.680 --> 00:38:31.360
yeah.


00:38:31.360 --> 00:38:33.760
Yeah, it's the responsibility of the person running it,


00:38:33.760 --> 00:38:35.240
sort of, OK?


00:38:35.240 --> 00:38:37.920
Yeah, it's the leaf--


00:38:37.920 --> 00:38:38.560
the leaf depends.


00:38:38.560 --> 00:38:41.120
Yeah, yeah, it's the top--


00:38:41.120 --> 00:38:43.040
the top of the tree.


00:38:43.040 --> 00:38:45.920
Yeah, yeah.


00:38:45.920 --> 00:38:49.240
Yeah, to give an example of what Barry is talking about


00:38:49.240 --> 00:38:52.960
is like, I mean, for better or worse,


00:38:52.960 --> 00:38:54.440
some level of import side effects


00:38:54.440 --> 00:38:56.200
are just kind of built into Python.


00:38:56.200 --> 00:38:59.520
Like if you have a module that subclasses a class


00:38:59.520 --> 00:39:01.880
from another module, you may think


00:39:01.880 --> 00:39:04.360
that you have a module with no import side effects,


00:39:04.360 --> 00:39:06.720
but actually importing your module


00:39:06.720 --> 00:39:10.400
adds something to the Dunder subclasses of the module


00:39:10.400 --> 00:39:11.520
you inherited from.


00:39:11.520 --> 00:39:14.680
And so even code that apparently looks


00:39:14.680 --> 00:39:18.120
very clean and clear of import side effects


00:39:18.120 --> 00:39:20.800
does technically have some side effects on import.


00:39:20.800 --> 00:39:23.480
And the real question is, is anybody actually


00:39:23.480 --> 00:39:26.640
looking at Dunder subclasses on the parent module.


00:39:26.640 --> 00:39:30.040
And there's a lot of common library patterns


00:39:30.040 --> 00:39:32.940
like decorators that when you decorate a function,


00:39:32.940 --> 00:39:34.840
they register that function to that class


00:39:34.840 --> 00:39:36.940
and some registry and some other module.


00:39:36.940 --> 00:39:38.840
So then suddenly again, you have an important side of--


00:39:38.840 --> 00:39:40.480
- Like Flask or something, yeah.


00:39:40.480 --> 00:39:42.460
- Right, yep, exactly.


00:39:42.460 --> 00:39:46.560
So it really has to be the person writing the application


00:39:46.560 --> 00:39:48.760
and testing the application who says,


00:39:48.760 --> 00:39:50.160
I'm gonna try lazy imports,


00:39:50.160 --> 00:39:51.280
I'm gonna see if things work.


00:39:51.280 --> 00:39:54.240
I know how my dependencies are used.


00:39:54.240 --> 00:39:56.000
If it works well and all my tests pass,


00:39:56.000 --> 00:39:59.540
then I can consider just turning this on at that level.


00:39:59.540 --> 00:40:01.800
- Sure.


00:40:01.800 --> 00:40:03.000
Okay, interesting.


00:40:03.000 --> 00:40:09.680
So taking Barry's idea that it's the application owner


00:40:09.680 --> 00:40:11.960
who should sort of make this decision,


00:40:11.960 --> 00:40:14.600
what about having some code artifact


00:40:14.600 --> 00:40:18.120
that allows you to signal that as well, right?


00:40:18.120 --> 00:40:22.280
So as I run it, I can control whether or not this happens.


00:40:22.280 --> 00:40:27.120
But what if I just, the very first line of my app.py


00:40:27.120 --> 00:40:31.180
or whatever it is, I just say, import lazy


00:40:31.180 --> 00:40:32.720
or something like that.


00:40:32.720 --> 00:40:34.680
And then every subsequent thing


00:40:34.680 --> 00:40:36.240
from there on behaves that way.


00:40:36.240 --> 00:40:39.880
That way, if I distribute my app to someone else,


00:40:39.880 --> 00:40:43.000
I don't have to convince them or teach them about -l.


00:40:43.000 --> 00:40:45.360
I can just say, no, just double click this thing


00:40:45.360 --> 00:40:49.400
or run this and it'll go in a consistent way.


00:40:49.400 --> 00:40:51.800
- Yeah, we actually...


00:40:51.800 --> 00:40:53.280
Go ahead, go ahead, Barry.


00:40:53.280 --> 00:40:54.120
- I was just gonna say,


00:40:54.120 --> 00:40:55.720
as long as you don't have like PTH files


00:40:55.720 --> 00:40:57.000
that are getting in the way


00:40:57.000 --> 00:41:01.120
before your main gets called, right?


00:41:01.120 --> 00:41:02.200
Go ahead, Carl, sorry.


00:41:02.200 --> 00:41:03.880
- Yeah, no, I was just gonna say,


00:41:03.880 --> 00:41:06.120
there was a lot of discussion about that in the thread


00:41:06.120 --> 00:41:07.960
and there actually is a draft


00:41:07.960 --> 00:41:11.160
of a heavily revised version of the PEP


00:41:11.160 --> 00:41:13.080
up for Barry's review, actually.


00:41:13.080 --> 00:41:14.280
So, Barry, you can...


00:41:14.280 --> 00:41:16.720
- Barry, you want me to pull that up for you?


00:41:16.720 --> 00:41:17.560
We can go through it right now.


00:41:17.560 --> 00:41:18.400
- Yeah, yeah, yeah.


00:41:18.400 --> 00:41:20.080
(laughing)


00:41:20.080 --> 00:41:22.360
- One of the changes that is made in that draft


00:41:22.360 --> 00:41:25.440
is both removing the environment variable


00:41:25.440 --> 00:41:27.400
because people were concerned about the risk


00:41:27.400 --> 00:41:30.000
that if somebody just got the idea that,


00:41:30.000 --> 00:41:32.120
oh, lazy imports makes everything faster,


00:41:32.120 --> 00:41:34.160
they might try to just set the environment variable


00:41:34.160 --> 00:41:35.400
in their shell.


00:41:35.400 --> 00:41:37.900
And then all of the Python programs they run


00:41:37.900 --> 00:41:40.000
will try to run with lazy imports and might break


00:41:40.000 --> 00:41:41.120
and then they're reporting bugs.


00:41:41.120 --> 00:41:42.800
And that's not a great experience.


00:41:42.800 --> 00:41:44.960
we want it to be really limited to an application


00:41:44.960 --> 00:41:46.760
that's tested with lazy imports.


00:41:46.760 --> 00:41:48.960
So the latest draft of the PEP removes


00:41:48.960 --> 00:41:51.360
the environment variable and actually adds exactly


00:41:51.360 --> 00:41:54.240
what you're talking about, a programmatic way


00:41:54.240 --> 00:41:56.840
to enable lazy imports for your application in code.


00:41:56.840 --> 00:41:59.600
- What is the code way?


00:41:59.600 --> 00:42:04.520
- Well, I mean, it's just a proposal in my draft PR


00:42:04.520 --> 00:42:05.600
to the PEP text right now.


00:42:05.600 --> 00:42:07.120
So we'll see what Barry says about it.


00:42:07.120 --> 00:42:07.960
- Sure.


00:42:07.960 --> 00:42:08.800
- It could well change.


00:42:08.800 --> 00:42:10.120
- The reason I asked, the reason I asked--


00:42:10.120 --> 00:42:11.360
- I just rubber stamped it.


00:42:11.360 --> 00:42:13.920
(laughing)


00:42:13.920 --> 00:42:15.520
- So the reason I ask is,


00:42:15.520 --> 00:42:18.880
there's sometimes certain things you've got to do


00:42:18.880 --> 00:42:21.200
to like tweak the path or something


00:42:21.200 --> 00:42:22.440
to get imports to work right


00:42:22.440 --> 00:42:25.280
if you're running from some weird location or something,


00:42:25.280 --> 00:42:28.400
thinking of like Alembic migrations and stuff like that.


00:42:28.400 --> 00:42:32.200
But in a lot of the editors and the lynchers,


00:42:32.200 --> 00:42:34.080
they'll whine at you and say,


00:42:34.080 --> 00:42:37.200
"No, no, no, these imports that go below that


00:42:37.200 --> 00:42:39.720
modification to the path statement, they go above it."


00:42:39.720 --> 00:42:41.760
Like, no, the whole point of the thing above it


00:42:41.760 --> 00:42:43.960
is so the things below it don't fail.


00:42:43.960 --> 00:42:47.440
Is there-- like, whatever it is, I just


00:42:47.440 --> 00:42:49.320
want to put in a little hint.


00:42:49.320 --> 00:42:52.920
Like, if you could make the editors not complain


00:42:52.920 --> 00:42:54.760
that the stuff below it should go above it,


00:42:54.760 --> 00:42:57.000
because the stuff below it is controlled by the stuff


00:42:57.000 --> 00:42:58.640
above it, you know what I mean?


00:42:58.640 --> 00:43:00.440
Yeah, the current proposal, I don't think--


00:43:00.440 --> 00:43:03.120
I mean, I suppose if it becomes merged,


00:43:03.120 --> 00:43:06.280
the linters and such could special case it.


00:43:06.280 --> 00:43:08.640
I think hopefully that's not too huge of an issue,


00:43:08.640 --> 00:43:09.720
because the idea is, I mean,


00:43:09.720 --> 00:43:11.840
you potentially have a large application


00:43:11.840 --> 00:43:14.480
and this would occur like in one main module.


00:43:14.480 --> 00:43:17.080
- Or you just put like all this function.


00:43:17.080 --> 00:43:19.400
Yeah, you put the hash ignore and then you're good to go.


00:43:19.400 --> 00:43:20.240
- Right.


00:43:20.240 --> 00:43:21.400
- You got it.


00:43:21.400 --> 00:43:22.240
Okay, cool.


00:43:22.240 --> 00:43:25.120
Let's go talk about some of the benefits here.


00:43:25.120 --> 00:43:27.640
So in terms of performance,


00:43:27.640 --> 00:43:31.780
you saw, I don't know where's the,


00:43:31.780 --> 00:43:34.280
if I go searching for percent signs, there we go.


00:43:36.040 --> 00:43:39.720
So it says it's already been demonstrated for startup time


00:43:39.720 --> 00:43:45.240
improvements of 70% and memory reduction of real-world CLIs


00:43:45.240 --> 00:43:46.400
by 40%.


00:43:46.400 --> 00:43:47.840
Those are not joking around.


00:43:47.840 --> 00:43:50.280
This is not playing at the edges of performance changes.


00:43:50.280 --> 00:43:52.200
This is significant.


00:43:52.200 --> 00:43:56.720
So are those numbers from what you're


00:43:56.720 --> 00:44:01.040
doing with Instagram or other tools that you tested it on


00:44:01.040 --> 00:44:03.320
or something like that?


00:44:03.320 --> 00:44:07.160
- These are numbers from Instagram, Instagram server.


00:44:07.160 --> 00:44:12.160
And also I love common line tools that we use inside meta.


00:44:12.160 --> 00:44:16.160
So yeah, these are real numbers.


00:44:16.160 --> 00:44:17.600
It's up to 70%.


00:44:17.600 --> 00:44:21.960
Sometimes we've seen 50% improvement in startup speed.


00:44:21.960 --> 00:44:25.880
And memory is also up to 40%.


00:44:25.880 --> 00:44:27.200
We've seen 20%. - Right, these are upper bound


00:44:27.200 --> 00:44:28.600
of course, sure.


00:44:28.600 --> 00:44:31.200
But what I think is good about that is it's not,


00:44:31.200 --> 00:44:33.080
you know, sometimes people say,


00:44:33.080 --> 00:44:34.440
well, let's see how fast Python is.


00:44:34.440 --> 00:44:36.840
I'm gonna do a while true loop


00:44:36.840 --> 00:44:39.560
and see how many times I can increment a number


00:44:39.560 --> 00:44:42.040
and compare that to doing that and see like, it's okay.


00:44:42.040 --> 00:44:44.160
Nobody does this and they don't really care about how fast,


00:44:44.160 --> 00:44:46.280
like how do real apps behave?


00:44:46.280 --> 00:44:49.080
How do real, and so this is you taking the stuff


00:44:49.080 --> 00:44:50.880
that you all work with day to day


00:44:50.880 --> 00:44:52.000
and trying to make it faster


00:44:52.000 --> 00:44:54.480
and getting significant benefits from it.


00:44:54.480 --> 00:44:58.960
- Yeah, and I think an important thing to note there,


00:44:58.960 --> 00:45:00.840
yeah, I think an important thing to note there


00:45:00.840 --> 00:45:01.960
that Hermann mentioned is that


00:45:01.960 --> 00:45:03.520
this isn't just one code base.


00:45:03.520 --> 00:45:08.320
So, we've seen this as repeatable scale of improvement


00:45:08.320 --> 00:45:10.200
across a variety of different tools.


00:45:10.200 --> 00:45:12.160
In fact, recently we've started to see,


00:45:12.160 --> 00:45:17.160
we have a lot of data science people and researchers


00:45:17.160 --> 00:45:19.480
who use a lot of Jupyter notebooks,


00:45:19.480 --> 00:45:22.440
and they've started to really quickly pick up


00:45:22.440 --> 00:45:25.040
Jupyter notebooks kernels based on Cinder


00:45:25.040 --> 00:45:26.640
with lazy imports enabled,


00:45:26.640 --> 00:45:28.560
because they're seeing similar startup time


00:45:28.560 --> 00:45:31.320
and memory use numbers for their Jupyter notebooks.


00:45:31.320 --> 00:45:35.680
So across a fairly wide range of use cases and types of programs,


00:45:35.680 --> 00:45:37.400
we are seeing these kinds of numbers


00:45:37.400 --> 00:45:40.480
as consistently repeatable.


00:45:40.480 --> 00:45:42.880
>> Yeah, that's interesting, the data science side.


00:45:42.880 --> 00:45:44.640
A lot of those libraries are pretty large.


00:45:44.640 --> 00:45:50.200
And so I suspect that's probably pretty valuable.


00:45:50.200 --> 00:45:51.820
So one of the things you all talk about


00:45:51.820 --> 00:45:56.040
is that this proposal also will eliminate--


00:45:56.040 --> 00:45:58.840
what would you call it-- false import cycles?


00:45:58.840 --> 00:46:00.240
I don't know.


00:46:00.240 --> 00:46:02.980
Do you wanna talk about the cycle benefit


00:46:02.980 --> 00:46:04.280
that we might get here?


00:46:04.280 --> 00:46:06.820
- Yeah. - Don't answer,


00:46:06.820 --> 00:46:07.980
whoever wants to grab it.


00:46:07.980 --> 00:46:13.740
- I can try saying something about the import cycles.


00:46:13.740 --> 00:46:18.140
When you have imports at the top of the module


00:46:18.140 --> 00:46:21.060
and you're not using this import,


00:46:21.060 --> 00:46:26.020
and some of the imports that you are declaring there


00:46:26.020 --> 00:46:28.180
are importing something and in turn,


00:46:28.180 --> 00:46:32.060
at some point ends up importing the first module,


00:46:32.060 --> 00:46:34.020
then you have a cycle, right?


00:46:34.020 --> 00:46:39.020
So if one of these imports is not actually being used


00:46:39.020 --> 00:46:42.500
and is being deferred to a use case


00:46:42.500 --> 00:46:47.500
where it is only resolved inside a function further down,


00:46:47.500 --> 00:46:50.620
which is not being immediately called,


00:46:50.620 --> 00:46:53.220
then we won't have these cycles.


00:46:53.220 --> 00:46:58.220
And then a lot of times we have these kind of imports


00:46:58.220 --> 00:47:00.780
that are declared on the top of the modules


00:47:00.780 --> 00:47:04.780
because PEP-8 says that it's recommended


00:47:04.780 --> 00:47:08.060
to have all imports in the top of the module.


00:47:08.060 --> 00:47:11.140
And so people just start putting imports there


00:47:11.140 --> 00:47:13.660
because it's cleaner and looks better,


00:47:13.660 --> 00:47:18.660
but it ends up provoking these,


00:47:18.980 --> 00:47:23.000
because in this import cycles.


00:47:23.000 --> 00:47:29.960
- Nice, so hopefully this will solve some of those issues.


00:47:29.960 --> 00:47:32.040
I know when I first got into Python,


00:47:32.040 --> 00:47:36.580
I didn't understand why there wasn't a better way out of,


00:47:36.580 --> 00:47:41.140
like sharing code in a bi-directional way.


00:47:41.140 --> 00:47:42.860
It was really, it took a lot of thinking,


00:47:42.860 --> 00:47:45.100
like, okay, how can I structure my code


00:47:45.100 --> 00:47:47.780
into different files that don't feel like


00:47:47.780 --> 00:47:52.060
all just went in one file and yet allow me to reference it.


00:47:52.060 --> 00:47:54.560
Like, for example, if I've got one class


00:47:54.560 --> 00:47:56.820
and it works with another and it has a function


00:47:56.820 --> 00:47:59.480
that returns one type of it, but the other one might have a field


00:47:59.480 --> 00:48:02.280
which is one of those and you want to do a type declaration


00:48:02.280 --> 00:48:05.160
of saying which one is which, or you need to create the--


00:48:05.160 --> 00:48:07.160
call initializer of one or something.


00:48:07.160 --> 00:48:11.960
Those kinds of bidirectional relationships are hard to model.


00:48:11.960 --> 00:48:15.040
And it sounds like this doesn't really address or fix


00:48:15.040 --> 00:48:17.040
or change those in any significant way,


00:48:17.040 --> 00:48:21.040
but the other ones just about the timing can go away, right?


00:48:21.040 --> 00:48:30.080
So the only import cycles that lazy imports don't fix


00:48:30.080 --> 00:48:33.040
are the ones where basically it would be a cycle


00:48:33.040 --> 00:48:35.120
even if you had it in the same module,


00:48:35.120 --> 00:48:37.760
like where you're literally using names


00:48:37.760 --> 00:48:40.800
in a bidirectional way at module level,


00:48:40.800 --> 00:48:42.400
and so there's no way you can order them


00:48:42.400 --> 00:48:45.040
even within one module and have it work.


00:48:45.040 --> 00:48:46.480
So essentially four references.


00:48:46.480 --> 00:48:51.280
Those kinds of cycles, the lazy imports doesn't fix. But really any other kind of cycle where


00:48:51.280 --> 00:48:57.760
anywhere in the cycle one of the uses is inside a function, all of those are taken care of.


00:48:57.760 --> 00:49:04.560
And so even for the type annotation ones, if you use from future import annotations,


00:49:04.560 --> 00:49:12.080
PEP 563 or another proposal, PEP 649, anything that makes the type annotations also lazily


00:49:12.080 --> 00:49:16.880
evaluated, so they aren't eagerly evaluated at import time, then all of a sudden your cycles


00:49:16.880 --> 00:49:22.000
with that plus lazy imports, then all the cycle problems with type annotations also just disappears.


00:49:22.000 --> 00:49:28.800
I thought one of the, I was just gonna say, I think one of the interesting things that


00:49:28.800 --> 00:49:34.320
I think it was Carl pointed out when we were talking about this is that if you've got, you


00:49:34.320 --> 00:49:38.240
know, the converse is right, if you've got an application or something that's using this late,


00:49:38.240 --> 00:49:43.520
these lazy imports, and then you turn them off, you might be hit


00:49:43.520 --> 00:49:48.200
with a bunch of cycles that were sort of, you know, hidden from


00:49:48.200 --> 00:49:51.160
you because of the lazy feature, right? So you have to be a


00:49:51.160 --> 00:49:56.280
little bit careful about, you know, engaging with lazy imports


00:49:56.280 --> 00:49:59.360
and then turning them off, right, getting everything eager.


00:49:59.360 --> 00:50:01.880
So it's just one of those things to watch out for.


00:50:01.880 --> 00:50:05.320
Oh, interesting. Yeah. If, if you're doing it by running it


00:50:05.320 --> 00:50:10.080
with the run flag, you could be effectively hiding a runtime


00:50:10.080 --> 00:50:13.440
error that someone else would hit if they ran it without.


00:50:13.440 --> 00:50:14.440
- Yeah.


00:50:14.440 --> 00:50:15.280
- Right, right.


00:50:15.280 --> 00:50:16.640
Again, kind of back to my like,


00:50:16.640 --> 00:50:19.400
could the code define this instead of a runtime flag?


00:50:19.400 --> 00:50:21.680
So it's like absolutely consistent, yeah.


00:50:21.680 --> 00:50:26.280
Okay, let's talk about debuggability a little bit.


00:50:26.280 --> 00:50:31.120
So normally when you have an exception,


00:50:31.120 --> 00:50:34.000
if I import thing and there's a problem importing


00:50:34.000 --> 00:50:41.600
that thing, I'll get an exception on the line that the import did. But with this lazy thing,


00:50:41.600 --> 00:50:48.780
it'll be the import error will occur where the first attempt to touch it happens. Right.


00:50:48.780 --> 00:50:55.800
But you you all do some work to figure out and sort of report back. The error came from


00:50:55.800 --> 00:50:58.200
where the original import statement was, right?


00:50:58.200 --> 00:51:04.840
- Yes, yes, the error should be reported


00:51:04.840 --> 00:51:06.640
where the import is being declared


00:51:06.640 --> 00:51:08.200
so that it's easier to debug.


00:51:08.200 --> 00:51:14.320
Yes, this can also produce import errors in anywhere.


00:51:14.320 --> 00:51:18.240
So the other thing that we are thinking about


00:51:18.240 --> 00:51:23.240
adding to this implementation is to have an error wrapper


00:51:24.640 --> 00:51:27.360
around the real error that is being thrown.


00:51:27.360 --> 00:51:31.020
So we can easily know that it's just an import error


00:51:31.020 --> 00:51:32.860
coming from a lazy import.


00:51:32.860 --> 00:51:34.960
- Got it.


00:51:34.960 --> 00:51:38.600
Yeah, and it could theoretically, I guess,


00:51:38.600 --> 00:51:40.920
get caught in a situation


00:51:40.920 --> 00:51:43.560
where people would have not expected it, right?


00:51:43.560 --> 00:51:47.880
It could have a overly aggressive try except block.


00:51:47.880 --> 00:51:49.800
There's like, well, there's only two types of exceptions


00:51:49.800 --> 00:51:51.840
that come out of here possibly ever.


00:51:51.840 --> 00:51:54.280
And either of them, I'm gonna handle it in this case.


00:51:54.280 --> 00:51:56.480
Well, now here's a third, it's a surprise.


00:51:56.480 --> 00:51:58.760
- Yeah.


00:51:58.760 --> 00:52:00.720
- Yeah.


00:52:00.720 --> 00:52:04.040
Okay, but at least from sort of figuring out


00:52:04.040 --> 00:52:06.620
where the error came from,


00:52:06.620 --> 00:52:09.520
I guess you guys, what do you call it?


00:52:09.520 --> 00:52:12.480
Deferred exceptions is what you actually called that, right?


00:52:12.480 --> 00:52:15.200
Yeah.


00:52:15.200 --> 00:52:16.920
- Right.


00:52:16.920 --> 00:52:20.720
- So there's a couple of code examples in here


00:52:20.720 --> 00:52:23.520
and I'm through here.


00:52:23.520 --> 00:52:26.180
- Okay, you also have some code APIs.


00:52:26.180 --> 00:52:28.300
I talked about my wish for some code thing


00:52:28.300 --> 00:52:31.480
to declare laziness, I guess, is the way to put it.


00:52:31.480 --> 00:52:34.560
But different things happen.


00:52:34.560 --> 00:52:36.980
Like if you do the import within a tri-block,


00:52:36.980 --> 00:52:38.280
that forces them to be eager,


00:52:38.280 --> 00:52:43.280
but you also have defined this eager imports context manager


00:52:43.280 --> 00:52:48.360
sort of, that will force the imports to be eager, right?


00:52:48.360 --> 00:52:50.500
And I say sort of because it's not actually


00:52:50.500 --> 00:52:53.160
the eager imports thing, it's the with block.


00:52:53.160 --> 00:52:54.860
whatever you put in there, if you don't import in it


00:52:54.860 --> 00:52:56.960
is what's gonna trigger it, right?


00:52:56.960 --> 00:52:58.220
- Yeah, it doesn't matter.


00:52:58.220 --> 00:53:02.680
- Yeah, and then the third way is you can import,


00:53:02.680 --> 00:53:05.800
set eager imports and actually pass


00:53:05.800 --> 00:53:09.520
like namespace names in there.


00:53:09.520 --> 00:53:13.960
Because one of the problems is I'm gonna import a thing


00:53:13.960 --> 00:53:16.220
that's a package whose code I don't control


00:53:16.220 --> 00:53:19.080
and I need it to, for one particular thing,


00:53:19.080 --> 00:53:20.400
eagerly import that, right?


00:53:20.400 --> 00:53:22.760
So you kind of have to force it down the line


00:53:22.760 --> 00:53:25.040
or it's out of the chain of control there.


00:53:25.040 --> 00:53:30.040
So you can sort of set like, I wanna do fast API dot


00:53:30.040 --> 00:53:32.680
whatever like exceptions or whatever's in there.


00:53:32.680 --> 00:53:34.740
I wanna make sure that that eager loads


00:53:34.740 --> 00:53:37.320
even though I don't control fast API, right?


00:53:37.320 --> 00:53:39.760
So you wanna talk about some of these code tricks


00:53:39.760 --> 00:53:40.720
that you have here?


00:53:40.720 --> 00:53:43.960
- Yeah.


00:53:43.960 --> 00:53:45.160
- Or tools, I guess is a better word.


00:53:45.160 --> 00:53:46.000
- Set eagle.


00:53:46.000 --> 00:53:49.480
Sorry.


00:53:49.480 --> 00:53:52.600
- I just, maybe not tricks, tools or something.


00:53:52.600 --> 00:53:53.880
Things you can use to control it.


00:53:53.880 --> 00:53:54.720
- Right.


00:53:54.720 --> 00:53:58.280
Yeah, set Angular imports just for opting out


00:53:58.280 --> 00:53:59.720
certain modules.


00:53:59.720 --> 00:54:03.400
I mean, application owners should be the ones


00:54:03.400 --> 00:54:07.520
adding their own compatible libraries here.


00:54:07.520 --> 00:54:10.200
If they find or figure out that they are playing well


00:54:10.200 --> 00:54:11.920
with lazy imports.


00:54:11.920 --> 00:54:14.360
Sometimes you've seen that many, many--


00:54:14.360 --> 00:54:18.280
- So if I'm a library, yeah, so if I write a library


00:54:18.280 --> 00:54:22.280
and I see that my sub module cannot deal with being lazy,


00:54:22.280 --> 00:54:26.520
I could put this in my code to avoid,


00:54:26.520 --> 00:54:28.500
no matter what people set for the runtime flag,


00:54:28.500 --> 00:54:31.560
I could avoid that problem for my library, right?


00:54:31.560 --> 00:54:33.700
- Yeah, exactly.


00:54:33.700 --> 00:54:36.020
So you can always try it first


00:54:36.020 --> 00:54:37.940
and if you are the application owner


00:54:37.940 --> 00:54:40.140
and you know exactly what you need


00:54:40.140 --> 00:54:43.140
to this application to work,


00:54:43.140 --> 00:54:45.300
you can try it in modules.


00:54:45.300 --> 00:54:48.220
A lot of libraries just work out of the box,


00:54:48.220 --> 00:54:50.620
so you don't need to do anything.


00:54:50.620 --> 00:54:53.160
there are some libraries that don't work.


00:54:53.160 --> 00:54:56.600
And if you can make those work in some other way,


00:54:56.600 --> 00:54:59.080
you can then have these as bigger imports


00:54:59.080 --> 00:55:03.580
and lose the benefits of placing imports in those libraries.


00:55:03.580 --> 00:55:05.840
- Yeah. - When it's needed.


00:55:05.840 --> 00:55:06.680
- Okay.


00:55:06.680 --> 00:55:09.920
Yeah, these are all,


00:55:09.920 --> 00:55:11.260
these are really interesting to see here.


00:55:11.260 --> 00:55:14.980
Like you can even pass a callback


00:55:14.980 --> 00:55:17.120
that will be handed a module name


00:55:17.120 --> 00:55:19.220
and it can decide.


00:55:19.220 --> 00:55:23.160
You could say, I don't wanna just say all the names


00:55:23.160 --> 00:55:24.820
that are of this sub module,


00:55:24.820 --> 00:55:27.260
but just anything that matches this pattern,


00:55:27.260 --> 00:55:30.640
let's just tell it we wanna eagerly import that.


00:55:30.640 --> 00:55:33.020
- Yeah, yeah, yeah.


00:55:33.020 --> 00:55:38.440
- Yeah, it looks nice, I like it.


00:55:38.440 --> 00:55:42.800
There's another question from the audience,


00:55:42.800 --> 00:55:44.040
back to a code question,


00:55:44.040 --> 00:55:47.780
an explicit opt-in as hybrid robotics also asks.


00:55:47.780 --> 00:55:50.980
I really like the idea of import lazy or lazy import library


00:55:50.980 --> 00:55:53.580
or something like that to be explicit about it.


00:55:53.580 --> 00:55:56.660
And you all actually specifically addressed


00:55:56.660 --> 00:56:00.420
whether or not there should be some syntax code


00:56:00.420 --> 00:56:04.620
that makes this happen instead of changing the default.


00:56:04.620 --> 00:56:06.880
What's the thoughts there?


00:56:11.520 --> 00:56:14.880
Yeah, I mean, I think I can speak to that a little bit.


00:56:14.880 --> 00:56:18.080
I mean, I think generally we're not opposed to the idea


00:56:18.080 --> 00:56:20.960
of syntax for lazy imports,


00:56:20.960 --> 00:56:25.960
but the kinds of like memory and startup time wins


00:56:25.960 --> 00:56:31.660
that we've seen really depend on very broad application


00:56:31.660 --> 00:56:35.160
of lazy imports with just very narrowly targeted opt-outs.


00:56:35.160 --> 00:56:37.800
That's what you need in order to really get to a situation


00:56:37.800 --> 00:56:40.020
where you're actually paying for what you use


00:56:40.020 --> 00:56:42.780
in a robust way where you're not in a situation


00:56:42.780 --> 00:56:45.140
where you just accidentally add one import in one place


00:56:45.140 --> 00:56:48.740
and all of a sudden all your games just disappear like that.


00:56:48.740 --> 00:56:50.580
If it's really across the code base,


00:56:50.580 --> 00:56:54.420
then it's very robust startup time and memory wins


00:56:54.420 --> 00:56:55.500
where you add one import


00:56:55.500 --> 00:56:56.940
and while you might pay for a little more,


00:56:56.940 --> 00:56:59.100
but you're not gonna suddenly start paying


00:56:59.100 --> 00:57:01.260
a hundred percent of the cost again.


00:57:01.260 --> 00:57:06.260
So it feels like adding new syntax is a much bigger hurdle


00:57:06.260 --> 00:57:08.600
in terms of the steering council


00:57:08.600 --> 00:57:11.800
and having to change the Python grammar and all that.


00:57:11.800 --> 00:57:15.880
And when the syntax, the per import syntax


00:57:15.880 --> 00:57:19.980
isn't really even useful in gaining the wins


00:57:19.980 --> 00:57:22.320
that are the primary motivation for the pep,


00:57:22.320 --> 00:57:23.920
then it doesn't feel like a good trade-off


00:57:23.920 --> 00:57:25.760
to add that to the pep.


00:57:25.760 --> 00:57:27.560
- Sure.


00:57:27.560 --> 00:57:29.640
I think I agree with that.


00:57:29.640 --> 00:57:30.840
That seems pretty reasonable to me.


00:57:30.840 --> 00:57:32.500
What about the reverse?


00:57:32.500 --> 00:57:35.180
What about if you, so instead of something,


00:57:37.280 --> 00:57:39.040
Instead of doing something like this,


00:57:39.040 --> 00:57:41.400
where you say, I'm gonna force these to be,


00:57:41.400 --> 00:57:45.660
I'm gonna like run some code to make these modules eager.


00:57:45.660 --> 00:57:47.120
What if as a library author,


00:57:47.120 --> 00:57:50.600
I could write eager import my thing,


00:57:50.600 --> 00:57:52.880
or something along those lines.


00:57:52.880 --> 00:57:56.960
Now, I really don't wanna see more syntax in Python.


00:57:56.960 --> 00:57:59.240
Like there was a huge battle over whether a colon


00:57:59.240 --> 00:58:00.640
goes by an equal sign.


00:58:00.640 --> 00:58:04.480
So I'm not necessarily suggesting we should do this.


00:58:04.480 --> 00:58:05.320
But--


00:58:05.320 --> 00:58:08.120
- I would say there's nothing necessarily wrong with that.


00:58:08.120 --> 00:58:11.200
It's more just that adding new syntax is a higher bar


00:58:11.200 --> 00:58:12.880
and maybe we should get some experience.


00:58:12.880 --> 00:58:15.000
When the same thing is easily possible


00:58:15.000 --> 00:58:17.640
with existing syntax, like a context manager,


00:58:17.640 --> 00:58:20.140
we may as well get some experience with the feature


00:58:20.140 --> 00:58:23.280
in a less invasive way before we go adding syntax.


00:58:23.280 --> 00:58:25.240
- Right, if you see so many people using it


00:58:25.240 --> 00:58:28.040
and benefiting from it, then you could consider it.


00:58:28.040 --> 00:58:31.320
I mean, one example of that is like 3.4 to 3.5


00:58:31.320 --> 00:58:33.240
when there was async IO introduced


00:58:33.240 --> 00:58:35.120
and then there was async and await introduced


00:58:35.120 --> 00:58:36.840
on top of that.


00:58:36.840 --> 00:58:39.480
- Right, even things like property, right?


00:58:39.480 --> 00:58:42.820
Like the property decorator was,


00:58:42.820 --> 00:58:46.880
you know, a feature that was available


00:58:46.880 --> 00:58:49.640
before the decorator syntax was added.


00:58:49.640 --> 00:58:54.200
So it's a tried and true, you know, strategy for Python.


00:58:54.200 --> 00:58:56.080
Let's get experience with the feature


00:58:56.080 --> 00:58:58.920
and then, you know, we can make adjustments


00:58:58.920 --> 00:59:02.480
to any syntax to make it prettier, you know, down the road.


00:59:03.800 --> 00:59:06.860
- Yeah, that's a good path.


00:59:06.860 --> 00:59:07.700
Awesome.


00:59:07.700 --> 00:59:11.380
All right, well, really, really good work on this, you guys.


00:59:11.380 --> 00:59:13.380
This is exciting.


00:59:13.380 --> 00:59:18.380
I would like to see the status change from draft to--


00:59:18.380 --> 00:59:21.540
- I guess I have to go do something after this chat.


00:59:21.540 --> 00:59:26.340
- Perhaps so, perhaps.


00:59:26.340 --> 00:59:27.660
Awesome.


00:59:27.660 --> 00:59:31.140
But now people know about the conversation


00:59:31.140 --> 00:59:33.380
much more broadly, and maybe we'll get some more,


00:59:33.380 --> 00:59:35.880
Even more comments on the discourse thread there.


00:59:35.880 --> 00:59:42.340
Cool, all right, well, let's maybe wrap that up


00:59:42.340 --> 00:59:43.820
because I think we're about out of time.


00:59:43.820 --> 00:59:45.540
But before I let you all out of here,


00:59:45.540 --> 00:59:47.940
I've got the two questions to quickly answer


00:59:47.940 --> 00:59:49.780
since there's three of you.


00:59:49.780 --> 00:59:51.060
Barry, if you're gonna write some code,


00:59:51.060 --> 00:59:52.900
what editor are you using these days?


00:59:52.900 --> 00:59:56.540
- It's always gonna be Emacs for me.


00:59:56.540 --> 00:59:59.420
I, you know, it's funny 'cause Brett, you know,


00:59:59.420 --> 01:00:02.300
Brett works at Microsoft and so, you know,


01:00:02.300 --> 01:00:03.140
LinkedIn and Microsoft.


01:00:03.140 --> 01:00:04.540
- He had something to do with some editor.


01:00:04.540 --> 01:00:05.380
I think people,


01:00:05.380 --> 01:00:07.500
a few people may have heard of or something.


01:00:07.500 --> 01:00:08.740
- Yeah, and I keep telling Brett,


01:00:08.740 --> 01:00:10.700
I wanna, I wanna, you know,


01:00:10.700 --> 01:00:11.780
if I was starting today,


01:00:11.780 --> 01:00:13.420
I would probably use VS code,


01:00:13.420 --> 01:00:17.720
but Emacs is just deeply in my bones.


01:00:17.720 --> 01:00:18.820
- Got it.


01:00:18.820 --> 01:00:19.820
Ermon, how about you?


01:00:19.820 --> 01:00:24.020
- I used to use Sublime Text,


01:00:24.020 --> 01:00:28.260
even though it didn't have autocomplete.


01:00:28.260 --> 01:00:39.620
So I added some autocomplete from working Komodo IDE editor, autocomplete to sublime text.


01:00:39.620 --> 01:00:45.540
But nowadays in meta I'm using VS code and also being when I'm in a terminal.


01:00:45.540 --> 01:00:50.820
>> Right on. Carl? >> Yeah, I used to be an Emacs user.


01:00:50.820 --> 01:00:55.460
I mentioned that's how Barry and I very first connected back at PyCon 2008.


01:00:56.420 --> 01:00:59.580
but I have switched to VS Code.


01:00:59.580 --> 01:01:01.740
There's a lot of integrations with VS Code


01:01:01.740 --> 01:01:04.740
in terms of meta infrastructure


01:01:04.740 --> 01:01:07.340
and maintaining all that stuff myself for Emacs


01:01:07.340 --> 01:01:09.900
just became more of a hassle than I wanted to pay.


01:01:09.900 --> 01:01:11.060
So I've switched to it.


01:01:11.060 --> 01:01:13.460
- Did what, two jobs and one was enough?


01:01:13.460 --> 01:01:14.300
- Right.


01:01:14.300 --> 01:01:16.260
- All right.


01:01:16.260 --> 01:01:18.360
And then notable PyPI package,


01:01:18.360 --> 01:01:20.020
something that you think is pretty cool,


01:01:20.020 --> 01:01:22.180
you just wanna give a shout out to, popular or not.


01:01:22.180 --> 01:01:24.140
Go in reverse order, Carl, how about you?


01:01:25.140 --> 01:01:26.740
- Well, I guess I'll give a shout out to something


01:01:26.740 --> 01:01:28.260
that I use in all of my projects,


01:01:28.260 --> 01:01:30.460
which is, I guess, depending on the project,


01:01:30.460 --> 01:01:32.180
either Pyre or mypy.


01:01:32.180 --> 01:01:35.740
I'm a big fan of type checking my Python code.


01:01:35.740 --> 01:01:38.220
- Yeah, fantastic.


01:01:38.220 --> 01:01:39.040
German?


01:01:39.040 --> 01:01:43.220
- Yeah, well, Pyre is pretty good.


01:01:43.220 --> 01:01:44.740
I like that one.


01:01:44.740 --> 01:01:49.740
MicroSort, which sorts your imports at the top of the file.


01:01:49.740 --> 01:01:51.300
It's also very useful.


01:01:51.300 --> 01:01:55.060
- Yeah, if there's an import syntax,


01:01:55.060 --> 01:01:56.600
that makes all the other ones lazy.


01:01:56.600 --> 01:01:58.500
All these tools are gonna have to learn about,


01:01:58.500 --> 01:02:00.740
well, this one doesn't go before the other,


01:02:00.740 --> 01:02:04.340
or you could give it something like AAAAA lazy.


01:02:04.340 --> 01:02:06.920
(all laughing)


01:02:06.920 --> 01:02:13.500
All right, Barry, how about you, notable package?


01:02:13.500 --> 01:02:18.900
- For me, it's a PDM, which is a package manager


01:02:18.900 --> 01:02:20.220
and sort of a build backend.


01:02:20.220 --> 01:02:22.900
I went through an exercise a couple of months ago


01:02:22.900 --> 01:02:25.740
where I just was finally wanting to get rid


01:02:25.740 --> 01:02:28.180
of all my setup.pys and setup.cfgs


01:02:28.180 --> 01:02:31.140
and just fully embrace pyproject.toml


01:02:31.140 --> 01:02:32.300
and see how far it could go.


01:02:32.300 --> 01:02:36.380
And I was actually pretty happy


01:02:36.380 --> 01:02:38.340
with being able to get rid of both


01:02:38.340 --> 01:02:43.340
of those legacy packaging files.


01:02:43.340 --> 01:02:46.340
So I tried a bunch of the different package managers


01:02:46.340 --> 01:02:47.720
and I really liked PDM.


01:02:47.720 --> 01:02:52.180
So I kind of settled on that one for my personal stuff.


01:02:52.180 --> 01:02:54.020
- Yeah, fantastic.


01:02:54.020 --> 01:02:56.020
All right, well, final call to action.


01:02:56.020 --> 01:02:58.940
People want to maybe have their thoughts heard on this.


01:02:58.940 --> 01:02:59.780
What do they do?


01:02:59.780 --> 01:03:04.180
- I guess the discourse thread.


01:03:04.180 --> 01:03:08.340
Discuss.python.org, look for the PEPs category


01:03:08.340 --> 01:03:10.140
and look for PEP 690.


01:03:10.140 --> 01:03:11.180
- Yeah.


01:03:11.180 --> 01:03:12.340
- Yeah, cool.


01:03:12.340 --> 01:03:17.340
And you can love it or not love it or stuff like that.


01:03:17.340 --> 01:03:21.580
There's sort of ways to give just a heart feedback as well.


01:03:21.580 --> 01:03:23.180
So cool.


01:03:23.180 --> 01:03:24.900
>>The other thing you can do is pressure


01:03:24.900 --> 01:03:27.540
the sponsor of the pep to stop being so lazy.


01:03:27.540 --> 01:03:33.220
>>I would find it incorrect if you were not


01:03:33.220 --> 01:03:34.620
lazy on this particular one.


01:03:34.620 --> 01:03:39.220
I mean, you've got to just swim in that waterfall


01:03:39.220 --> 01:03:41.340
and see how it feels before you can really


01:03:41.340 --> 01:03:42.380
make a decision on that.


01:03:42.380 --> 01:03:44.860
>>Right, right, right, right, right.


01:03:44.860 --> 01:03:45.380
>>Awesome.


01:03:45.380 --> 01:03:47.820
All right, well, gentlemen, thank you for being here.


01:03:47.820 --> 01:03:50.060
It's been great having you all on the show.


01:03:50.060 --> 01:03:50.780
>>Thanks, Michael.


01:03:50.780 --> 01:03:52.100
- Thanks so much, Michael.


01:03:52.100 --> 01:03:53.300
Thanks for inviting us.


01:03:53.300 --> 01:03:54.140
Appreciate it.


01:03:54.140 --> 01:03:54.960
- Yeah, you bet.


01:03:54.960 --> 01:03:55.800
Bye.


01:03:55.800 --> 01:03:56.300
Bye.


01:03:56.300 --> 01:04:06.300
[BLANK_AUDIO]

