WEBVTT

00:00:00.000 --> 00:00:02.000
- Yeah, I'm excited to be here.


00:00:02.000 --> 00:00:04.000
- Yeah, it's great to have you here.


00:00:04.000 --> 00:00:06.240
Oh, we get to talk about one of my favorite topics,


00:00:06.240 --> 00:00:08.240
MongoDB, I'm so excited.


00:00:08.240 --> 00:00:12.160
- Yeah, my favorite topic, obviously too.


00:00:12.160 --> 00:00:14.760
- Yeah, you definitely put a lot of time into it.


00:00:14.760 --> 00:00:17.000
We're gonna talk about your ODM.


00:00:17.000 --> 00:00:20.440
People often hear about ORMs, Object Relational Mappers,


00:00:20.440 --> 00:00:24.800
but traditionally, MongoDB and other document databases


00:00:24.800 --> 00:00:26.000
and those who can't read,


00:00:26.000 --> 00:00:27.240
and those who can't type,


00:00:27.240 --> 00:00:30.800
and other document databases and NoSQL databases


00:00:30.800 --> 00:00:33.080
haven't modeled things to relationships,


00:00:33.080 --> 00:00:34.840
it's more through documents.


00:00:34.840 --> 00:00:38.320
So the D instead of R, ODM, Beanie,


00:00:38.320 --> 00:00:39.760
which is gonna be super fun,


00:00:39.760 --> 00:00:42.440
it brings together so many cool topics


00:00:42.440 --> 00:00:43.560
and even relationships.


00:00:43.560 --> 00:00:44.640
So maybe if you really wanted,


00:00:44.640 --> 00:00:48.680
I guess you could put the R back in there as of recently.


00:00:48.680 --> 00:00:51.760
Anyway, super fun topic on deck for us.


00:00:51.760 --> 00:00:53.920
Before we get to that, let's just start with your story.


00:00:53.920 --> 00:00:55.920
How'd you get into programming in Python?


00:00:55.920 --> 00:00:59.920
- I started when I was a student,


00:00:59.920 --> 00:01:03.160
like more than 10 years ago now.


00:01:03.160 --> 00:01:04.920
So, but I started not with Python.


00:01:04.920 --> 00:01:09.800
I started, it was 2008, I think, 2007 probably.


00:01:09.800 --> 00:01:12.560
I started with Flash and nobody knew


00:01:12.560 --> 00:01:14.800
that Flash will die soon.


00:01:14.800 --> 00:01:17.000
- Flash was such a big thing when it was new.


00:01:17.000 --> 00:01:20.200
I remember people were just completely


00:01:20.200 --> 00:01:22.160
getting amazing consulting jobs


00:01:22.160 --> 00:01:23.640
and building websites with Flash.


00:01:23.640 --> 00:01:24.480
I'm like, what is this?


00:01:24.480 --> 00:01:26.160
I'm not sure I want to learn this, but...


00:01:26.160 --> 00:01:27.000
- Do I have to learn this?


00:01:27.000 --> 00:01:27.840
I hope not.


00:01:27.840 --> 00:01:29.680
- But yeah, anyway, yeah.


00:01:29.680 --> 00:01:32.120
It did kind of get killed by HTML5.


00:01:32.120 --> 00:01:33.400
And you know, I think honestly,


00:01:33.400 --> 00:01:35.760
maybe it got killed by Steve Jobs, really.


00:01:35.760 --> 00:01:37.520
At least earlier than it would have been.


00:01:37.520 --> 00:01:38.360
- Yeah.


00:01:38.360 --> 00:01:41.320
So, but that time I didn't know that


00:01:41.320 --> 00:01:46.320
and ActionScript two and three were my tools.


00:01:46.320 --> 00:01:50.000
And then I decided to move to backend problems.


00:01:50.000 --> 00:01:52.240
So Flash is a client technology.


00:01:52.240 --> 00:01:54.120
If somebody don't know.


00:01:54.120 --> 00:02:00.920
So, and then I moved to... I just wanted to build websites and wanted to move to backend.


00:02:00.920 --> 00:02:08.920
And I chose Django. Not Python, but Django. Because Django was super fancy at that time.


00:02:08.920 --> 00:02:13.800
And now also, but at that time, yes. And I was a Django developer, not Python developer, but Django


00:02:13.800 --> 00:02:18.280
developer for a year probably. Because, you know, I knew a few tricks and tips about Django tools.


00:02:19.080 --> 00:02:22.000
models for use and et cetera to Python.


00:02:22.000 --> 00:02:24.880
And then somehow I learned Python also


00:02:24.880 --> 00:02:27.880
and now I'm more or less good Python developer.


00:02:27.880 --> 00:02:29.640
- Yeah, fantastic.


00:02:29.640 --> 00:02:32.280
I think I just realized as you were speaking,


00:02:32.280 --> 00:02:36.160
we might have to tell people what Flash is.


00:02:36.160 --> 00:02:37.760
I feel like it's just one of these,


00:02:37.760 --> 00:02:40.040
you know, iconic things out of the tech industry,


00:02:40.040 --> 00:02:42.640
but it might be like talking about Alta Vista.


00:02:42.640 --> 00:02:45.840
At some point, the kids, they won't know what Flash is.


00:02:45.840 --> 00:02:47.960
They won't know there was this battle


00:02:47.960 --> 00:02:50.880
about getting this thing on people's computer


00:02:50.880 --> 00:02:53.380
and it was always like viruses that are being found in it,


00:02:53.380 --> 00:02:54.980
but it could always do this magical stuff.


00:02:54.980 --> 00:02:56.560
How interesting.


00:02:56.560 --> 00:02:58.080
- Yeah, yeah.


00:02:58.080 --> 00:02:58.920
How old we are.


00:02:58.920 --> 00:03:00.760
- Exactly.


00:03:00.760 --> 00:03:02.280
The other thing that is interesting


00:03:02.280 --> 00:03:05.200
is you said you chose Django,


00:03:05.200 --> 00:03:08.080
you didn't choose Python, which...


00:03:08.080 --> 00:03:09.160
- Yeah.


00:03:09.160 --> 00:03:11.560
- Yeah, I think that that's...


00:03:11.560 --> 00:03:13.360
Now people are often choosing Python


00:03:13.360 --> 00:03:16.280
because of the data science and computational story,


00:03:16.280 --> 00:03:20.240
But before 2012, there was not this massive influx


00:03:20.240 --> 00:03:21.120
of data science people.


00:03:21.120 --> 00:03:23.300
And I think that the big influx


00:03:23.300 --> 00:03:25.560
was people becoming Django developers.


00:03:25.560 --> 00:03:28.400
And like, well, I guess I'll learn Python.


00:03:28.400 --> 00:03:30.840
Kind of like people becoming Ruby on Rails developers.


00:03:30.840 --> 00:03:31.720
They're like, I don't know Ruby,


00:03:31.720 --> 00:03:32.960
but I want to do Ruby on Rails.


00:03:32.960 --> 00:03:34.120
So I guess I got to learn Ruby.


00:03:34.120 --> 00:03:37.040
And Django is kind of our version of that, right?


00:03:37.040 --> 00:03:37.880
- Right, yeah.


00:03:37.880 --> 00:03:42.800
Then I think Flask appeared after a few years


00:03:42.800 --> 00:03:45.540
and everyone started to do microservices with Flask.


00:03:45.540 --> 00:03:48.340
and after that, the game started.


00:03:48.340 --> 00:03:49.540
(laughing)


00:03:49.540 --> 00:03:50.820
- That's right.


00:03:50.820 --> 00:03:52.100
That's right, oh my goodness.


00:03:52.100 --> 00:03:53.140
Out in the live stream,


00:03:53.140 --> 00:03:56.980
we're getting some high fives from Pradvan on Django


00:03:56.980 --> 00:04:00.940
and JF says, he says Django the right way, fantastic.


00:04:00.940 --> 00:04:03.180
So awesome.


00:04:03.180 --> 00:04:06.620
Yeah, and I think Django has been massively important


00:04:06.620 --> 00:04:09.300
for Python and very, very cool.


00:04:09.300 --> 00:04:10.140
- Yeah.


00:04:10.140 --> 00:04:13.140
- How about now, what are you doing day to day?


00:04:13.140 --> 00:04:17.940
So I'm principal Python developer now and this is interesting.


00:04:17.940 --> 00:04:24.580
Actually I changed my job three months ago and I didn't look for a new job.


00:04:24.580 --> 00:04:31.780
But one day Mahmood, my current manager, just texted me into Twitter that,


00:04:31.780 --> 00:04:38.820
"Hey, I saw your library, Bini, and it's interesting and we need something like this in our project


00:04:38.820 --> 00:04:41.540
and probably would like to participate in and, you know,


00:04:41.540 --> 00:04:47.060
integrate Bini into our project and develop Bini at the work time.


00:04:47.060 --> 00:04:47.700
Oh, cool.


00:04:47.700 --> 00:04:48.900
And I decided, yeah.


00:04:48.900 --> 00:04:51.380
Yeah, that's amazing.


00:04:51.380 --> 00:04:57.620
I mean, on one hand, it would just be cool to have a fun job doing cool MongoDB stuff, right?


00:04:57.620 --> 00:05:02.100
On the other, it's like, oh my gosh, I get to use my library and build up my library


00:05:02.100 --> 00:05:04.420
in a real production environment.


00:05:04.420 --> 00:05:05.460
Like, that's awesome, right?


00:05:05.460 --> 00:05:06.580
Yeah, yeah.


00:05:06.580 --> 00:05:11.580
And so I decided the same day, I think.


00:05:11.580 --> 00:05:14.420
- Let me think about it.


00:05:14.420 --> 00:05:15.260
Yes, okay.


00:05:15.260 --> 00:05:16.080
(laughing)


00:05:16.080 --> 00:05:17.460
I'm trying to figure out how long it takes me


00:05:17.460 --> 00:05:19.140
to quit my current job.


00:05:19.140 --> 00:05:20.420
Awesome, well, congratulations.


00:05:20.420 --> 00:05:21.420
That's really cool.


00:05:21.420 --> 00:05:24.260
So that only means good things for Beanie, right?


00:05:24.260 --> 00:05:27.460
It only means more time and energy on it, I would suspect.


00:05:27.460 --> 00:05:29.420
- Yeah, all this, the current release,


00:05:29.420 --> 00:05:33.780
the huge release is possible only because I can work


00:05:33.780 --> 00:05:35.500
a little bit time on work time,


00:05:35.500 --> 00:05:36.900
not only on weekends.


00:05:36.900 --> 00:05:38.660
- Yeah, absolutely.


00:05:38.660 --> 00:05:40.540
Yeah, it's easy to justify,


00:05:40.540 --> 00:05:43.860
like the library needs this feature to work right for us.


00:05:43.860 --> 00:05:45.900
So let me add that feature to the library


00:05:45.900 --> 00:05:48.300
as just part of the sprint or whatever, right?


00:05:48.300 --> 00:05:50.900
- And also probably it's even more important set


00:05:50.900 --> 00:05:53.660
when I can work on production with Binny,


00:05:53.660 --> 00:05:57.380
I can also see what does it need,


00:05:57.380 --> 00:06:01.140
like which feature and which movement.


00:06:01.140 --> 00:06:02.260
- It's so true because


00:06:03.680 --> 00:06:05.960
there's just these little edge cases.


00:06:05.960 --> 00:06:10.060
They don't show up under even a complicated


00:06:10.060 --> 00:06:11.920
little example you build for yourself.


00:06:11.920 --> 00:06:14.780
You know, you've got to put it into production


00:06:14.780 --> 00:06:15.800
and live with it.


00:06:15.800 --> 00:06:17.920
You know, some of that stuff might be migrations, right?


00:06:17.920 --> 00:06:19.480
Like, I never need these migrations.


00:06:19.480 --> 00:06:22.680
Oh, wait, we have the zero downtime promise.


00:06:22.680 --> 00:06:25.280
We kind of need migrations now or something, right?


00:06:25.280 --> 00:06:26.120
- Yeah, right.


00:06:26.120 --> 00:06:27.160
Totally correct.


00:06:27.160 --> 00:06:28.860
- Yeah, yeah, cool.


00:06:28.860 --> 00:06:29.700
Well, that's great to hear.


00:06:29.700 --> 00:06:30.960
Congratulations.


00:06:30.960 --> 00:06:33.280
Now, I wanted to start our chat off


00:06:33.280 --> 00:06:36.000
not talking about Beanie precisely,


00:06:36.000 --> 00:06:39.240
but like a little lower in the tech stack here.


00:06:39.240 --> 00:06:44.000
Let's just talk about MongoDB for a little bit.


00:06:44.000 --> 00:06:46.360
I'm a huge fan of MongoDB,


00:06:46.360 --> 00:06:49.620
as I'm sure many of the listeners know out there.


00:06:49.620 --> 00:06:52.080
I've been running Talk Python,


00:06:52.080 --> 00:06:54.600
Talk Python Training those things on top of MongoDB


00:06:54.600 --> 00:06:57.300
for quite some time.


00:06:57.300 --> 00:07:00.080
In the very, very early days,


00:07:00.080 --> 00:07:02.160
some of that was SQL alchemy stuff,


00:07:02.160 --> 00:07:05.400
but then I switched over to Mongo and whatnot.


00:07:05.400 --> 00:07:07.580
So I'm a huge fan of it.


00:07:07.580 --> 00:07:10.980
I definitely think there's a lot of value in it.


00:07:10.980 --> 00:07:15.960
There's a lot of these architectures where people talk


00:07:15.960 --> 00:07:18.320
about, oh, we have a Redis middle tier cache


00:07:18.320 --> 00:07:20.720
because we got to have our website fast.


00:07:20.720 --> 00:07:21.760
You know what?


00:07:21.760 --> 00:07:24.960
We get 10 millisecond response time and there's no cache.


00:07:24.960 --> 00:07:27.640
It's just talking to the database 'cause, you know,


00:07:27.640 --> 00:07:29.080
everything is structured the right way.


00:07:29.080 --> 00:07:31.520
I think it's, anyway, I'm kind of going on too much,


00:07:31.520 --> 00:07:34.920
But what I wanted to start with was,


00:07:34.920 --> 00:07:36.760
I wanna hear your thoughts on just sort of


00:07:36.760 --> 00:07:38.640
why build on top of Mongo?


00:07:38.640 --> 00:07:41.440
You know, so many people in the Python space


00:07:41.440 --> 00:07:43.360
build on Postgres, which is fine.


00:07:43.360 --> 00:07:44.540
It's a good database and all,


00:07:44.540 --> 00:07:46.680
it's just a completely different modeling story.


00:07:46.680 --> 00:07:49.960
So why are you interested in Mongo?


00:07:49.960 --> 00:07:56.040
- So, first of all, Mongo is super flexible


00:07:56.040 --> 00:07:57.680
database by design.


00:07:57.680 --> 00:08:01.080
And I really like to do prototypes.


00:08:01.080 --> 00:08:08.840
So when I just come up with new idea of new project,


00:08:08.840 --> 00:08:11.200
home project and et cetera,


00:08:11.200 --> 00:08:14.160
it's quite simple to work with MongoDB


00:08:14.160 --> 00:08:17.680
instead of Postgres when you have to change


00:08:17.680 --> 00:08:20.280
painfully schema of your data.


00:08:20.280 --> 00:08:23.680
But with Mongo, you can just do what you want to.


00:08:23.680 --> 00:08:26.160
- That's been my experience as well


00:08:26.160 --> 00:08:29.720
that I remember almost every release of my code


00:08:29.720 --> 00:08:32.500
would involve some migration on the SQLAlchemy version.


00:08:32.500 --> 00:08:35.160
And I think I've done one,


00:08:35.160 --> 00:08:36.920
what you would consider a migration


00:08:36.920 --> 00:08:38.720
in like five years on MongoDB.


00:08:38.720 --> 00:08:39.680
Whereas everything else is like,


00:08:39.680 --> 00:08:43.380
I'm gonna add this equivalent of a table,


00:08:43.380 --> 00:08:45.680
or I'm gonna add a field to this document,


00:08:45.680 --> 00:08:49.360
but it just goes in and it adapts.


00:08:49.360 --> 00:08:50.280
It's fantastic.


00:08:50.280 --> 00:08:53.440
It's like plastic instead of something brittle.


00:08:54.400 --> 00:08:56.320
- Ah, in the indexes.


00:08:56.320 --> 00:08:58.940
- Yeah, yeah, absolutely.


00:08:58.940 --> 00:09:03.780
- So yeah, that's why it's great for me, I think, yeah.


00:09:03.780 --> 00:09:05.400
- Yeah, it's really easy for prototyping, right?


00:09:05.400 --> 00:09:08.720
You just, instead of trying to keep the database in sync


00:09:08.720 --> 00:09:12.800
or whatever, you just work on your models and magic happens.


00:09:12.800 --> 00:09:14.000
- Yeah, yeah, you're right.


00:09:14.000 --> 00:09:16.500
And then, for sure, for production,


00:09:16.500 --> 00:09:20.040
you have to understand your,


00:09:20.040 --> 00:09:24.240
so profiling your needs


00:09:24.240 --> 00:09:26.460
and then you can move to Postgres


00:09:26.460 --> 00:09:28.160
or you can move to something like


00:09:28.160 --> 00:09:32.800
timestamp database like Clickhouse, for example, yeah.


00:09:32.800 --> 00:09:35.020
But in most cases, Mongo is enough.


00:09:35.020 --> 00:09:38.120
And for some cases, Mongo is the best choice


00:09:38.120 --> 00:09:41.720
because of flexibility and because of many cool stuff


00:09:41.720 --> 00:09:44.000
like indexes and such.


00:09:44.000 --> 00:09:45.320
- Yeah, absolutely.


00:09:45.320 --> 00:09:50.940
I think indexes, I don't know,


00:09:50.940 --> 00:09:52.680
this is maybe getting ahead of ourselves,


00:09:52.680 --> 00:09:55.600
But I think indexes are just so underappreciated


00:09:55.600 --> 00:09:56.440
in databases.


00:09:56.440 --> 00:09:57.760
I mean, I know a lot of people out there


00:09:57.760 --> 00:10:01.680
make sure their queries have the right indexes


00:10:01.680 --> 00:10:04.940
and stuff in it, but there's also so many websites I visit


00:10:04.940 --> 00:10:06.840
that take three seconds to load a page.


00:10:06.840 --> 00:10:08.700
I'm like, there's no way there's an index on this query.


00:10:08.700 --> 00:10:11.000
There's just no way, I don't know what it's doing,


00:10:11.000 --> 00:10:14.880
but somebody has just not even thought about it.


00:10:14.880 --> 00:10:15.920
And if it was a weird little,


00:10:15.920 --> 00:10:18.280
oh, here's like the reporting page, fine.


00:10:18.280 --> 00:10:19.960
But it's like the homepage or something,


00:10:19.960 --> 00:10:20.800
you know what I mean?


00:10:20.800 --> 00:10:23.120
How are they not making this faster


00:10:23.120 --> 00:10:26.360
even in like a Postgres story, right?


00:10:26.360 --> 00:10:31.360
Like I feel like there's one thing to have a database


00:10:31.360 --> 00:10:32.600
that does something,


00:10:32.600 --> 00:10:35.120
there's another to like tune it to do the right thing


00:10:35.120 --> 00:10:38.440
regardless of whether it's relational or NoSQL.


00:10:38.440 --> 00:10:39.760
- Yeah, totally correct.


00:10:39.760 --> 00:10:41.720
- Yeah, you have a lot of experience with databases.


00:10:41.720 --> 00:10:43.500
I mean, you must have that feeling as well.


00:10:43.500 --> 00:10:45.960
You go to some website, you're like, what is it doing?


00:10:45.960 --> 00:10:47.100
Why is this thing spinning?


00:10:47.100 --> 00:10:48.960
What could it possibly be doing here?


00:10:50.160 --> 00:10:52.660
- Yeah, probably somebody is going to get data.


00:10:52.660 --> 00:10:55.920
- Exactly, I mean, you're thinking through the ideas,


00:10:55.920 --> 00:10:58.240
okay, is it just not have an index


00:10:58.240 --> 00:11:01.400
or is it an N plus one problem with some ORM


00:11:01.400 --> 00:11:03.400
or why am I waiting here?


00:11:03.400 --> 00:11:04.760
What mistake have they made?


00:11:04.760 --> 00:11:06.480
(both laughing)


00:11:06.480 --> 00:11:08.200
Fantastic, all right.


00:11:08.200 --> 00:11:12.120
So the next thing I wanna sort of touch on


00:11:12.120 --> 00:11:14.600
is this tweet from Scott Stoltzman


00:11:14.600 --> 00:11:15.540
sent this out yesterday.


00:11:15.540 --> 00:11:17.960
I don't think he knew that we were coming up


00:11:17.960 --> 00:11:20.960
with this conversation actually.


00:11:20.960 --> 00:11:23.440
So there was this programming humor joke.


00:11:23.440 --> 00:11:27.060
It says, it has like two,


00:11:27.060 --> 00:11:31.360
I guess one of them is like a kitchen.


00:11:31.360 --> 00:11:33.120
The other is an office, but it doesn't really matter.


00:11:33.120 --> 00:11:36.380
Like the kitchen is super organized and it says MySQL.


00:11:36.380 --> 00:11:39.240
Everything's little buckets and put away nice.


00:11:39.240 --> 00:11:42.640
And then there's a desk area that's just,


00:11:42.640 --> 00:11:44.880
it looks like a hoarder house or like a,


00:11:46.600 --> 00:11:48.920
earthquake hit and destroyed this area.


00:11:48.920 --> 00:11:50.280
And it says MongoDB.


00:11:50.280 --> 00:11:52.960
- And it's actually true.


00:11:52.960 --> 00:11:55.480
- It is, it can be true.


00:11:55.480 --> 00:11:57.640
And the reason I bring this up is Scott said,


00:11:57.640 --> 00:12:00.240
you know, I know a guy who made this course


00:12:00.240 --> 00:12:03.480
that saved me from this chaos with Mongo engine.


00:12:03.480 --> 00:12:04.960
Because it can happen with,


00:12:04.960 --> 00:12:08.280
it can happen in about 15 seconds without a strong plan.


00:12:08.280 --> 00:12:12.800
And so out of the box, the way MongoDB,


00:12:12.800 --> 00:12:16.800
the dev folks there suggest that you,


00:12:16.800 --> 00:12:19.720
or at least provide, let's put it that way,


00:12:19.720 --> 00:12:23.360
the tools they provide for you to work with MongoDB


00:12:23.360 --> 00:12:27.920
are dictionaries, like you can give us dictionaries


00:12:27.920 --> 00:12:30.120
and put them somewhere and then you get dictionaries back.


00:12:30.120 --> 00:12:34.120
In Python, dictionaries are just whatever, right?


00:12:34.120 --> 00:12:37.000
There's zero structure, there's zero discoverability,


00:12:37.000 --> 00:12:38.920
there's zero type safety, right?


00:12:38.920 --> 00:12:41.200
Sometimes it's a string that looks like a number,


00:12:41.200 --> 00:12:42.280
other times it's a number.


00:12:42.280 --> 00:12:44.580
good luck, those don't match in a query.


00:12:44.580 --> 00:12:46.160
You know, that gets horrible.


00:12:46.160 --> 00:12:50.160
And so for me, I feel like what you need to do


00:12:50.160 --> 00:12:51.700
when you're working with databases


00:12:51.700 --> 00:12:56.000
that have less structure in the thing itself,


00:12:56.000 --> 00:12:58.480
like this is MySQL, say Postgres.


00:12:58.480 --> 00:13:00.940
Like Postgres says, the table looks like this.


00:13:00.940 --> 00:13:04.480
This column is that size of a string.


00:13:04.480 --> 00:13:06.280
This is a number and that's it.


00:13:06.280 --> 00:13:09.760
You know, like the structure is in the database,


00:13:09.760 --> 00:13:12.680
where in these document databases,


00:13:12.680 --> 00:13:14.800
the structure is in the code.


00:13:14.800 --> 00:13:16.720
And so you should have some kind of code


00:13:16.720 --> 00:13:20.360
that helps you not end up in a situation like this, right?


00:13:20.360 --> 00:13:21.500
- Yeah, yeah.


00:13:21.500 --> 00:13:25.120
But so honestly, Postgres also came up


00:13:25.120 --> 00:13:27.360
with JSONB fields now.


00:13:27.360 --> 00:13:28.960
- Yeah, so they're kind of,


00:13:28.960 --> 00:13:30.640
maybe they fall into that bottom bucket,


00:13:30.640 --> 00:13:32.560
like in a small little area.


00:13:32.560 --> 00:13:36.300
- Yeah, but yeah, it's also one of the things why,


00:13:36.300 --> 00:13:37.140
- Yeah.


00:13:37.140 --> 00:13:47.180
Schemas about structure.


00:13:47.180 --> 00:13:53.360
- Yeah, and so the thing I think saves you from,


00:13:53.360 --> 00:13:55.620
Scott mentioned Mongoid, which is pretty good,


00:13:55.620 --> 00:13:57.180
but I think the thing that saves you from this


00:13:57.180 --> 00:14:00.620
are these ODMs, like you have a lot more structure


00:14:00.620 --> 00:14:05.000
in your classes and your Python layer, right?


00:14:05.000 --> 00:14:06.320
- Yeah, yeah, correct.


00:14:06.320 --> 00:14:11.320
And also, so yeah, Beanie is ODM based on Pydentik.


00:14:11.320 --> 00:14:14.960
Pydentik is a Python library.


00:14:14.960 --> 00:14:24.900
Validating stuff, so.


00:14:24.900 --> 00:14:29.240
- Yeah, let me read the little introduction bit here


00:14:29.240 --> 00:14:32.160
because I think there's so much in this first sentence.


00:14:32.160 --> 00:14:37.160
So Beanie is an asynchronous Python object document mapper,


00:14:37.160 --> 00:14:39.360
ODM, for MongoDB.


00:14:39.360 --> 00:14:44.360
So ODM we talked about, Mongo we talked about,


00:14:44.360 --> 00:14:49.400
asynchronous, and also I didn't finish the sentence,


00:14:49.400 --> 00:14:52.840
based on motor, which comes from MongoDB, and Pydantic.


00:14:52.840 --> 00:14:56.240
So it's also asynchronous, right?


00:14:56.240 --> 00:14:59.940
Which is pretty awesome, as in async and await.


00:14:59.940 --> 00:15:04.940
And so often the models that we build for the databases


00:15:04.940 --> 00:15:08.700
are their own special thing.


00:15:08.700 --> 00:15:10.420
Then you got to build maybe an API


00:15:10.420 --> 00:15:12.360
and you might use Pydantic or something like that.


00:15:12.360 --> 00:15:14.780
But Pydantic has been really coming on strong


00:15:14.780 --> 00:15:19.060
as a super cool way to build object trees


00:15:19.060 --> 00:15:21.860
and object graphs and stuff.


00:15:21.860 --> 00:15:24.860
And so Pydantic is a perfect thing to say,


00:15:24.860 --> 00:15:25.780
well, let's just use that.


00:15:25.780 --> 00:15:27.260
Everyone already knows how to use that.


00:15:27.260 --> 00:15:31.780
and things like APIs can already exchange those on the wire.


00:15:31.780 --> 00:15:34.480
- Yep.


00:15:34.480 --> 00:15:35.560
- Yeah.


00:15:35.560 --> 00:15:38.820
- So, and that's why I chose this.


00:15:38.820 --> 00:15:43.600
- Yeah, it's just such a neat combination


00:15:43.600 --> 00:15:47.280
of bringing the async and await stuff together


00:15:47.280 --> 00:15:49.760
along with Hidantic and saying,


00:15:49.760 --> 00:15:54.760
let's see if we can use those ideas for the ODM.


00:15:56.320 --> 00:15:57.340
So there's other ones, you know,


00:15:57.340 --> 00:15:58.920
Scott mentioned Mongo engine.


00:15:58.920 --> 00:16:00.480
That's actually what I'm using right now


00:16:00.480 --> 00:16:02.620
for my MongoDB stuff in Python.


00:16:02.620 --> 00:16:05.220
Mongo engine's pretty good.


00:16:05.220 --> 00:16:11.200
I feel like it's kind of wherever it's gonna be.


00:16:11.200 --> 00:16:13.480
There's not a ton of excitement


00:16:13.480 --> 00:16:16.240
in terms of like new features and pushing stuff forward.


00:16:16.240 --> 00:16:18.480
For example, there's, to my knowledge,


00:16:18.480 --> 00:16:21.280
there's no async and await stuff happening in there.


00:16:21.280 --> 00:16:22.120
- Yeah.


00:16:22.120 --> 00:16:25.080
- There's, I think it's synchronous.


00:16:25.080 --> 00:16:26.940
- Possibly there's something that's happened


00:16:26.940 --> 00:16:28.260
that's changed that, but the last time I looked,


00:16:28.260 --> 00:16:29.540
it was synchronous still.


00:16:29.540 --> 00:16:31.740
- Weeks ago it was synchronous, yeah.


00:16:31.740 --> 00:16:32.580
- Yeah, okay.


00:16:32.580 --> 00:16:34.540
That's much more recent than I've looked.


00:16:34.540 --> 00:16:37.580
And what are some of the other ones?


00:16:37.580 --> 00:16:40.340
I'm trying to think of some of the other


00:16:40.340 --> 00:16:43.060
MongoDB ODMs out there.


00:16:43.060 --> 00:16:45.020
- I know in another languages probably,


00:16:45.020 --> 00:16:48.060
like Mongoose in JavaScript.


00:16:48.060 --> 00:16:48.900
- Yep.


00:16:48.900 --> 00:16:51.860
Yeah.


00:16:51.860 --> 00:16:53.340
- Active record stuff for Ruby.


00:16:53.340 --> 00:16:58.340
- Yeah, yeah, so a lot of these systems


00:16:58.340 --> 00:17:02.520
were based on the Django ORM model.


00:17:02.520 --> 00:17:05.640
So for example, like Mongo engine is basically


00:17:05.640 --> 00:17:09.880
Django ORM but adapted for documents in Mongo, right?


00:17:09.880 --> 00:17:12.520
Like the terminology and everything is quite similar.


00:17:12.520 --> 00:17:17.240
Being based on Pydantic, yours is a little bit different.


00:17:17.240 --> 00:17:20.720
I feel like there's a lot of interesting things,


00:17:20.720 --> 00:17:22.360
choices you've made.


00:17:22.360 --> 00:17:25.860
One, to be based on Pydantic and how that works.


00:17:25.860 --> 00:17:29.100
But two, we'll get into the API and stuff,


00:17:29.100 --> 00:17:30.500
but when you look at the API,


00:17:30.500 --> 00:17:32.540
I feel like you've chosen to be very near


00:17:32.540 --> 00:17:36.260
MongoDB's native query syntax or query language.


00:17:36.260 --> 00:17:38.960
So for example, instead of doing a select,


00:17:38.960 --> 00:17:42.060
you would do like a find or find one,


00:17:42.060 --> 00:17:46.820
or the updates, and like a set operator


00:17:46.820 --> 00:17:47.920
is one of the things you can do,


00:17:47.920 --> 00:17:50.360
like a set a value on there.


00:17:51.740 --> 00:17:52.580
Was that conscious?


00:17:52.580 --> 00:17:54.300
Did it say, like, I'm going to try to be really close


00:17:54.300 --> 00:17:57.300
to MongoDB or what was the thinking there?


00:17:57.300 --> 00:18:02.300
- So, yeah, when I started to work on Binny,


00:18:02.300 --> 00:18:07.060
it was not Binny, it was just a side project.


00:18:07.060 --> 00:18:09.420
Because, so yeah, once the very beginning,


00:18:09.420 --> 00:18:11.660
I started to play with FastAPI.


00:18:11.660 --> 00:18:15.220
It was a very modern web framework at that time.


00:18:15.220 --> 00:18:18.220
Now it's still modern and great for a web framework.


00:18:18.220 --> 00:18:22.540
but at that time it was quite new, around a few years ago.


00:18:22.540 --> 00:18:24.020
And this is asynchronous also,


00:18:24.020 --> 00:18:26.980
and uses Pydantic under the hood.


00:18:26.980 --> 00:18:31.220
And there were no ODM, no async ODM


00:18:31.220 --> 00:18:34.300
for Python and MongoDB.


00:18:34.300 --> 00:18:35.140
- Yeah.


00:18:35.140 --> 00:18:36.060
- And I decided--


00:18:36.060 --> 00:18:38.300
- I had the same experience,


00:18:38.300 --> 00:18:41.340
like I wanted to use MongoDB with some fast API stuff.


00:18:41.340 --> 00:18:42.840
I'm like, there's not a great,


00:18:42.840 --> 00:18:45.700
great library that I can pick here,


00:18:45.700 --> 00:18:50.060
So I guess I'll just use SQLAlchemy or something, right?


00:18:50.060 --> 00:18:55.060
- And what I did, I just started with Spadantic


00:18:55.060 --> 00:19:00.940
and I've got a motor.


00:19:00.940 --> 00:19:06.900
It is a PyMongo.


00:19:06.900 --> 00:19:10.060
So yeah, this is an engine over PyMongo


00:19:10.060 --> 00:19:12.860
and it is a synchronous engine.


00:19:12.860 --> 00:19:14.580
- Yeah, let's talk about motor a little bit


00:19:14.580 --> 00:19:17.540
because I suspect that most people


00:19:17.540 --> 00:19:21.540
who work with MongoDB work with PyMongo, right?


00:19:21.540 --> 00:19:24.140
When I opened the conversation, I said,


00:19:24.140 --> 00:19:26.300
the tools they give you are just,


00:19:26.300 --> 00:19:27.820
here's a dictionary to put in,


00:19:27.820 --> 00:19:29.620
and then I get dictionaries back out.


00:19:29.620 --> 00:19:34.500
I was exactly thinking of the PyMongo library, right?


00:19:34.500 --> 00:19:36.340
And so what's this motor thing?


00:19:36.340 --> 00:19:38.620
This is also from MongoDB.


00:19:38.620 --> 00:19:40.340
- This is also from MongoDB, right?


00:19:40.340 --> 00:19:46.860
And it also reflects each method and function from PyMongo.


00:19:46.860 --> 00:19:51.780
But it converted, let's say, into a synchronous method


00:19:51.780 --> 00:19:55.140
and function.


00:19:55.140 --> 00:19:57.580
So it uses the same--


00:19:57.580 --> 00:20:04.740
mostly the same syntax as MongoDB itself and as PyMongo.


00:20:04.740 --> 00:20:06.300
So it's a lot like PyMongo.


00:20:06.300 --> 00:20:11.300
It says, "Motor supports nearly every method PyMongo does,


00:20:11.300 --> 00:20:16.300
"but motor methods that do network IO are co-routines."


00:20:16.300 --> 00:20:19.640
So, async and await type of things, right?


00:20:19.640 --> 00:20:21.320
And yeah, yeah.


00:20:21.320 --> 00:20:25.260
- So yeah, and what I did, I just combined together


00:20:25.260 --> 00:20:31.340
pedantic and motor without any query builder stuff


00:20:32.540 --> 00:20:35.940
and other ODM fancy stuff,


00:20:35.940 --> 00:20:38.460
just querying using dictionaries,


00:20:38.460 --> 00:20:40.580
the same dictionaries as motor do,


00:20:40.580 --> 00:20:46.580
and PyMongo for models and nothing more, small library.


00:20:46.580 --> 00:20:50.600
It wasn't Binny at that time, it was internal project,


00:20:50.600 --> 00:20:52.500
just to play with fast API.


00:20:52.500 --> 00:20:56.240
And then after a few months of working,


00:20:56.240 --> 00:21:00.600
I decided probably I can make it open source.


00:21:01.620 --> 00:21:03.460
came up with the name "Bini".


00:21:03.460 --> 00:21:09.060
So, and that's why, mostly that's why I'm following MongoDB naming,


00:21:09.060 --> 00:21:13.060
not select, not join, etc.


00:21:13.060 --> 00:21:18.660
Just find many, find one, update, etc.


00:21:18.660 --> 00:21:24.100
Because I'm using, I started to use directly


00:21:24.100 --> 00:21:27.620
motor functions inside of Bidentic stuff.


00:21:27.620 --> 00:21:35.620
And only after that, I just started to update Binny stuff with more fancy stuff.


00:21:35.620 --> 00:21:42.100
Mm-hmm. Yeah, so it was a pretty close match to like, how do I take Motor and just make it


00:21:42.100 --> 00:21:46.020
send and receive Pydantic instead of sending and receiving straight dictionaries, right?


00:21:46.020 --> 00:21:52.340
Yeah, yeah. So the first project was just a parser from Motor to Pydantic and back.


00:21:53.540 --> 00:21:55.220
Cool. Well, I think it's really neat.


00:21:55.220 --> 00:21:57.220
And I, you know, however you got there,


00:21:57.220 --> 00:21:59.920
I think it's really nice that you have the API that matches that


00:21:59.920 --> 00:22:03.580
because then I can go to the MongoDB documentation


00:22:03.580 --> 00:22:06.720
and where I can find some other example


00:22:06.720 --> 00:22:10.460
that somebody has on, well, here's how you do it with PyMongo.


00:22:10.460 --> 00:22:14.600
And you're like, well, that looks really close to the same thing over here.


00:22:14.600 --> 00:22:16.760
So we can talk about that.


00:22:16.760 --> 00:22:21.840
Now, I want to dig into some of the other features and stuff there.


00:22:21.840 --> 00:22:24.960
for example, data and schema migrations,


00:22:24.960 --> 00:22:27.160
and support and whatnot, that's pretty cool.


00:22:27.160 --> 00:22:31.600
But let's talk about modeling data here.


00:22:31.600 --> 00:22:36.600
That's the first letter in ODM, the object bit.


00:22:36.600 --> 00:22:40.000
So what does it look like?


00:22:40.000 --> 00:22:42.640
I know, well, maybe not everyone listening knows


00:22:42.640 --> 00:22:45.360
what it looks like to model something with Pydantic.


00:22:45.360 --> 00:22:47.600
So maybe you could give us a Pydantic example,


00:22:47.600 --> 00:22:49.240
and then we could talk about how to turn that


00:22:49.240 --> 00:22:51.760
into something that can be stored in MongoDB?


00:22:51.760 --> 00:22:57.040
- So yeah, Pydantic is base model.


00:22:57.040 --> 00:22:59.280
The main class of Pydantic is base model


00:22:59.280 --> 00:23:01.660
and you inherit everything from base model.


00:23:01.660 --> 00:23:06.660
And it's like, it's looks like data classes of Python,


00:23:06.660 --> 00:23:11.840
but it also supports validation and parsing.


00:23:11.840 --> 00:23:15.920
- And yeah, the conversions and stuff, it's really cool.


00:23:15.920 --> 00:23:19.000
That's one of the things I think Pydantic is so good about.


00:23:19.000 --> 00:23:21.760
If you look at their example,


00:23:21.760 --> 00:23:25.520
the way you define these classes is you have a class


00:23:25.520 --> 00:23:29.720
and you just as a sort of class level, not instance level,


00:23:29.720 --> 00:23:33.360
you'd say name colon or variable colon type,


00:23:33.360 --> 00:23:34.200
variable colon type.


00:23:34.200 --> 00:23:36.200
So in this example, you've got a category,


00:23:36.200 --> 00:23:40.320
say name colon str, description colon str.


00:23:40.320 --> 00:23:43.280
And then this just means this thing has two fields,


00:23:43.280 --> 00:23:44.520
they're both strings.


00:23:44.520 --> 00:23:47.040
But the Pydentic example on their website


00:23:47.040 --> 00:23:51.800
is got some kind of model where it's got multiple fields


00:23:51.800 --> 00:23:54.120
and one of them is a list of things


00:23:54.120 --> 00:23:55.480
that are supposed to be numbers.


00:23:55.480 --> 00:24:00.080
And if you pass it a data and that list happens to have


00:24:00.080 --> 00:24:02.200
a list of strings that can be parsed to numbers,


00:24:02.200 --> 00:24:04.700
it'll just convert it straight to numbers


00:24:04.700 --> 00:24:05.760
as part of loading it.


00:24:05.760 --> 00:24:07.720
It's really, really nice, right?


00:24:07.720 --> 00:24:09.740
- Yeah, yeah, this is a great feature.


00:24:09.740 --> 00:24:11.080
- Yeah, this exchange across,


00:24:11.080 --> 00:24:14.440
especially across either files or API boundaries, right?


00:24:14.440 --> 00:24:18.800
somebody writes some code and they send you some data.


00:24:18.800 --> 00:24:21.980
Well, if they didn't really use the native data type


00:24:21.980 --> 00:24:23.360
but it could be turned into it,


00:24:23.360 --> 00:24:25.360
then that's really nice.


00:24:25.360 --> 00:24:28.080
- You also can add your own parser,


00:24:28.080 --> 00:24:29.760
like your own validation step.


00:24:29.760 --> 00:24:34.600
And then it will convert with your rule,


00:24:34.600 --> 00:24:38.180
like from string to number, to date.


00:24:38.180 --> 00:24:43.920
So yeah, and the Beanie uses the same schema,


00:24:43.920 --> 00:24:46.520
the same, so document is a main class of Bini


00:24:46.520 --> 00:24:51.520
and it's inherited from Pydantic base model


00:24:51.520 --> 00:24:54.040
and it inherits all the methods,


00:24:54.040 --> 00:24:59.040
all the aspects of base model of Pydantic


00:24:59.040 --> 00:25:01.920
so it can use the same validation stuff,


00:25:01.920 --> 00:25:04.760
the same parsing stuff and et cetera.


00:25:04.760 --> 00:25:07.600
- Right, so whatever people know and think about Pydantic,


00:25:07.600 --> 00:25:10.520
that's what the modeling looks like here.


00:25:10.520 --> 00:25:15.340
I guess the one difference is when you talk about,


00:25:15.340 --> 00:25:18.900
when you model the top level documents


00:25:18.900 --> 00:25:22.100
that are going to be stored and queried in MongoDB,


00:25:22.100 --> 00:25:24.500
you don't derive from base model, right?


00:25:24.500 --> 00:25:26.300
Derive from something else?


00:25:26.300 --> 00:25:28.280
- Yeah, from document.


00:25:28.280 --> 00:25:30.340
- Right, and document, it comes from Beanie,


00:25:30.340 --> 00:25:31.960
but that document itself is,


00:25:31.960 --> 00:25:35.580
derives from base model ultimately, right?


00:25:35.580 --> 00:25:37.700
So even though you gotta do this


00:25:37.700 --> 00:25:39.540
little more specialized class,


00:25:39.540 --> 00:25:42.740
it's still a pedantic model in its behavior, right?


00:25:42.740 --> 00:25:43.740
- Yeah, yeah, correct.


00:25:43.740 --> 00:25:47.740
That's why you can use it as a response model,


00:25:47.740 --> 00:25:50.540
for example, in FastAPI, if you're familiar with,


00:25:50.540 --> 00:25:54.420
because it uses pedantic base models


00:25:54.420 --> 00:25:56.380
and sub models of base models.


00:25:56.380 --> 00:25:58.380
- Yeah, if people haven't seen that,


00:25:58.380 --> 00:26:02.140
let me, here's an example.


00:26:02.140 --> 00:26:04.260
One of the things you can do with FastAPI


00:26:04.260 --> 00:26:07.640
that's super, super neat is you can go and say,


00:26:07.640 --> 00:26:12.640
as part of returning, where is this here?


00:26:12.640 --> 00:26:18.680
As part of returning the values out of the API,


00:26:18.680 --> 00:26:20.440
one of the things you can do in the decorator


00:26:20.440 --> 00:26:22.920
is you can just say the response model


00:26:22.920 --> 00:26:24.720
is some Pydantic class.


00:26:24.720 --> 00:26:27.000
And if you just add that one line


00:26:27.000 --> 00:26:29.360
and that class happens to be a Pydantic model,


00:26:29.360 --> 00:26:33.600
you get all sorts of live documentation


00:26:33.600 --> 00:26:35.520
and API definition stuff.


00:26:35.520 --> 00:26:37.520
And there's even code that will consume that.


00:26:37.520 --> 00:26:41.840
So I built this little weather thing in fast API


00:26:41.840 --> 00:26:45.120
for one of my classes over at weather.talkpython.fm.


00:26:45.120 --> 00:26:46.900
And we just go to slash docs.


00:26:46.900 --> 00:26:51.460
It pulls up, oh, here's all the APIs you can call.


00:26:51.460 --> 00:26:53.560
And here's like the return value


00:26:53.560 --> 00:26:55.960
with exactly what the schema is.


00:26:55.960 --> 00:26:58.600
And all of that's just from that one line of code.


00:26:58.600 --> 00:27:00.040
So what you're saying is you could do that


00:27:00.040 --> 00:27:02.020
with these database models.


00:27:02.020 --> 00:27:03.760
You could just say, I'm gonna return this directly


00:27:03.760 --> 00:27:06.240
from my API back to you.


00:27:06.240 --> 00:27:10.740
If you just say response model equals your data entity model,


00:27:10.740 --> 00:27:13.240
you get all this for free, right?


00:27:13.240 --> 00:27:15.760
- Yeah, it's also validated based on this model.


00:27:15.760 --> 00:27:17.020
Like if you're, for example,


00:27:17.020 --> 00:27:21.660
using some external source of data and they changed schema


00:27:21.660 --> 00:27:24.520
and you received it and responded back.


00:27:24.520 --> 00:27:26.920
And if the format is not correct,


00:27:26.920 --> 00:27:28.320
it just will raise an error


00:27:28.320 --> 00:27:31.680
and you can gracefully handle this, yeah.


00:27:31.680 --> 00:27:32.520
- Nice.


00:27:32.520 --> 00:27:35.320
Yeah, the error that it returns is also meaningful.


00:27:35.320 --> 00:27:39.160
Like the third entry in this list cannot be parsed


00:27:39.160 --> 00:27:42.360
to an integer rather than 400 invalid data.


00:27:42.360 --> 00:27:43.200
Good luck.


00:27:43.200 --> 00:27:48.640
Okay, so we've modeled these objects in here.


00:27:48.640 --> 00:27:50.180
And I guess one more thing to throw in


00:27:50.180 --> 00:27:52.040
while we're talking about modeling.


00:27:52.040 --> 00:27:54.880
In your example, right at the bottom of the GitHub page,


00:27:54.880 --> 00:27:57.080
you have a category which has the name and description


00:27:57.080 --> 00:28:01.080
and you have a product that has its own name and description


00:28:01.080 --> 00:28:05.520
and then a price and the product has a category


00:28:05.520 --> 00:28:07.800
and here you just say colon category, right?


00:28:07.800 --> 00:28:10.920
And that would make, I guess would make this


00:28:10.920 --> 00:28:14.400
in this case an embedded document


00:28:14.400 --> 00:28:17.120
inside of the product document, right?


00:28:17.120 --> 00:28:18.240
- Yeah, totally correct.


00:28:18.240 --> 00:28:20.340
It will just create embedded document.


00:28:20.340 --> 00:28:25.380
- Yeah, so the way that you model,


00:28:25.380 --> 00:28:27.040
this is why Pydantic is a really good match


00:28:27.040 --> 00:28:30.240
'cause Pydantic allows you to compose these Pydantic models


00:28:30.240 --> 00:28:32.520
in this hierarchy you can have list


00:28:32.520 --> 00:28:35.320
of other Pydantic models within a Pydantic model,


00:28:35.320 --> 00:28:37.220
which is exactly the same modeling you get


00:28:37.220 --> 00:28:39.880
with document databases like Mongo, right?


00:28:39.880 --> 00:28:40.880
- Yeah, yeah.


00:28:40.880 --> 00:28:42.720
- So you don't have to do anything.


00:28:42.720 --> 00:28:45.400
It keeps modeling the things I wanted to model, cool.


00:28:45.400 --> 00:28:50.880
In other database systems like SQLAlchemy or something,


00:28:50.880 --> 00:28:55.840
you would be able to say this field is nullable


00:28:57.360 --> 00:29:01.400
or it's required or something like that.


00:29:01.400 --> 00:29:04.500
So how do you say that in this model?


00:29:04.500 --> 00:29:07.660
- If it's notable, yeah, I can just use Python,


00:29:07.660 --> 00:29:13.400
type in optional, it's not class, but optional,


00:29:13.400 --> 00:29:14.480
optional, (laughs)


00:29:14.480 --> 00:29:15.320
- Yeah.


00:29:15.320 --> 00:29:17.600
- And mark it as optional and--


00:29:17.600 --> 00:29:21.440
- Like optional bracket str versus just str, right?


00:29:21.440 --> 00:29:22.280
- Yeah.


00:29:22.280 --> 00:29:23.480
- And I guess for a default value,


00:29:23.480 --> 00:29:26.680
you just set it equal to its default value, right?


00:29:26.680 --> 00:29:31.100
- If it's, yeah, you're right, but if it's option,


00:29:31.100 --> 00:29:33.400
so it's explicitly marked here,


00:29:33.400 --> 00:29:36.640
but pedantic allows you to use optional


00:29:36.640 --> 00:29:39.740
without default value and default would be none in that case


00:29:39.740 --> 00:29:43.040
'cause pedantic is marked. - I'm thinking like a false


00:29:43.040 --> 00:29:45.800
or none or something like that.


00:29:45.800 --> 00:29:47.440
This case, you probably wouldn't make it optional,


00:29:47.440 --> 00:29:49.480
you would just give it a default value, right?


00:29:49.480 --> 00:29:51.600
- Yeah, correct.


00:29:51.600 --> 00:29:54.640
- Now, one of the things that I can do and say Mongo engine


00:29:55.740 --> 00:29:58.300
is I can say the default is a function


00:29:58.300 --> 00:30:03.020
because maybe this is incredibly common for in my world


00:30:03.020 --> 00:30:06.060
is I want to know when something was created.


00:30:06.060 --> 00:30:07.820
When did this user create an account?


00:30:07.820 --> 00:30:09.180
When was this purchase made?


00:30:09.180 --> 00:30:12.180
When did this person watch this video or whatever?


00:30:12.180 --> 00:30:14.700
And so almost all of my models have some kind


00:30:14.700 --> 00:30:16.620
of created date type of thing.


00:30:16.620 --> 00:30:20.780
And the default value is dateTime.dateTime.now


00:30:20.780 --> 00:30:22.660
without parentheses.


00:30:22.660 --> 00:30:24.620
Like I want you to call the now function


00:30:24.620 --> 00:30:26.120
when you do an insert.


00:30:26.120 --> 00:30:28.680
How would I model that in Beanie?


00:30:28.680 --> 00:30:32.180
- You can use, again, you can use pedantic stuff here.


00:30:32.180 --> 00:30:34.420
So I'm really like pedantic.


00:30:34.420 --> 00:30:36.220
They did half a fork.


00:30:36.220 --> 00:30:39.580
You can use fields class, equal fields.


00:30:39.580 --> 00:30:44.380
And inside of that, you can use default factory parameter


00:30:44.380 --> 00:30:48.200
where you can just provide function you want to.


00:30:48.200 --> 00:30:49.040
- Okay.


00:30:49.040 --> 00:30:50.800
- And so yeah. - Oh, that's right.


00:30:50.800 --> 00:30:52.340
So you can, instead of setting it,


00:30:52.340 --> 00:30:55.020
Like you could say it's a string, but its value is,


00:30:55.020 --> 00:30:58.260
what is it, you say field factory or something?


00:30:58.260 --> 00:30:59.700
You set it to be one of these things


00:30:59.700 --> 00:31:01.020
that Pydantic knows about?


00:31:01.020 --> 00:31:05.700
- Didn't get you, sorry.


00:31:05.700 --> 00:31:08.900
- Yeah, so what, so like,


00:31:08.900 --> 00:31:11.180
is that thing that I'm setting it to equal to,


00:31:11.180 --> 00:31:12.820
does that come out of Pydantic?


00:31:12.820 --> 00:31:14.380
Like that's not a Beanie thing?


00:31:14.380 --> 00:31:18.020
- This is Pydantic stuff, yeah.


00:31:18.020 --> 00:31:19.740
Default factory stuff.


00:31:19.740 --> 00:31:22.740
But there is interesting feature about this.


00:31:22.740 --> 00:31:30.180
I can show you in another code example here.


00:31:30.180 --> 00:31:36.520
For example, if you want to use not created at field,


00:31:36.520 --> 00:31:37.640
but updated at.


00:31:37.640 --> 00:31:42.040
So each time when you update, you want to update time.


00:31:42.040 --> 00:31:45.080
And for that case, default factory will not work


00:31:45.080 --> 00:31:45.920
because default factory--


00:31:45.920 --> 00:31:46.920
- Right, it's already got a value.


00:31:46.920 --> 00:31:48.840
Yeah, it's only on creating, yeah.


00:31:48.840 --> 00:31:56.280
Yeah, so, and BINI allows you to use event-based actions for this.


00:31:56.280 --> 00:32:00.120
And you can just create a method of the class.


00:32:00.120 --> 00:32:09.400
And they are marked it like run before event, before event decorator, yeah.


00:32:09.400 --> 00:32:10.760
Before event.


00:32:10.760 --> 00:32:18.200
And inside of this, you can just write your logic like self updated at field equals


00:32:18.200 --> 00:32:25.560
current time and it will work for events you will choose like insert replace and anything else.


00:32:25.560 --> 00:32:29.560
Yeah this is one of the new features we're going to talk about some of the new things but one of


00:32:29.560 --> 00:32:36.600
them are these these event actions so you can say before the insert event or before the save event


00:32:36.600 --> 00:32:43.080
happens or after the thing's been replaced or any of those types of things you can sort of put a


00:32:43.080 --> 00:32:45.320
or decorator and say run this function


00:32:45.320 --> 00:32:47.400
when that happens on this type


00:32:47.400 --> 00:32:50.160
or in this collection effectively, right?


00:32:50.160 --> 00:32:51.240
- Yep.


00:32:51.240 --> 00:32:52.080
- Very, very cool.


00:32:52.080 --> 00:32:54.600
All right, we're gonna dive back into that


00:32:54.600 --> 00:32:55.420
'cause that's good.


00:32:55.420 --> 00:32:57.160
And so that would be actually a pretty good way, wouldn't it?


00:32:57.160 --> 00:33:00.180
Just do an event on insert.


00:33:00.180 --> 00:33:01.480
And when an insert happens,


00:33:01.480 --> 00:33:03.800
set my created date to be datetime.now.


00:33:03.800 --> 00:33:06.840
- Yeah.


00:33:06.840 --> 00:33:08.600
- Okay, good, good.


00:33:08.600 --> 00:33:11.440
And then I guess the other part that's interesting now


00:33:11.440 --> 00:33:13.200
is doing queries and inserts on this.


00:33:13.200 --> 00:33:15.480
So you would create your objects


00:33:15.480 --> 00:33:18.320
just exactly the same as you would Pydantic, right?


00:33:18.320 --> 00:33:23.140
Just class name, key value, key value, key value, like that.


00:33:23.140 --> 00:33:31.160
- Yeah, or even parse object like category dot parse object


00:33:31.160 --> 00:33:33.040
and dictionary with values.


00:33:33.040 --> 00:33:35.400
And yeah, if you want to parse more.


00:33:35.400 --> 00:33:37.080
- Right, if it's coming, okay.


00:33:37.080 --> 00:33:39.280
Or if it's coming out of an API or something like that.


00:33:39.280 --> 00:33:40.120
Right.


00:33:40.120 --> 00:33:43.840
And then you would say, here's where it gets interesting,


00:33:43.840 --> 00:33:47.400
you say await object.insert,


00:33:47.400 --> 00:33:51.860
or await class.find1, right?


00:33:51.860 --> 00:33:55.240
Or await set some value there.


00:33:55.240 --> 00:33:56.840
- Yeah, yeah, yeah.


00:33:56.840 --> 00:33:59.360
Because this is a sync/await library,


00:33:59.360 --> 00:34:01.420
so that's why you have to use await here.


00:34:01.420 --> 00:34:05.480
Yeah.


00:34:05.480 --> 00:34:09.040
Based on the synchronous nature of the library.


00:34:09.040 --> 00:34:10.520
- Sure, and that's the whole point, right?


00:34:10.520 --> 00:34:13.520
Is that it's built around that.


00:34:13.520 --> 00:34:15.480
I think, I mean, there's ways in which you could use it


00:34:15.480 --> 00:34:17.720
in asynchronous situations, right?


00:34:17.720 --> 00:34:19.280
You could always create your own event loop


00:34:19.280 --> 00:34:22.520
and just run the function and just block right that way


00:34:22.520 --> 00:34:24.720
or use something like Unsync,


00:34:24.720 --> 00:34:26.920
which maybe we'll touch on a little bit later.


00:34:26.920 --> 00:34:31.440
But yeah, so, but if you're doing something like Flask


00:34:31.440 --> 00:34:36.480
or FastAPI, where the functions themselves,


00:34:36.480 --> 00:34:39.520
the thing being called by the framework


00:34:39.520 --> 00:34:41.160
is already handling it.


00:34:41.160 --> 00:34:42.620
It's basically no work, right?


00:34:42.620 --> 00:34:44.240
You just make an async method


00:34:44.240 --> 00:34:46.060
and then you just await things


00:34:46.060 --> 00:34:50.040
and you unlock this scalability right there.


00:34:50.040 --> 00:34:51.520
- Yeah, yeah.


00:34:51.520 --> 00:34:55.760
I think modern Python work is pretty everywhere


00:34:55.760 --> 00:34:57.520
asynchronous already.


00:34:57.520 --> 00:35:02.520
I don't know if I think framework development now,


00:35:02.520 --> 00:35:05.120
like most of them are already asynchronous.


00:35:05.120 --> 00:35:06.520
I mean, that's the worst. - Yeah, exactly.


00:35:06.520 --> 00:35:08.880
Yeah, I think with Flask,


00:35:08.880 --> 00:35:11.980
there's limited support for async.


00:35:11.980 --> 00:35:13.760
And then if you want full async,


00:35:13.760 --> 00:35:15.300
you have to use court for the moment,


00:35:15.300 --> 00:35:16.440
but maybe stuff's happening.


00:35:16.440 --> 00:35:20.400
I know Django is working on an async story as well.


00:35:20.400 --> 00:35:23.240
I think the big holdup for like full-on async in Django


00:35:23.240 --> 00:35:24.740
has actually been the Django ORM.


00:35:24.740 --> 00:35:28.160
So, you know, this would fix that.


00:35:28.160 --> 00:35:31.160
Although, does it make any sense to use Beanie


00:35:31.160 --> 00:35:35.440
or another ODM or something like that with Django?


00:35:35.440 --> 00:35:38.840
Or, I mean, it's so tied into its ORM itself, right?


00:35:38.840 --> 00:35:43.320
- I think for Django, it's a little bit tricky.


00:35:43.320 --> 00:35:44.920
Probably things changed,


00:35:44.920 --> 00:35:49.560
but Django works with relative databases here,


00:35:49.560 --> 00:35:50.840
with SQL databases,


00:35:50.840 --> 00:35:54.320
and also the Django model stuff


00:35:54.320 --> 00:35:57.320
picked to this kind of.


00:35:57.320 --> 00:35:59.640
So, and it will be, it's possible,


00:35:59.640 --> 00:36:01.080
- Yeah, it's just, you know,


00:36:01.080 --> 00:36:03.180
if you're fighting against the system,


00:36:03.180 --> 00:36:08.180
then you maybe should just choose a different framework


00:36:08.180 --> 00:36:10.320
rather than try to fight the way that it works, right?


00:36:10.320 --> 00:36:11.960
Like if you're gonna choose something like Django


00:36:11.960 --> 00:36:15.360
that gives you a lot of opinionated workflow,


00:36:15.360 --> 00:36:17.760
but a lot of benefit if you stay in that workflow,


00:36:17.760 --> 00:36:20.000
then just, you know, I'd say follow that.


00:36:20.000 --> 00:36:22.760
But the other frameworks are pretty wide open, right?


00:36:22.760 --> 00:36:25.240
You could easily use this with Flask.


00:36:25.240 --> 00:36:26.960
You could use this with, you know,


00:36:26.960 --> 00:36:32.240
easily use this with a flask, you could use this with pretty much anything.


00:36:32.240 --> 00:36:34.840
It's better if it supports async, right?


00:36:34.840 --> 00:36:36.520
There's not a synchronous version.


00:36:36.520 --> 00:36:37.740
Is there?


00:36:37.740 --> 00:36:43.560
Yeah, there is no synchronous version of this as it uses a motor inside this, as we said.


00:36:43.560 --> 00:36:49.760
I'm thinking about at, you know, by Mongo support without motor.


00:36:49.760 --> 00:36:52.920
And in that case, it would be just synchronous.


00:36:52.920 --> 00:36:54.480
I would think that would be great.


00:36:54.480 --> 00:36:55.040
Honestly.


00:36:55.040 --> 00:37:00.920
I'm very excited that this is async burst.


00:37:00.920 --> 00:37:02.400
I think that's really good.


00:37:02.400 --> 00:37:05.160
But let me give you an example.


00:37:05.160 --> 00:37:07.560
For my website, I would love to be able


00:37:07.560 --> 00:37:11.080
to make all the view methods be async.


00:37:11.080 --> 00:37:13.640
That would give it a little bit more scalability.


00:37:13.640 --> 00:37:15.240
It's pretty quick like I said,


00:37:15.240 --> 00:37:17.840
but it would still be way more scalable


00:37:17.840 --> 00:37:20.280
if it could do more while it's waiting on the server.


00:37:20.280 --> 00:37:21.840
But at the same time,


00:37:21.840 --> 00:37:24.680
I have all these little scripts that I run,


00:37:24.680 --> 00:37:28.560
and like here's how I want to go and just show me all the,


00:37:28.560 --> 00:37:34.400
you know, show me all of the podcast episodes that,


00:37:34.400 --> 00:37:36.760
and who is sponsoring them to make sure


00:37:36.760 --> 00:37:38.680
that if I had to reorder things,


00:37:38.680 --> 00:37:41.320
I don't mess up some sponsorship detail


00:37:41.320 --> 00:37:43.440
or show me all the people who have signed up


00:37:43.440 --> 00:37:47.560
for this class this month and whatnot.


00:37:47.560 --> 00:37:49.120
Those little scripts, right?


00:37:49.120 --> 00:37:50.600
It would be nice if I could just say


00:37:50.600 --> 00:37:52.360
these little things are going to be synchronous


00:37:52.360 --> 00:37:54.960
because it's the easier programming model.


00:37:54.960 --> 00:37:56.760
I don't have to deal with this loop stuff.


00:37:56.760 --> 00:38:00.280
But then keep the website using the same models


00:38:00.280 --> 00:38:02.880
in the async version.


00:38:02.880 --> 00:38:04.840
What do you think of that?


00:38:04.840 --> 00:38:06.720
- Yeah, yeah, I do agree totally.


00:38:06.720 --> 00:38:08.760
But I have limited time, that's why.


00:38:08.760 --> 00:38:10.600
(both laughing)


00:38:10.600 --> 00:38:12.080
- Yes, no, of course you do.


00:38:12.080 --> 00:38:15.020
And I guess that pull requests are accepted,


00:38:15.020 --> 00:38:17.520
or contributions are accepted


00:38:17.520 --> 00:38:20.120
if there's meaningful good work, right?


00:38:20.120 --> 00:38:21.580
- Yeah, sure, sure.


00:38:21.580 --> 00:38:23.380
- Yeah, cool.


00:38:23.380 --> 00:38:26.740
No, I'm not suggesting that it's like a super shortcoming,


00:38:26.740 --> 00:38:29.500
right, it's not that hard to create an async method


00:38:29.500 --> 00:38:31.380
and then just call async.io.run on it,


00:38:31.380 --> 00:38:34.580
but having this ability to say,


00:38:34.580 --> 00:38:37.180
this situation is really a synchronous one,


00:38:37.180 --> 00:38:41.460
don't need to go through the hoops to make that happen.


00:38:41.460 --> 00:38:44.540
- Even I had this situation in the past, you know,


00:38:44.540 --> 00:38:47.580
and I had to create a loop inside of synchronous function.


00:38:47.580 --> 00:38:49.260
(laughing)


00:38:49.260 --> 00:38:50.100
- Yeah, exactly.


00:38:50.100 --> 00:38:52.860
- And you know, I think that's worth touching on a little bit


00:38:52.860 --> 00:38:56.940
because people say that async and await is like,


00:38:56.940 --> 00:39:01.180
what's the, it's like a virus or something.


00:39:01.180 --> 00:39:03.940
Like once one part of your code base gets async,


00:39:03.940 --> 00:39:06.220
like it sort of expands upward


00:39:06.220 --> 00:39:09.060
so that anything that might touch that function


00:39:09.060 --> 00:39:10.380
itself has to become async


00:39:10.380 --> 00:39:13.220
and then its colors have to become async and so on.


00:39:13.220 --> 00:39:17.780
And I, you know, in the most naive, straightforward way,


00:39:17.780 --> 00:39:19.540
that's totally true.


00:39:19.540 --> 00:39:24.060
but it's not true if you don't want it to be.


00:39:24.060 --> 00:39:25.860
Right, like halfway through that function,


00:39:25.860 --> 00:39:27.920
that call stack, you could say on this part,


00:39:27.920 --> 00:39:29.960
I'm gonna create an async IO event loop


00:39:29.960 --> 00:39:32.200
and just run it and just block.


00:39:32.200 --> 00:39:33.700
Right, and anyone who calls that function


00:39:33.700 --> 00:39:36.040
doesn't have to know it's async IO, right?


00:39:36.040 --> 00:39:39.520
You can sort of stop that async propagation.


00:39:39.520 --> 00:39:40.960
And that sounds like that's what you're talking about,


00:39:40.960 --> 00:39:42.600
like creating a loop and running it


00:39:42.600 --> 00:39:44.480
inside of a synchronous function.


00:39:44.480 --> 00:39:47.280
- Yeah, but this looks really super ugly.


00:39:48.240 --> 00:39:51.760
- Yeah, you're like-- - You even don't have any


00:39:51.760 --> 00:39:54.320
chance to avoid this.


00:39:54.320 --> 00:39:56.960
Great task. (laughs)


00:39:56.960 --> 00:40:00.080
- Yeah, it is a little bit weird if you haven't seen it.


00:40:00.080 --> 00:40:03.400
Okay, so it's time for my requisite required shout out


00:40:03.400 --> 00:40:05.440
to the Unsync library,


00:40:05.440 --> 00:40:08.440
which I think is just so neat in the way


00:40:08.440 --> 00:40:11.760
that it simplifies async and await in Python.


00:40:11.760 --> 00:40:13.040
We were talking about this just a little bit


00:40:13.040 --> 00:40:14.560
before I hit record,


00:40:14.560 --> 00:40:19.560
but it has basically two things that are frustrations


00:40:19.560 --> 00:40:23.080
that make this kind of stuff we're talking about


00:40:23.080 --> 00:40:23.920
a little bit harder.


00:40:23.920 --> 00:40:26.360
Like one, wouldn't it be nice if you could just call


00:40:26.360 --> 00:40:28.480
an async function and it just runs?


00:40:28.480 --> 00:40:29.920
Like I wanna write this to the log,


00:40:29.920 --> 00:40:32.040
but let's do that asynchronously and just go,


00:40:32.040 --> 00:40:32.920
go right to the log.


00:40:32.920 --> 00:40:34.280
I don't wanna see from you again,


00:40:34.280 --> 00:40:36.840
I wanna hear from you again, just go put it in the log.


00:40:36.840 --> 00:40:37.960
I'm gonna keep on working, right?


00:40:37.960 --> 00:40:39.640
You can't do that with Python's async.


00:40:39.640 --> 00:40:40.960
You've gotta like put it in a loop


00:40:40.960 --> 00:40:43.400
and make sure the loop is running.


00:40:43.400 --> 00:40:45.360
to this fire and forget model doesn't work.


00:40:45.360 --> 00:40:47.600
And the other is you can't block,


00:40:47.600 --> 00:40:50.840
you can't call dot result to make it block.


00:40:50.840 --> 00:40:53.240
If it's not done, it's gonna throw an exception, right?


00:40:53.240 --> 00:40:56.920
So this unsync thing lets you put an @unsync decorator


00:40:56.920 --> 00:41:01.080
on an async method, and then if you need to stop


00:41:01.080 --> 00:41:03.360
the async propagation, you just call dot result


00:41:03.360 --> 00:41:05.480
and it'll block and then give you the answer


00:41:05.480 --> 00:41:06.640
till it's done.


00:41:06.640 --> 00:41:08.100
And there's all sorts of cool integration


00:41:08.100 --> 00:41:11.480
with like threads plus async IO plus multiprocessing.


00:41:11.480 --> 00:41:14.520
It's, I think this fixes a lot of those


00:41:14.520 --> 00:41:16.160
like little weird edge cases.


00:41:16.160 --> 00:41:20.480
- I think I will try this after this podcast


00:41:20.480 --> 00:41:23.400
and we'll create a page on the documentation.


00:41:23.400 --> 00:41:24.920
So if you need to find-


00:41:24.920 --> 00:41:26.560
- Yeah, try it out and see if it's a good idea.


00:41:26.560 --> 00:41:29.240
It might not be a good fit, but I think it is actually.


00:41:29.240 --> 00:41:30.680
I think it would be.


00:41:30.680 --> 00:41:31.500
- I will try.


00:41:31.500 --> 00:41:32.840
So if it will not work, I will not.


00:41:32.840 --> 00:41:34.160
(both laughing)


00:41:34.160 --> 00:41:36.240
- So basically the way it works is it create,


00:41:36.240 --> 00:41:39.080
when it starts up, it creates a background thread


00:41:39.080 --> 00:41:43.080
that its only job is to run an async IO event loop.


00:41:43.080 --> 00:41:44.640
And then when you do stuff,


00:41:44.640 --> 00:41:45.880
when you call functions on this,


00:41:45.880 --> 00:41:46.880
instead of running the main thread,


00:41:46.880 --> 00:41:48.440
it just runs on that background thread.


00:41:48.440 --> 00:41:50.440
When you block, it just waits for that background thread


00:41:50.440 --> 00:41:51.920
to finish its work and stuff like that.


00:41:51.920 --> 00:41:54.400
So that's sort of the trick around it.


00:41:54.400 --> 00:41:56.920
But super big fan of unsync.


00:41:56.920 --> 00:42:01.060
I think it does a lot of good for these situations


00:42:01.060 --> 00:42:02.000
that we're talking about where you're like,


00:42:02.000 --> 00:42:03.200
okay, almost all the time,


00:42:03.200 --> 00:42:05.520
and definitely in production, I want it async.


00:42:05.520 --> 00:42:08.360
But every now and then, I want it to just stop.


00:42:08.360 --> 00:42:09.660
You know what I mean?


00:42:09.660 --> 00:42:11.940
(laughing)


00:42:11.940 --> 00:42:14.440
So let's talk about some of the other features.


00:42:14.440 --> 00:42:17.100
Back to this example here,


00:42:17.100 --> 00:42:18.800
there's one thing I wanted to highlight


00:42:18.800 --> 00:42:21.280
that I think was really neat that I saw.


00:42:21.280 --> 00:42:24.000
So you've got the standard,


00:42:24.000 --> 00:42:26.940
I've created a object that goes in the database


00:42:26.940 --> 00:42:29.060
and I call insert and I await that.


00:42:29.060 --> 00:42:30.840
That puts it in the database, right?


00:42:30.840 --> 00:42:31.680
- Yeah.


00:42:31.680 --> 00:42:36.400
- So I don't see a return value here.


00:42:36.400 --> 00:42:39.240
Does that actually set the ID on this thing


00:42:39.240 --> 00:42:41.640
that's being inserted after that function call?


00:42:41.640 --> 00:42:43.240
- It updates.


00:42:43.240 --> 00:42:44.640
- Okay, perfect.


00:42:44.640 --> 00:42:48.080
Yeah, so .id is good to go after that, right?


00:42:48.080 --> 00:42:48.900
- Yeah.


00:42:48.900 --> 00:42:49.740
- Okay, cool.


00:42:49.740 --> 00:42:53.160
And then the other one, you've got your await find one.


00:42:53.160 --> 00:42:57.360
The filter syntax is the first thing I wanted to talk about,


00:42:57.360 --> 00:42:59.600
which I think is really nice.


00:42:59.600 --> 00:43:04.600
So even though these things are,


00:43:04.600 --> 00:43:09.200
These things are, does it have to be one of these


00:43:09.200 --> 00:43:12.840
indexed ones or can you do these queries of this style


00:43:12.840 --> 00:43:13.800
on any of these?


00:43:13.800 --> 00:43:17.760
Could I do a category or a description equals something


00:43:17.760 --> 00:43:19.760
or a name equals something?


00:43:19.760 --> 00:43:20.600
- Yeah, yeah, sure.


00:43:20.600 --> 00:43:24.120
You can do everything and you can do it even in the same,


00:43:24.120 --> 00:43:30.600
in the same line in find one, price less than 10,


00:43:30.600 --> 00:43:34.980
comma and name equals, I don't know, your name.


00:43:34.980 --> 00:43:35.820
- Yeah.


00:43:35.820 --> 00:43:36.780
- So it will work.


00:43:36.780 --> 00:43:38.340
- Nice.


00:43:38.340 --> 00:43:40.020
So the way that you would say,


00:43:40.020 --> 00:43:43.820
I wanna find the product or all the products


00:43:43.820 --> 00:43:46.220
that has a price less than 10,


00:43:46.220 --> 00:43:47.540
is you just say, in this case,


00:43:47.540 --> 00:43:49.140
the product is a class with a price field,


00:43:49.140 --> 00:43:52.380
just say product.price less than 10, right?


00:43:52.380 --> 00:43:53.780
Just like you would in if statement


00:43:53.780 --> 00:43:55.900
or while loop or something like that.


00:43:55.900 --> 00:43:57.180
- Yeah, yeah.


00:43:57.180 --> 00:43:58.660
- This is really nice because


00:43:59.900 --> 00:44:03.120
The alternative is something like what you have


00:44:03.120 --> 00:44:05.160
in Mongo engine, where what you would say


00:44:05.160 --> 00:44:10.160
is you would say price underscore underscore LT equals 10.


00:44:10.160 --> 00:44:15.280
Right, so you would say like separate the operators


00:44:15.280 --> 00:44:17.240
on the field with double underscores


00:44:17.240 --> 00:44:19.880
and so LT means less than and then you equal the value


00:44:19.880 --> 00:44:22.440
you want it to be less than and that is entirely


00:44:22.440 --> 00:44:26.040
not natural, it's not horrible, you can get used to it


00:44:26.040 --> 00:44:30.080
but it sure isn't the same as price less than 10, right?


00:44:30.080 --> 00:44:31.480
- Yeah. - That'd be really nice.


00:44:31.480 --> 00:44:33.600
- On the very beginning, when I told that


00:44:33.600 --> 00:44:35.720
I was Django developer, not Python developer,


00:44:35.720 --> 00:44:37.560
it was about this,


00:44:37.560 --> 00:44:41.320
because I knew how to do this stuff about Django,


00:44:41.320 --> 00:44:44.520
but it's not Python syntax, honestly,


00:44:44.520 --> 00:44:46.840
it's Django syntax, which moved to.


00:44:46.840 --> 00:44:50.400
- Exactly, so you can do these natural queries,


00:44:50.400 --> 00:44:52.200
you can go like less than, greater than,


00:44:52.200 --> 00:44:54.200
equal, not equal to, and so on.


00:44:54.200 --> 00:44:55.520
- Yeah, yeah.


00:44:55.520 --> 00:44:58.280
- For if it was none, I mean,


00:44:58.280 --> 00:45:00.960
is thing is none is the most natural way,


00:45:00.960 --> 00:45:02.840
but you would just say equal, equal none.


00:45:02.840 --> 00:45:04.600
Is that how you would test this?


00:45:04.600 --> 00:45:08.840
- Yeah, you cannot hear, so it's not supported to use is.


00:45:08.840 --> 00:45:09.680
- That's fine.


00:45:09.680 --> 00:45:11.640
- You can use only equal.


00:45:11.640 --> 00:45:16.040
- It's better than, you know, price equals 10


00:45:16.040 --> 00:45:18.880
or equals none just as an assignment.


00:45:18.880 --> 00:45:20.880
That's even weirder, so that's cool.


00:45:21.800 --> 00:45:24.600
Then the other thing that I thought was neat


00:45:24.600 --> 00:45:27.080
is so often in these ORMs,


00:45:27.080 --> 00:45:30.660
and it is worse in the Mongo story


00:45:30.660 --> 00:45:33.520
because each record that comes back


00:45:33.520 --> 00:45:35.760
represents more of the data, right?


00:45:35.760 --> 00:45:37.940
In this case, you've got a product


00:45:37.940 --> 00:45:39.480
and the product has a category,


00:45:39.480 --> 00:45:42.520
whereas those might be two separate tables


00:45:42.520 --> 00:45:44.520
in a relational database.


00:45:44.520 --> 00:45:47.080
So the problem is I get one of these objects


00:45:47.080 --> 00:45:49.360
back from the database, I make a small change to it,


00:45:49.360 --> 00:45:51.440
like I wanna change the name,


00:45:51.440 --> 00:45:54.140
and then I call save and it's gonna completely write


00:45:54.140 --> 00:45:56.320
everything back to the database.


00:45:56.320 --> 00:45:58.240
It's gonna overwrite everything,


00:45:58.240 --> 00:45:59.880
which can be a big problem.


00:45:59.880 --> 00:46:01.960
So you've got, there's a couple of solutions


00:46:01.960 --> 00:46:02.800
you have for that.


00:46:02.800 --> 00:46:07.400
One is you have the in place update operators,


00:46:07.400 --> 00:46:10.840
like set, and I'm guessing do you have like increment


00:46:10.840 --> 00:46:15.260
and decrement and add to set and those kinds of things?


00:46:15.260 --> 00:46:16.900
- Yeah, yeah, literally everything


00:46:16.900 --> 00:46:18.600
from which MongoDB supports.


00:46:19.540 --> 00:46:23.200
- Right, so in this case, you can say product.set


00:46:23.200 --> 00:46:27.100
and then product name is Goldbar, right?


00:46:27.100 --> 00:46:29.580
Rather than what was it before?


00:46:29.580 --> 00:46:32.340
It was Tony's or something like that, right?


00:46:32.340 --> 00:46:36.740
And that'll do a MongoDB, you know, dollar set operation,


00:46:36.740 --> 00:46:39.420
which is an atomic operation.


00:46:39.420 --> 00:46:41.940
So somebody else could be updating, say, the category


00:46:41.940 --> 00:46:45.260
at the same time, sort of transactionally safe.


00:46:45.260 --> 00:46:48.740
And so this way, you're both way more efficient


00:46:48.740 --> 00:46:52.020
And it's also safer that you're not possibly


00:46:52.020 --> 00:46:53.740
overriding other changes.


00:46:53.740 --> 00:46:54.580
- Yeah, yeah.


00:46:54.580 --> 00:46:58.500
And also in current version,


00:46:58.500 --> 00:47:00.580
it's possible to,


00:47:00.580 --> 00:47:05.580
so Bini tracks all the changes of the object.


00:47:05.580 --> 00:47:08.300
And when you call, instead of set,


00:47:08.300 --> 00:47:10.620
you can call save changes,


00:47:10.620 --> 00:47:14.380
and it will call set inside for all the changes


00:47:14.380 --> 00:47:18.700
which was happened with this object.


00:47:18.700 --> 00:47:20.700
- Yeah, this was the other way that I was hinting at


00:47:20.700 --> 00:47:22.260
and it's super cool.


00:47:22.260 --> 00:47:24.220
Where is this save changes?


00:47:24.220 --> 00:47:25.060
There we go.


00:47:25.060 --> 00:47:27.100
So on all of these documents,


00:47:27.100 --> 00:47:29.900
you can optionally have a class,


00:47:29.900 --> 00:47:31.940
an inner class called settings.


00:47:31.940 --> 00:47:33.020
And then you can do things like


00:47:33.020 --> 00:47:35.660
use state management equals true.


00:47:35.660 --> 00:47:38.620
And you don't have to figure out how to write those


00:47:38.620 --> 00:47:42.240
set operations or increment operations or whatever.


00:47:42.240 --> 00:47:44.540
You can just make changes and call save changes


00:47:44.540 --> 00:47:46.100
and off it goes, right?


00:47:46.100 --> 00:47:47.140
- Yeah, yeah.


00:47:47.140 --> 00:47:50.140
So it's--


00:47:50.140 --> 00:47:50.980
- I like this.


00:47:50.980 --> 00:47:52.640
Yeah, this is really, really cool.


00:47:52.640 --> 00:47:56.100
So I like that about this,


00:47:56.100 --> 00:48:00.020
that it gives you that option to sort of use the most


00:48:00.020 --> 00:48:04.020
natural way of making very small changes to the data,


00:48:04.020 --> 00:48:04.860
right?


00:48:04.860 --> 00:48:06.660
Because so often ORMs and ODMs are,


00:48:06.660 --> 00:48:08.660
give me the object back, I make a change to it,


00:48:08.660 --> 00:48:12.340
put the whole thing back wherever it came from, you know?


00:48:12.340 --> 00:48:13.900
- Yeah, yeah, they're great.


00:48:13.900 --> 00:48:21.660
Yeah, I agree. And also, if you don't want to fetch object at all,


00:48:21.660 --> 00:48:27.100
and you want to set something to the object, you can use update query here, right?


00:48:27.100 --> 00:48:32.220
And you will not even fetch object into your application.


00:48:32.220 --> 00:48:36.540
That's a really good point, because so often with ORMs and ODMs,


00:48:36.540 --> 00:48:40.060
the set-based behaviors are super hard to do.


00:48:40.620 --> 00:48:45.300
Right, like let's suppose I've got 100,000 users,


00:48:45.300 --> 00:48:50.220
I want to go and set some field to like a default value


00:48:50.220 --> 00:48:52.860
that didn't previously exist in the database.


00:48:52.860 --> 00:48:55.660
Or I want to compute something that's a computed field


00:48:55.660 --> 00:48:56.780
that wasn't previously there.


00:48:56.780 --> 00:49:01.620
So I've got to go to each one, make a change or something.


00:49:01.620 --> 00:49:03.540
If it's always the same value, you still


00:49:03.540 --> 00:49:05.380
would need to go in the ORM stories,


00:49:05.380 --> 00:49:09.780
like do a query, get the 100,000 records back,


00:49:09.780 --> 00:49:13.100
loop over them, set the little one value on the class


00:49:13.100 --> 00:49:14.340
and call save.


00:49:14.340 --> 00:49:16.620
But what you're saying is you could just do like


00:49:16.620 --> 00:49:20.740
product or in my case, users.update,


00:49:20.740 --> 00:49:22.660
value equals what you want it to


00:49:22.660 --> 00:49:25.060
and just update all of them, right?


00:49:25.060 --> 00:49:27.380
Update many, you might have to call or something like that.


00:49:27.380 --> 00:49:30.300
- Or you can even find something and then dot update


00:49:30.300 --> 00:49:33.420
and it will update on only.


00:49:33.420 --> 00:49:34.260
- Oh, really?


00:49:34.260 --> 00:49:37.300
So you could do like a find all then a dot update


00:49:37.300 --> 00:49:39.500
and it wouldn't actually pull them back from the database?


00:49:39.500 --> 00:49:40.940
- It will not fetch in there.


00:49:40.940 --> 00:49:42.260
- Oh my goodness, okay.


00:49:42.260 --> 00:49:43.500
- Little bit magic.


00:49:43.500 --> 00:49:44.620
- That's very magical.


00:49:44.620 --> 00:49:46.020
That's awesome actually.


00:49:46.020 --> 00:49:49.720
Then again, the other things you have on here


00:49:49.720 --> 00:49:51.340
that are really just simple is like,


00:49:51.340 --> 00:49:55.500
you can do a find and then just a to list on it.


00:49:55.500 --> 00:49:57.280
You know, like I don't wanna loop over it


00:49:57.280 --> 00:49:59.740
or what I just, give me the list back.


00:49:59.740 --> 00:50:01.180
That's also nice.


00:50:01.180 --> 00:50:02.020
- Yeah.


00:50:02.020 --> 00:50:05.740
- Yeah, let's see, how are we doing on time?


00:50:05.740 --> 00:50:07.220
We're getting a little short on time.


00:50:07.220 --> 00:50:09.940
Let's talk through a little bit of some,


00:50:09.940 --> 00:50:12.280
there's a really nice tutorial here


00:50:12.280 --> 00:50:15.160
that starts out with defining documents,


00:50:15.160 --> 00:50:16.220
setting up the code,


00:50:16.220 --> 00:50:19.140
which is pretty much just standard MongoDB, right?


00:50:19.140 --> 00:50:22.060
Like you have to create one of these clients,


00:50:22.060 --> 00:50:24.620
but what you're really creating is just a motor client.


00:50:24.620 --> 00:50:26.940
So I'm guessing you can send as like complex


00:50:26.940 --> 00:50:28.980
of a MongoDB configuration as you need to,


00:50:28.980 --> 00:50:30.480
and it doesn't affect Beanie.


00:50:30.480 --> 00:50:34.860
- Yeah, and also now it's not documented yet


00:50:34.860 --> 00:50:36.820
because I'm lazy,


00:50:36.820 --> 00:50:40.620
but Anthony Shaw, you know him, I think.


00:50:40.620 --> 00:50:43.460
- Anthony Shaw makes common appearances here, yes.


00:50:43.460 --> 00:50:48.140
- Yeah, suggested me to add optional,


00:50:48.140 --> 00:50:50.280
so you can pass connection string


00:50:50.280 --> 00:50:52.820
instead of all this stuff with database,


00:50:52.820 --> 00:50:56.620
just init_binny and connection string, and it will work.


00:50:56.620 --> 00:50:57.460
- Nice.


00:50:57.460 --> 00:51:02.140
- But I can't have documentation about this because...


00:51:02.140 --> 00:51:05.260
- Sure, so in the documentation, you create a motor client


00:51:05.260 --> 00:51:08.920
and then you pass the client over to Beanie,


00:51:08.920 --> 00:51:13.320
and that, or you just create the client first, right?


00:51:13.320 --> 00:51:14.620
But if you just call Beanie,


00:51:14.620 --> 00:51:17.100
and then Beanie with the right connection string,


00:51:17.100 --> 00:51:19.260
it'll do that behind the scenes for you.


00:51:19.260 --> 00:51:20.360
Yeah, thanks, Anthony.


00:51:20.360 --> 00:51:22.540
That's really good.


00:51:22.540 --> 00:51:26.380
So, but if you're working with like sharded clusters


00:51:26.380 --> 00:51:28.300
and replica sets and all the kinds of stuff


00:51:28.300 --> 00:51:31.240
that is like on the outer edge of these use cases,


00:51:31.240 --> 00:51:34.820
that should be supported, right?


00:51:34.820 --> 00:51:36.820
It's just under behind the scenes.


00:51:36.820 --> 00:51:37.940
You don't have to know about it.


00:51:37.940 --> 00:51:40.100
The other thing that's interesting is when you initialize it,


00:51:40.100 --> 00:51:43.860
you pass it all the document classes,


00:51:43.860 --> 00:51:46.640
like product or user or whatever, right?


00:51:46.640 --> 00:51:47.480
As a list.


00:51:47.480 --> 00:51:50.420
- Yeah, yeah, because you have to,


00:51:50.420 --> 00:51:52.620
so under the hood,


00:51:52.620 --> 00:51:56.300
document must know to which database it's picked


00:51:56.300 --> 00:51:58.620
because so for some use cases,


00:51:58.620 --> 00:52:01.780
you can use different databases in the same application.


00:52:01.780 --> 00:52:03.340
And in that case, you have to in it,


00:52:03.340 --> 00:52:07.380
for different databases with different set of models.


00:52:07.380 --> 00:52:11.700
So yeah, you have to pass models there.


00:52:11.700 --> 00:52:14.940
- Yeah, I do that in mine.


00:52:14.940 --> 00:52:16.600
I have multiple databases,


00:52:16.600 --> 00:52:21.420
like logging and analytics and all that kind of stuff


00:52:21.420 --> 00:52:24.900
goes to one database that gets managed


00:52:24.900 --> 00:52:27.140
and backed up less frequently


00:52:27.140 --> 00:52:29.580
'cause it's like gigs and gigs of data.


00:52:29.580 --> 00:52:30.980
But if you lost it,


00:52:30.980 --> 00:52:32.780
the only person who would care in the world is me,


00:52:32.780 --> 00:52:35.940
Like I lost my history of stuff, right?


00:52:35.940 --> 00:52:38.620
As opposed to the thing the website needs to run


00:52:38.620 --> 00:52:41.020
or user accounts or whatever,


00:52:41.020 --> 00:52:44.140
like those need to be backed up frequently


00:52:44.140 --> 00:52:45.740
and treated really specially.


00:52:45.740 --> 00:52:48.500
So I actually have those as two separate databases


00:52:48.500 --> 00:52:50.660
based on classes.


00:52:50.660 --> 00:52:52.140
So I guess what you're saying here


00:52:52.140 --> 00:52:55.700
is you can also call init beanie on multiple times


00:52:55.700 --> 00:52:59.300
with different databases and different lists of documents.


00:52:59.300 --> 00:53:00.140
- Yeah, yeah.


00:53:01.340 --> 00:53:02.240
- And it will work.


00:53:02.240 --> 00:53:06.280
- Nice.


00:53:06.280 --> 00:53:07.520
Yeah, that's really cool.


00:53:07.520 --> 00:53:10.400
Can you give it like a star type of thing,


00:53:10.400 --> 00:53:13.240
like everything in this folder,


00:53:13.240 --> 00:53:16.720
in this module or this sub package?


00:53:16.720 --> 00:53:21.000
- Not yet, unfortunately, but it's nice feature.


00:53:21.000 --> 00:53:24.360
I think, yeah, it sounds like a feature request.


00:53:24.360 --> 00:53:25.640
- Okay, sounds like a feature request.


00:53:25.640 --> 00:53:27.640
Yeah, so if you could give it something like,


00:53:27.640 --> 00:53:31.560
all my models live in this sub package of my project


00:53:31.560 --> 00:53:32.400
or in this folder.


00:53:32.400 --> 00:53:33.840
Like, there you go.


00:53:33.840 --> 00:53:35.520
That might be nice.


00:53:35.520 --> 00:53:38.720
Because one of the things that happens to me often


00:53:38.720 --> 00:53:43.720
is I'll add like a view to some part of my site


00:53:43.720 --> 00:53:46.280
and I'll forget to register it somewhere.


00:53:46.280 --> 00:53:47.720
Like, why is this a 404?


00:53:47.720 --> 00:53:49.400
Oh, yeah, yeah, yeah.


00:53:49.400 --> 00:53:52.360
I gotta go and make sure that thing can see this file.


00:53:52.360 --> 00:53:55.800
- It will raise an error, an exception,


00:53:55.800 --> 00:53:59.360
or less than you will call any endpoint.


00:53:59.360 --> 00:54:02.640
Like if you try to touch any document


00:54:02.640 --> 00:54:05.140
without initialization, it will raise an error.


00:54:05.140 --> 00:54:05.980
- Yeah, cool.


00:54:05.980 --> 00:54:09.060
So let's see, let's talk indexes.


00:54:09.060 --> 00:54:12.260
I started our conversation with my utter disbelief


00:54:12.260 --> 00:54:15.380
that there are websites that take five seconds to load.


00:54:15.380 --> 00:54:19.220
And I'm like, I know they don't have more data than I have.


00:54:19.220 --> 00:54:21.220
I just know they've done something wrong.


00:54:21.220 --> 00:54:24.060
There's no way this has more data.


00:54:24.060 --> 00:54:26.260
So indexes are critical, right?


00:54:26.260 --> 00:54:27.580
What is the index story?


00:54:27.580 --> 00:54:29.880
How do you create them over here?


00:54:29.880 --> 00:54:32.860
- It's interesting story about indexes, honestly.


00:54:32.860 --> 00:54:37.140
Like I published my first version of Beanie


00:54:37.140 --> 00:54:39.620
and one guy texted me and said,


00:54:39.620 --> 00:54:41.700
(both laughing)


00:54:41.700 --> 00:54:44.460
probably it's possible to add indexes there.


00:54:44.460 --> 00:54:46.740
I don't see if it's supported or not.


00:54:46.740 --> 00:54:48.340
(both laughing)


00:54:48.340 --> 00:54:50.580
And in a few days I added them.


00:54:50.580 --> 00:54:51.420
- Yeah, that's right.


00:54:51.420 --> 00:54:53.940
We covered Beanie when it first came out on Python Bytes.


00:54:53.940 --> 00:54:56.740
I'm like, this is awesome, but where are the indexes?


00:54:56.740 --> 00:54:58.620
I'm a bit of a stickler for those.


00:54:58.620 --> 00:54:59.500
That's awesome.


00:54:59.500 --> 00:55:02.180
So yeah, the way you do it is instead of saying,


00:55:02.180 --> 00:55:06.380
when you define a class, say the type is, say a str,


00:55:06.380 --> 00:55:09.980
or an int, you would say it's an indexed of int,


00:55:09.980 --> 00:55:11.820
and that just creates the index.


00:55:11.820 --> 00:55:13.360
And it looks like you, you know, in Mongo,


00:55:13.360 --> 00:55:16.580
you have all these parameters and control.


00:55:16.580 --> 00:55:18.220
Is it a sparse index?


00:55:18.220 --> 00:55:20.640
Is it a uniqueness constraint as well?


00:55:20.640 --> 00:55:22.580
Is it ascending?


00:55:22.580 --> 00:55:23.620
Is it descending?


00:55:23.620 --> 00:55:26.820
and whatnot, and so you can pass additional information


00:55:26.820 --> 00:55:30.380
like that it's a text index or something like that, right?


00:55:30.380 --> 00:55:32.580
- Yeah, yeah, it supports all the parameters.


00:55:32.580 --> 00:55:34.780
- And uniqueness, this isn't super important, right?


00:55:34.780 --> 00:55:38.620
Like, your email on your user account


00:55:38.620 --> 00:55:41.220
had better be unique, otherwise a reset password


00:55:41.220 --> 00:55:42.580
is gonna get really weird.


00:55:42.580 --> 00:55:45.500
(both laughing)


00:55:45.500 --> 00:55:47.500
You support multi-field indexes,


00:55:47.500 --> 00:55:49.460
which is something that's pretty common,


00:55:49.460 --> 00:55:50.940
like a composite index.


00:55:50.940 --> 00:55:53.540
if I'm gonna do a query where the product


00:55:53.540 --> 00:55:56.780
is in this category and it's on sale,


00:55:56.780 --> 00:55:59.260
you wanna have the index take both of those into account


00:55:59.260 --> 00:56:00.380
to be super fast, right?


00:56:00.380 --> 00:56:02.160
So you have support for that?


00:56:02.160 --> 00:56:06.060
- Yeah, it supports also, but it's not that neat, let's say,


00:56:06.060 --> 00:56:08.540
it's not that beautiful, but it's supported.


00:56:08.540 --> 00:56:12.420
- Yeah, well, the payoff is worth it.


00:56:12.420 --> 00:56:17.420
And it's also in this class called collection, right?


00:56:17.700 --> 00:56:22.700
So it's kind of in its own special inner class of the model,


00:56:22.700 --> 00:56:25.540
in which case, a lot of the IDs have a little chevron,


00:56:25.540 --> 00:56:26.740
you can just collapse that thing


00:56:26.740 --> 00:56:28.140
and not look at it anymore.


00:56:28.140 --> 00:56:33.540
So it's easy to hide the complexity, I guess there.


00:56:33.540 --> 00:56:35.700
- Yeah, yeah.


00:56:35.700 --> 00:56:36.540
- Cool.


00:56:36.540 --> 00:56:38.860
All right, what else?


00:56:38.860 --> 00:56:43.860
Aggregation, it sounds like that when we talk about,


00:56:43.860 --> 00:56:46.220
I'll have to get to it pretty quick.


00:56:46.220 --> 00:56:48.660
when we talk about relationships and stuff,


00:56:48.660 --> 00:56:51.180
you said that this is super efficient


00:56:51.180 --> 00:56:53.660
because it's using the aggregation framework.


00:56:53.660 --> 00:56:56.220
So MongoDB has like two ways to query stuff, right?


00:56:56.220 --> 00:56:58.900
It's like the straight query style,


00:56:58.900 --> 00:57:02.260
and then it has something that's honestly harder to use,


00:57:02.260 --> 00:57:04.960
but more flexible called aggregations.


00:57:04.960 --> 00:57:06.500
And so you guys support,


00:57:06.500 --> 00:57:10.500
your library supports aggregation queries as well, right?


00:57:10.500 --> 00:57:11.740
- Yeah, yeah, right.


00:57:11.740 --> 00:57:14.180
And also as before with updates,


00:57:14.180 --> 00:57:18.660
it also supports find queries together with aggregations.


00:57:18.660 --> 00:57:23.380
Like you can use, like an example, for example,


00:57:23.380 --> 00:57:28.300
there are some presets of aggregations like average here,


00:57:28.300 --> 00:57:31.500
and you can use this average with find queries together,


00:57:31.500 --> 00:57:33.540
and you will see the result.


00:57:33.540 --> 00:57:36.960
And also for sure, you can pass list pipeline


00:57:36.960 --> 00:57:38.460
in MongoDB terms.


00:57:38.460 --> 00:57:43.460
You can pass pipeline of your aggregation steps there,


00:57:43.500 --> 00:57:44.740
and it will work.


00:57:44.740 --> 00:57:47.100
- Yeah, it's not super easy to write


00:57:47.100 --> 00:57:50.100
if you haven't done it before, but yes, it will work.


00:57:50.100 --> 00:57:53.820
- Yeah, and also the thing is, with aggregations,


00:57:53.820 --> 00:57:58.820
you have to set up what schema of the result will be,


00:57:58.820 --> 00:58:02.180
because with find, everybody knows it would be


00:58:02.180 --> 00:58:04.920
the same schema of the document, of the original document.


00:58:04.920 --> 00:58:07.780
But with aggregations, it definitely can be


00:58:07.780 --> 00:58:09.340
any schema of results.


00:58:09.340 --> 00:58:12.340
- Right, because the whole point of aggregation,


00:58:12.340 --> 00:58:15.180
other people might know something similar with MapReduce


00:58:15.180 --> 00:58:18.900
is I wanna take, say a collection of sales


00:58:18.900 --> 00:58:23.260
and I wanna get a result of show me the sales by country


00:58:23.260 --> 00:58:25.660
and the total sales for that country, right?


00:58:25.660 --> 00:58:27.260
So you're not gonna get a list of sales back,


00:58:27.260 --> 00:58:29.700
you're gonna get a thing, a list of things


00:58:29.700 --> 00:58:32.740
that has a country and a total sales, right?


00:58:32.740 --> 00:58:34.340
- Yeah, yeah, yeah.


00:58:34.340 --> 00:58:36.900
And that's why, so you can, for sure it's optional


00:58:36.900 --> 00:58:41.900
and you cannot pass project output model.


00:58:41.900 --> 00:58:44.460
And in that case, it will return dictionaries,


00:58:44.460 --> 00:58:47.700
but it's not that fancy, so it would be better to--


00:58:47.700 --> 00:58:48.620
- Yeah, this is super cool.


00:58:48.620 --> 00:58:50.320
I love this projection model idea.


00:58:50.320 --> 00:58:52.860
Mario out in the audience says,


00:58:52.860 --> 00:58:54.060
"I created a model loader."


00:58:54.060 --> 00:58:59.060
Speaking of the passing the documents to Beanie and Knit,


00:58:59.060 --> 00:59:02.540
I created a model loader as a utility function


00:59:02.540 --> 00:59:04.580
that pulls dot separated pass


00:59:04.580 --> 00:59:06.700
and then passes it to document models.


00:59:06.700 --> 00:59:07.600
Works really well.


00:59:07.600 --> 00:59:10.020
- Great.


00:59:10.020 --> 00:59:10.860
(both laughing)


00:59:10.860 --> 00:59:12.700
- There you go, right on.


00:59:12.700 --> 00:59:16.540
So let's talk about relationships


00:59:16.540 --> 00:59:19.220
because I started out talking about,


00:59:19.220 --> 00:59:21.060
you don't use the R, you use the D


00:59:21.060 --> 00:59:24.020
'cause you model documents, not relationships.


00:59:24.020 --> 00:59:28.220
And yet, Beanie supports relationships.


00:59:28.220 --> 00:59:29.060
This is pretty cool.


00:59:29.060 --> 00:59:30.460
- I'm super excited about this.


00:59:30.460 --> 00:59:32.520
- Yeah, tell us about this.


00:59:32.520 --> 00:59:36.940
- Yeah, so it took around three months


00:59:36.940 --> 00:59:38.740
to come up how to do relations.


00:59:38.740 --> 00:59:41.740
I mean, MongoDB doesn't support relations.


00:59:41.740 --> 00:59:43.820
(laughs)


00:59:43.820 --> 00:59:50.460
But relations is a very popular feature in Orem and ODMs


00:59:50.460 --> 00:59:53.460
and I had to implement it finally.


00:59:53.460 --> 00:59:55.980
So, and I did it.


00:59:55.980 --> 00:59:59.800
For now it's supported limited version of relations


00:59:59.800 --> 01:00:02.760
like only top level fields are supported


01:00:02.760 --> 01:00:06.420
and only two kinds of relations


01:00:06.420 --> 01:00:10.720
like a direct relation and list of relations.


01:00:10.720 --> 01:00:13.860
- Right, a one-to-one or a one-to-many, I guess.


01:00:13.860 --> 01:00:15.460
- One-to-one, one-to-many, yeah.


01:00:15.460 --> 01:00:21.860
And so the syntax is bytonic, I'd say.


01:00:21.860 --> 01:00:24.320
It uses generic class link.


01:00:24.320 --> 01:00:29.740
Inside of bracket, of square brackets,


01:00:29.740 --> 01:00:32.320
you'll pass your document.


01:00:32.320 --> 01:00:33.940
- Right, so maybe you would specify,


01:00:33.940 --> 01:00:36.940
normally you would say an optional int.


01:00:36.940 --> 01:00:39.540
Here you would say like link int,


01:00:39.540 --> 01:00:41.220
and that might, int doesn't make sense,


01:00:41.220 --> 01:00:43.380
but that type thing would be the relationship, right?


01:00:43.380 --> 01:00:45.940
It's like the same syntax is optional basically here.


01:00:45.940 --> 01:00:47.660
- Yeah, yeah, yeah.


01:00:47.660 --> 01:00:49.260
It's a little bit tricky


01:00:49.260 --> 01:00:52.380
and there's a black magic under the hood, but.


01:00:52.380 --> 01:00:55.100
- Not long as I don't have to know about it.


01:00:55.100 --> 01:00:56.980
Thanks for creating the black magic.


01:00:56.980 --> 01:00:59.340
So you could say here your model is,


01:00:59.340 --> 01:01:00.700
there's a door and a house,


01:01:00.700 --> 01:01:03.940
and then the door is of type link of door.


01:01:03.940 --> 01:01:05.460
And then you have another one,


01:01:05.460 --> 01:01:08.220
you have windows where the house has many windows.


01:01:08.220 --> 01:01:13.220
And you would say the windows is a list of link of window,


01:01:13.220 --> 01:01:17.840
which is, it's a little bit intense on the nesting there,


01:01:17.840 --> 01:01:18.780
but it's not bad, right?


01:01:18.780 --> 01:01:21.700
It's just, it's a list of relationships, yeah?


01:01:21.700 --> 01:01:22.540
- Yeah, yeah.


01:01:22.540 --> 01:01:23.740
And for sure it's possible.


01:01:23.740 --> 01:01:26.820
And I think later it would be implemented.


01:01:26.820 --> 01:01:31.820
I will shorten this list of links to another...


01:01:31.820 --> 01:01:34.100
- Links.


01:01:34.100 --> 01:01:34.940
- Links.


01:01:34.940 --> 01:01:37.100
- No, just kidding, don't do that.


01:01:37.100 --> 01:01:39.700
Although it would be kind of awesome as a syntax.


01:01:39.700 --> 01:01:41.600
I think it would be less discoverable.


01:01:41.600 --> 01:01:48.380
- So yeah, and it works.


01:01:48.380 --> 01:01:53.380
You can insert data inside of this linked documents


01:01:53.380 --> 01:01:55.220
to linked collections.


01:01:55.220 --> 01:01:57.860
and you can fetch data from linked collections.


01:01:57.860 --> 01:01:58.680
And...


01:01:58.680 --> 01:02:02.380
- Yeah, and you can even have it cascade things.


01:02:02.380 --> 01:02:05.860
So for example, you could have created a house object


01:02:05.860 --> 01:02:09.820
and say dot windows is this list of window objects.


01:02:09.820 --> 01:02:12.260
And then you would say house dot save.


01:02:12.260 --> 01:02:14.420
And if you pass the link rule,


01:02:14.420 --> 01:02:20.100
then that says, write the cascade the changes.


01:02:20.100 --> 01:02:22.140
It'll also go and insert all those windows


01:02:22.140 --> 01:02:24.340
and associate them, right?


01:02:24.340 --> 01:02:25.180
- Yeah, correct.


01:02:25.180 --> 01:02:28.900
And I didn't use cascade term


01:02:28.900 --> 01:02:32.180
because it's not SQL database


01:02:32.180 --> 01:02:34.340
and a little bit different.


01:02:34.340 --> 01:02:40.420
I mean, with relations, it would be completely different.


01:02:40.420 --> 01:02:41.260
- Yeah.


01:02:41.260 --> 01:02:43.580
How does this look in the database itself?


01:02:43.580 --> 01:02:48.240
So if I go to MongoDB and I pull up the house,


01:02:48.240 --> 01:02:49.580
what is in its windows?


01:02:49.580 --> 01:02:52.500
Is that a list of the IDs of the window objects


01:02:52.500 --> 01:02:53.740
or what is that?


01:02:53.740 --> 01:02:58.740
- In MongoDB, there is a special data type called refid.


01:02:58.740 --> 01:03:00.380
- Okay.


01:03:00.380 --> 01:03:03.780
- It's under the hood, it's binary data type,


01:03:03.780 --> 01:03:08.540
but under the hood, it's a combination of id of the document,


01:03:08.540 --> 01:03:11.620
name of the collection and name of the database.


01:03:11.620 --> 01:03:12.460
So it's a tuple.


01:03:12.460 --> 01:03:13.860
- Oh, interesting.


01:03:13.860 --> 01:03:16.580
Okay, so that's what in the document,


01:03:16.580 --> 01:03:19.260
what I end up with is a list of those things, yeah.


01:03:19.260 --> 01:03:20.780
- Yeah, yeah.


01:03:20.780 --> 01:03:23.220
And you will see a few collections,


01:03:23.220 --> 01:03:26.940
like here, house, window, and door,


01:03:26.940 --> 01:03:30.480
three collections with these objects, separated objects.


01:03:30.480 --> 01:03:33.020
- Okay, cool.


01:03:33.020 --> 01:03:35.620
You can also tell it


01:03:35.620 --> 01:03:38.380
that you don't want to propagate those changes, right?


01:03:38.380 --> 01:03:40.620
As you save the house, which is interesting.


01:03:40.620 --> 01:03:42.660
Let's talk about prefetch.


01:03:42.660 --> 01:03:46.700
So I told you one of the,


01:03:46.700 --> 01:03:50.020
when I see those websites that are just dragging super slow,


01:03:50.020 --> 01:03:52.940
I go through my thing, all right, did they forget the index?


01:03:52.940 --> 01:03:56.220
Are they doing some terrible seven-way join,


01:03:56.220 --> 01:03:58.180
probably without indexes?


01:03:58.180 --> 01:04:01.220
Or the third thing, is it an N plus one ORM problem


01:04:01.220 --> 01:04:02.120
where they get one thing,


01:04:02.120 --> 01:04:04.340
but then they've got to go back and back and back


01:04:04.340 --> 01:04:06.600
because they're touching this related field,


01:04:06.600 --> 01:04:09.940
which you could potentially run into that problem as well.


01:04:09.940 --> 01:04:11.220
So you have this prefetch idea,


01:04:11.220 --> 01:04:13.660
which is kind of like a joined load


01:04:13.660 --> 01:04:16.780
or something like that, right?


01:04:16.780 --> 01:04:20.260
- Yeah, yeah, it uses lookup aggregation


01:04:20.260 --> 01:04:21.540
in terms of MongoDB.


01:04:21.540 --> 01:04:25.860
It's not just find query, but aggregation,


01:04:25.860 --> 01:04:30.860
and it avoids this n plus one problem, as you said.


01:04:30.860 --> 01:04:32.660
- Right, so you just do, in your find,


01:04:32.660 --> 01:04:34.700
you just say fetch links equals true,


01:04:34.700 --> 01:04:37.460
and that'll just go get the doors, the windows,


01:04:37.460 --> 01:04:39.340
everything in your house example, right?


01:04:39.340 --> 01:04:40.700
- Yeah.


01:04:40.700 --> 01:04:45.700
And I like the speed of this.


01:04:45.780 --> 01:04:49.300
like it's much faster than do it one by one,


01:04:49.300 --> 01:04:50.980
especially for list of objects.


01:04:50.980 --> 01:04:51.940
- Yeah, absolutely.


01:04:51.940 --> 01:04:54.820
So you also have the ability to say,


01:04:54.820 --> 01:04:57.340
fetch all links retroactively.


01:04:57.340 --> 01:04:58.460
If you've, you're like,


01:04:58.460 --> 01:05:01.040
oh, I should have done this join, but I didn't.


01:05:01.040 --> 01:05:03.700
That might sound silly, right?


01:05:03.700 --> 01:05:05.740
Well, why not just always do the join, right?


01:05:05.740 --> 01:05:09.100
That's one, probably slower than not doing it,


01:05:09.100 --> 01:05:10.520
I would guess.


01:05:10.520 --> 01:05:13.980
And two, this happens to me all the time.


01:05:13.980 --> 01:05:16.280
like for example, on the courses website,


01:05:16.280 --> 01:05:20.100
I wanna show, I wanna be able to get the courses,


01:05:20.100 --> 01:05:22.600
but the courses have like chapter information


01:05:22.600 --> 01:05:24.740
and other stuff inside of them.


01:05:24.740 --> 01:05:28.740
And then those have like links effectively over to say,


01:05:28.740 --> 01:05:31.180
like all the details about each chapter,


01:05:31.180 --> 01:05:34.540
like the lectures and videos and all that.


01:05:34.540 --> 01:05:38.300
On say the page that lists the courses,


01:05:38.300 --> 01:05:40.060
I do not want those things,


01:05:40.060 --> 01:05:43.440
but on the course details page where it shows you like,


01:05:43.440 --> 01:05:45.480
here's all the stuff in the course and how long it is.


01:05:45.480 --> 01:05:48.060
Like I definitely do want those things.


01:05:48.060 --> 01:05:51.220
So in my data access layer, I have a thing that says,


01:05:51.220 --> 01:05:52.360
should you get all the data


01:05:52.360 --> 01:05:54.900
or just the top level data basically?


01:05:54.900 --> 01:05:56.880
And this would be exactly the code you'd write.


01:05:56.880 --> 01:05:58.480
Like, well, if you want all the data,


01:05:58.480 --> 01:06:00.960
you had say, fetch all links on it, right?


01:06:00.960 --> 01:06:02.280
- Yeah, yeah, correct.


01:06:02.280 --> 01:06:04.800
- This is cool.


01:06:04.800 --> 01:06:07.000
Is there a way to do that on a set?


01:06:07.000 --> 01:06:08.560
Like this is on one record.


01:06:08.560 --> 01:06:12.000
Is there a way to say, I got 20 houses back,


01:06:12.000 --> 01:06:14.400
fetch all of their links or do I have to do it?


01:06:14.400 --> 01:06:15.560
Is that 20 calls?


01:06:15.560 --> 01:06:18.840
- So it would be 20 calls.


01:06:18.840 --> 01:06:20.440
- That's okay.


01:06:20.440 --> 01:06:24.800
I think in my example, it's also 20 calls or however many


01:06:24.800 --> 01:06:26.940
the same setup is exactly the same, but.


01:06:26.940 --> 01:06:30.360
- But I will improve it.


01:06:30.360 --> 01:06:31.280
I hope.


01:06:31.280 --> 01:06:33.700
- Yeah, this is worth pointing out.


01:06:33.700 --> 01:06:35.120
This is a brand new feature, right?


01:06:35.120 --> 01:06:38.480
You announced this as one of the new features


01:06:38.480 --> 01:06:40.560
just two days ago, right?


01:06:40.560 --> 01:06:41.480
- On Monday, yeah.


01:06:41.480 --> 01:06:44.040
- Yeah, and for the people listening,


01:06:44.040 --> 01:06:45.440
we're recording on Wednesday morning.


01:06:45.440 --> 01:06:48.200
So yeah, this is not, this is like your first pass,


01:06:48.200 --> 01:06:50.520
but I really like how this looks with the relationships


01:06:50.520 --> 01:06:53.480
and the query and whatnot.


01:06:53.480 --> 01:06:55.680
It would be nice, I think, if you could have


01:06:55.680 --> 01:06:59.600
some way to kind of globally configure to save.


01:06:59.600 --> 01:07:01.720
In general, if I call save,


01:07:01.720 --> 01:07:05.960
the rule to write the relationships is to not do nothing


01:07:05.960 --> 01:07:07.860
or to always write them or something,


01:07:07.860 --> 01:07:10.120
and then only have to override it potentially.


01:07:10.120 --> 01:07:12.680
- Yeah, sounds like default rule.


01:07:12.680 --> 01:07:14.000
- Yeah, exactly, exactly.


01:07:14.000 --> 01:07:15.560
That'd be pretty cool.


01:07:15.560 --> 01:07:19.040
So let's see a few other things we could talk about.


01:07:19.040 --> 01:07:21.360
We talked a little bit about the event-based actions,


01:07:21.360 --> 01:07:25.680
but you wanna just kinda talk about them directly


01:07:25.680 --> 01:07:27.000
because it was like a quick,


01:07:27.000 --> 01:07:29.720
well, how do I add my default value?


01:07:29.720 --> 01:07:32.080
What's the overall picture with these default


01:07:32.080 --> 01:07:33.480
or with these event actions?


01:07:33.480 --> 01:07:38.800
- So yeah, a lot of, somehow a lot of people wanted this


01:07:38.800 --> 01:07:43.800
And I didn't know about this pattern before.


01:07:43.800 --> 01:07:47.560
Like it's implemented something like this,


01:07:47.560 --> 01:07:52.560
implemented in ActiveRab record pattern of Rails.


01:07:52.560 --> 01:07:56.920
And so finally I was inspired by this.


01:07:56.920 --> 01:07:58.760
I like this word, inspired by.


01:07:58.760 --> 01:08:01.960
Not stolen, but inspired by.


01:08:01.960 --> 01:08:06.560
So and implemented this, yeah.


01:08:06.560 --> 01:08:11.120
And now it's supported only for types of events.


01:08:11.120 --> 01:08:13.320
There are events on each insert,


01:08:13.320 --> 01:08:16.840
replace, save changes and validate on save.


01:08:16.840 --> 01:08:22.040
It creates an event and two events


01:08:22.040 --> 01:08:24.320
before it called and after it called.


01:08:24.320 --> 01:08:29.080
And based on this events,


01:08:29.080 --> 01:08:32.480
actions already registered to the document


01:08:32.480 --> 01:08:34.360
would be called also.


01:08:34.360 --> 01:08:39.320
It supports and synchronous and asynchronous methods for this.


01:08:39.320 --> 01:08:41.520
And you can do a lot of stuff with this.


01:08:41.520 --> 01:08:43.320
- Yeah, that's cool.


01:08:43.320 --> 01:08:45.720
You can put the decorator on just an async version


01:08:45.720 --> 01:08:47.080
or a non-async version


01:08:47.080 --> 01:08:50.520
and being able to just call it correctly, right?


01:08:50.520 --> 01:08:51.800
- Yeah, yeah.


01:08:51.800 --> 01:08:53.320
- Yeah, that's cool.


01:08:53.320 --> 01:08:56.240
I'm guessing if you're not doing any awaits,


01:08:56.240 --> 01:08:58.800
it'd be better if it was not asynchronous,


01:08:58.800 --> 01:09:00.760
but it doesn't matter that much, right?


01:09:01.800 --> 01:09:06.160
- It's one half faster if it's not asynchronous.


01:09:06.160 --> 01:09:07.000
- Yeah.


01:09:07.000 --> 01:09:11.280
But if it's doing something where it's waiting


01:09:11.280 --> 01:09:13.880
on something else, then maybe it should be.


01:09:13.880 --> 01:09:14.820
- Yeah. - Okay.


01:09:14.820 --> 01:09:19.480
Another feature that just came out is cache.


01:09:19.480 --> 01:09:21.900
- Yeah, cache.


01:09:21.900 --> 01:09:26.180
It's also interesting feature.


01:09:26.180 --> 01:09:29.600
So yeah, it's cache.


01:09:29.600 --> 01:09:33.240
I don't know if I have to explain what is cache.


01:09:33.240 --> 01:09:36.840
It's when you save data somewhere locally


01:09:36.840 --> 01:09:40.760
and use a copy of data for some time.


01:09:40.760 --> 01:09:43.120
- Yeah, and what you're talking about


01:09:43.120 --> 01:09:46.040
is not using MongoDB as a caching backend,


01:09:46.040 --> 01:09:50.920
but caching the queries that would run through Beanie


01:09:50.920 --> 01:09:53.780
to not hit the database again if it knows the answer.


01:09:53.780 --> 01:09:58.780
- Yeah, yeah, and somehow it's really important feature.


01:09:58.780 --> 01:10:01.880
even for my projects.


01:10:01.880 --> 01:10:06.720
Like for example, if you have to validate stuff with user


01:10:06.720 --> 01:10:10.840
and you already asked for a user in this application


01:10:10.840 --> 01:10:14.000
with this ID, but you don't know the place where you did it


01:10:14.000 --> 01:10:16.720
and you don't want to provide this object


01:10:16.720 --> 01:10:17.960
through the whole pipeline


01:10:17.960 --> 01:10:19.200
because probably it will not be used


01:10:19.200 --> 01:10:21.440
in the end of this pipeline.


01:10:21.440 --> 01:10:23.800
But user is already cached in Bini


01:10:23.800 --> 01:10:27.520
and if you just will ask in the end of the pipeline


01:10:27.520 --> 01:10:30.000
again, about the same user data.


01:10:30.000 --> 01:10:31.800
So it would be there.


01:10:31.800 --> 01:10:36.800
And with a bigger find queries, it works the same way.


01:10:36.800 --> 01:10:39.840
- Yeah, the more complicated the query, the better.


01:10:39.840 --> 01:10:42.840
This makes a lot of sense, I think,


01:10:42.840 --> 01:10:44.560
for data that doesn't change much.


01:10:44.560 --> 01:10:46.200
Like if you've got a bookstore,


01:10:46.200 --> 01:10:47.720
you might have categories and books,


01:10:47.720 --> 01:10:50.520
and maybe the books change often,


01:10:50.520 --> 01:10:52.920
the reviews of the books change often,


01:10:52.920 --> 01:10:54.920
the books that are in different categories change,


01:10:54.920 --> 01:10:58.260
but the categories themselves very rarely change, right?


01:10:58.260 --> 01:11:00.580
So that could be something like the category query


01:11:00.580 --> 01:11:03.620
could just be like, you know what, this is cached.


01:11:03.620 --> 01:11:05.620
- Yeah, yeah, definitely.


01:11:05.620 --> 01:11:08.900
So for now it supports only local cache


01:11:08.900 --> 01:11:11.660
like dictionaries of Python,


01:11:11.660 --> 01:11:13.980
but I plan to add another cache backends


01:11:13.980 --> 01:11:17.200
like Redis and something like this.


01:11:17.200 --> 01:11:18.040
- Yeah, that's cool.


01:11:18.040 --> 01:11:21.960
Or even possibly you could put,


01:11:21.960 --> 01:11:25.680
- It might even make sense to use MongoDB itself as a cache.


01:11:25.680 --> 01:11:26.520
- Yeah.


01:11:26.520 --> 01:11:29.360
- Because what your cache--


01:11:29.360 --> 01:11:30.320
(indistinct)


01:11:30.320 --> 01:11:32.520
I mean, it'd be weird to kind of store the same thing


01:11:32.520 --> 01:11:34.600
back into it, but at the same time,


01:11:34.600 --> 01:11:36.220
if you've got a complicated query,


01:11:36.220 --> 01:11:37.480
what you're storing is like,


01:11:37.480 --> 01:11:39.280
these are the three things that came back


01:11:39.280 --> 01:11:41.860
from running that query against possibly


01:11:41.860 --> 01:11:44.320
hundreds of millions of records, right?


01:11:44.320 --> 01:11:45.820
So in that case, it might make sense


01:11:45.820 --> 01:11:47.200
to just put it back in Mongo,


01:11:47.200 --> 01:11:50.680
so it's just a straight, you know, table scan reads.


01:11:50.680 --> 01:11:52.280
something like Lambda architecture


01:11:52.280 --> 01:11:53.960
inside of the single database.


01:11:53.960 --> 01:11:57.540
- Yeah, yeah.


01:11:57.540 --> 01:12:01.440
So I wanted to ask you, your example says,


01:12:01.440 --> 01:12:04.040
okay, what we're gonna do is say sample.find num


01:12:04.040 --> 01:12:06.420
greater than 10 to list.


01:12:06.420 --> 01:12:09.260
And then if you call it again with the caching on,


01:12:09.260 --> 01:12:11.120
then you get the same thing.


01:12:11.120 --> 01:12:15.260
Well, it looks at the actual query, right?


01:12:15.260 --> 01:12:17.560
So if I said num greater than 11,


01:12:17.560 --> 01:12:19.640
I would get, that would be a separate result


01:12:19.640 --> 01:12:21.760
of a separate cached thing, right?


01:12:21.760 --> 01:12:23.720
- Yeah, yeah, totally.


01:12:23.720 --> 01:12:25.440
- Cool, the other thing I guess that's worth noting


01:12:25.440 --> 01:12:28.880
is you can set an expiration date on the cache, right?


01:12:28.880 --> 01:12:32.160
Like I want this to live for 10 minutes or whatever


01:12:32.160 --> 01:12:35.240
to get the answer back, yeah?


01:12:35.240 --> 01:12:36.180
- Yeah, yeah.


01:12:36.180 --> 01:12:38.800
- Cool, all right.


01:12:38.800 --> 01:12:41.640
Let's talk about revisions


01:12:41.640 --> 01:12:44.360
and then I'm gonna propose one more idea


01:12:44.360 --> 01:12:47.880
that I think I could build out of revisions and events.


01:12:47.880 --> 01:12:52.360
So what are revisions?


01:12:52.360 --> 01:12:56.320
- So it's not my idea again.


01:12:56.320 --> 01:12:58.280
It's another one user asked me for this


01:12:58.280 --> 01:13:00.880
and I really like users of Binny


01:13:00.880 --> 01:13:04.600
because I have not that many ideas.


01:13:04.600 --> 01:13:08.580
And yeah, what is this?


01:13:08.580 --> 01:13:12.880
Sometimes you have to protect a document


01:13:12.880 --> 01:13:16.960
inside of the database of changes.


01:13:16.960 --> 01:13:21.120
So yeah, sometimes you have old version of the data


01:13:21.120 --> 01:13:23.800
in your backend and you do some updates.


01:13:23.800 --> 01:13:28.480
And if you update your document with this old data,


01:13:28.480 --> 01:13:32.360
you will lose data updated by another backend


01:13:32.360 --> 01:13:33.560
for the same document.


01:13:33.560 --> 01:13:35.840
- And so let me give people some examples


01:13:35.840 --> 01:13:38.560
'cause I think understanding the context is really important.


01:13:38.560 --> 01:13:42.000
Like it could be even the same function basically, right?


01:13:42.000 --> 01:13:45.160
So I could have a function that do complicated things.


01:13:45.160 --> 01:13:47.680
I could say, get me my user object


01:13:47.680 --> 01:13:50.240
for the current user who wants to make some changes.


01:13:50.240 --> 01:13:52.480
I could call, do a bunch of work,


01:13:52.480 --> 01:13:55.600
call a function with the pass, say, like the user ID over.


01:13:55.600 --> 01:13:57.020
Maybe that gets the user back,


01:13:57.020 --> 01:14:00.680
makes some changes, saves it to the database.


01:14:00.680 --> 01:14:02.760
And then I go to the end, I make some more changes,


01:14:02.760 --> 01:14:05.260
not realizing that, to my in-memory version,


01:14:05.260 --> 01:14:06.840
and I call save, and it overwrote


01:14:06.840 --> 01:14:09.480
what that intermediate function might have,


01:14:09.480 --> 01:14:12.440
whatever was there is gone now, you know what I mean?


01:14:12.440 --> 01:14:15.320
So you would want to know,


01:14:15.320 --> 01:14:19.280
is the thing that I got back,


01:14:19.280 --> 01:14:20.920
if I'm gonna replace it in the database,


01:14:20.920 --> 01:14:23.320
is it still the same thing


01:14:23.320 --> 01:14:26.280
or is somebody somewhere behind the scenes changed it?


01:14:26.280 --> 01:14:29.800
Often I think that people think about very complicated,


01:14:29.800 --> 01:14:31.840
well, some other process did some other thing,


01:14:31.840 --> 01:14:34.360
but it could just be some other part of your code


01:14:34.360 --> 01:14:37.560
that you didn't realize called save after a query.


01:14:37.560 --> 01:14:39.360
- Yeah, yeah.


01:14:39.360 --> 01:14:47.680
For this case, I'm using a revision ID, a special token, which generates each time when


01:14:47.680 --> 01:14:50.360
data saves into the database.


01:14:50.360 --> 01:14:57.940
And when you save again, it will check if this ID is the same or it's already updated.


01:14:57.940 --> 01:15:03.300
If it's updated, it will raise an error, like you have all data in memory.


01:15:03.300 --> 01:15:05.680
But if it's the same, it will allow you to...


01:15:05.680 --> 01:15:06.680
Nice.


01:15:06.680 --> 01:15:09.680
- That's really cool. - I think it's a great practice.


01:15:09.680 --> 01:15:12.680
No, it's good. It's good. It definitely is.


01:15:12.680 --> 01:15:18.680
Because the alternative of this pattern is to do a blocking transaction.


01:15:18.680 --> 01:15:21.680
Right? And that's also potentially possible.


01:15:21.680 --> 01:15:25.680
I think MongoDB does have transactions now, but I still haven't used them.


01:15:25.680 --> 01:15:27.680
I don't really have a use for that.


01:15:27.680 --> 01:15:32.680
But the alternative model in databases is to say,


01:15:32.680 --> 01:15:35.860
we're going to do a transaction that blocks


01:15:35.860 --> 01:15:38.400
and anyone else who tries to do a database thing whatsoever,


01:15:38.400 --> 01:15:40.400
they just wait until we're done.


01:15:40.400 --> 01:15:42.900
And that way there's no chance of them seeing it


01:15:42.900 --> 01:15:44.900
in this intermediate state.


01:15:44.900 --> 01:15:48.740
A lot of the scalable systems


01:15:48.740 --> 01:15:52.040
don't end up doing that even in relational databases


01:15:52.040 --> 01:15:55.040
because this blocking model can really kill the concurrency.


01:15:55.040 --> 01:15:58.040
Right? So they end up doing optimistic concurrency


01:15:58.040 --> 01:16:00.540
with these types of revisions anyway.


01:16:00.540 --> 01:16:03.340
It's just, so I think it's a really cool pattern.


01:16:03.340 --> 01:16:04.180
I love it.


01:16:04.180 --> 01:16:08.180
- Yeah, it is great.


01:16:08.180 --> 01:16:09.020
It's great.


01:16:09.020 --> 01:16:11.340
It's a bit, it's not my idea, but it's great.


01:16:11.340 --> 01:16:12.660
- Yeah, it's really good.


01:16:12.660 --> 01:16:15.700
It's also, I guess, worth discussing,


01:16:15.700 --> 01:16:19.140
like set and increment and those types of things.


01:16:19.140 --> 01:16:23.700
So if I say, like, I wanna add a category to a product,


01:16:23.700 --> 01:16:27.380
I could do like add to set on that thing and pass the,


01:16:27.380 --> 01:16:30.880
just put this thing in its category list.


01:16:30.880 --> 01:16:34.020
Will that also increment the revision?


01:16:34.020 --> 01:16:39.380
- So only set, I think, yeah.


01:16:39.380 --> 01:16:40.220
- Okay.


01:16:40.220 --> 01:16:41.800
- Because if you will use like internal methods


01:16:41.800 --> 01:16:44.260
of MongoDB, it will not understand that


01:16:44.260 --> 01:16:46.680
it needs to update another field.


01:16:46.680 --> 01:16:48.340
- Got it, okay.


01:16:48.340 --> 01:16:51.380
Interesting, but yeah, that's a good feature, I like it.


01:16:51.380 --> 01:16:53.260
This is a big release.


01:16:53.260 --> 01:16:54.440
- It's a huge one.


01:16:54.440 --> 01:16:57.060
- Cool.


01:16:57.060 --> 01:16:59.660
Well, we've been talking for a long time.


01:16:59.660 --> 01:17:01.860
As you can tell, I'm very excited about it.


01:17:01.860 --> 01:17:04.100
What else?


01:17:04.100 --> 01:17:04.940
What's coming next?


01:17:04.940 --> 01:17:09.320
- So next I have a big plans also.


01:17:09.320 --> 01:17:12.020
I really like Pydentic.


01:17:12.020 --> 01:17:14.740
I'm a huge fan of Pydentic.


01:17:14.740 --> 01:17:16.240
You can see it.


01:17:16.240 --> 01:17:21.620
But for some cases, Pydentic is a heavy tool.


01:17:21.620 --> 01:17:24.980
And probably, I don't know how I will implement it,


01:17:24.980 --> 01:17:29.980
but I want to add support of native Python data classes


01:17:29.980 --> 01:17:35.200
here or here or to separate it smaller project


01:17:35.200 --> 01:17:37.400
like Binny data classes.


01:17:37.400 --> 01:17:39.680
I don't know yet, but anyway,


01:17:39.680 --> 01:17:44.680
I have planned to add better classes without pedantic there.


01:17:44.680 --> 01:17:49.560
Just with not, let's say, fancy parsing stuff


01:17:49.560 --> 01:17:53.560
without that great validation stuff,


01:17:53.560 --> 01:17:55.040
but it's--


01:17:55.040 --> 01:17:57.520
- Somewhere in between, I just wanna,


01:17:57.520 --> 01:17:59.960
you're just getting dictionaries back, good luck,


01:17:59.960 --> 01:18:01.360
and you're getting Pydantic.


01:18:01.360 --> 01:18:03.640
Somewhere in the middle is you're getting classes back,


01:18:03.640 --> 01:18:05.040
but they don't necessarily,


01:18:05.040 --> 01:18:08.580
they're not as precise as, say, Pydantic.


01:18:08.580 --> 01:18:12.600
- Yeah, I mean, there are cases,


01:18:12.600 --> 01:18:17.560
and people uses Binny with these cases also,


01:18:17.560 --> 01:18:21.080
when you have a lot of JSON,


01:18:21.080 --> 01:18:23.460
huge JSONs as a document,


01:18:23.460 --> 01:18:25.460
and when you parse it on a fetching,


01:18:25.460 --> 01:18:29.620
it gives a lot of time.


01:18:29.620 --> 01:18:30.460
- Yeah.


01:18:30.460 --> 01:18:33.060
- So it takes a lot of time for that, just for parsing.


01:18:33.060 --> 01:18:36.100
And then for encoding back to dictionary


01:18:36.100 --> 01:18:38.240
to store this dictionary.


01:18:38.240 --> 01:18:39.940
- Yeah.


01:18:39.940 --> 01:18:41.460
- It's not, it's not pedantic fault, definitely,


01:18:41.460 --> 01:18:44.540
because pedantic is, again, it's great.


01:18:44.540 --> 01:18:49.260
But I need to avoid this step somehow,


01:18:49.260 --> 01:18:53.860
and probably I will use data classes for this.


01:18:53.860 --> 01:18:55.460
- Sure, they look very similar.


01:18:55.460 --> 01:18:58.540
Another scenario where I find that Pydantic


01:18:58.540 --> 01:19:01.800
is not a good fit is where I might be getting bad data,


01:19:01.800 --> 01:19:04.260
but I don't want it just to be an exception.


01:19:04.260 --> 01:19:07.420
I want to be able to get all the bad data


01:19:07.420 --> 01:19:09.700
and say, here's the three errors that you made


01:19:09.700 --> 01:19:11.500
passing me this data.


01:19:11.500 --> 01:19:13.500
And I'm not going to accept it,


01:19:13.500 --> 01:19:16.500
but here's what you gave me,


01:19:16.500 --> 01:19:18.660
if you're doing like form exchange, right?


01:19:18.660 --> 01:19:21.280
like from an HTML form.


01:19:21.280 --> 01:19:24.800
What you need to do is put the old value back in


01:19:24.800 --> 01:19:28.000
and say that value right there, that's wrong.


01:19:28.000 --> 01:19:32.500
But with Pydantic, if you get the value from the form


01:19:32.500 --> 01:19:35.100
and you try to read it, it's just gonna know it's wrong.


01:19:35.100 --> 01:19:36.960
And you're like, wait, but I need to give it back to them.


01:19:36.960 --> 01:19:39.240
Just don't run away, come back, where'd you go?


01:19:39.240 --> 01:19:40.840
And so there's situations like that


01:19:40.840 --> 01:19:43.800
where you need to kind of keep that exchange going,


01:19:43.800 --> 01:19:46.680
but you still want some sort of,


01:19:46.680 --> 01:19:48.440
you just gotta do the validation yourself.


01:19:48.440 --> 01:19:51.360
But anyway, there's certainly times where Pydantic is,


01:19:51.360 --> 01:19:54.360
as cool as it is, is not the right fit for that situation.


01:19:54.360 --> 01:19:56.680
- Yeah, yeah, I agree, totally, yeah.


01:19:56.680 --> 01:19:58.360
Good example. - Nice.


01:19:58.360 --> 01:19:59.680
Thanks.


01:19:59.680 --> 01:20:03.840
All right, well, Romano, this is a very cool project.


01:20:03.840 --> 01:20:07.120
I've, as you hinted at earlier,


01:20:07.120 --> 01:20:08.560
I've seen it from the beginning,


01:20:08.560 --> 01:20:10.440
at least when you open sourced it,


01:20:10.440 --> 01:20:11.960
and it's really come a long ways.


01:20:11.960 --> 01:20:13.480
It's super compelling.


01:20:13.480 --> 01:20:17.440
It looks like something that I could possibly use


01:20:17.440 --> 01:20:18.680
on my next project.


01:20:18.680 --> 01:20:21.240
I constantly, as many people out there are,


01:20:21.240 --> 01:20:22.640
I'm sure as you are,


01:20:22.640 --> 01:20:24.680
I'm constantly resisting the urge to go,


01:20:24.680 --> 01:20:26.400
you know, I should rewrite that.


01:20:26.400 --> 01:20:28.200
I should rewrite that in fast API


01:20:28.200 --> 01:20:29.900
or I should rewrite that in this.


01:20:29.900 --> 01:20:34.760
I should rewrite my Mongo engine stuff with Beanie,


01:20:34.760 --> 01:20:36.760
but you know, maybe one day I'll break down and do it.


01:20:36.760 --> 01:20:37.580
It'd be fun.


01:20:37.580 --> 01:20:39.600
- Yeah.


01:20:39.600 --> 01:20:40.440
Thank you.


01:20:40.440 --> 01:20:41.840
Thank you.


01:20:41.840 --> 01:20:43.600
- Yeah, very cool.


01:20:43.600 --> 01:20:46.120
So nice work on this project.


01:20:46.120 --> 01:20:48.320
You're looking for contributors and PR, would you be,


01:20:48.320 --> 01:20:53.320
PRs, would you be happy to have people make contributions?


01:20:53.320 --> 01:20:55.480
- I make a bunch of issues now.


01:20:55.480 --> 01:21:00.480
A lot of people found something doesn't fit


01:21:00.480 --> 01:21:05.320
to different use cases.


01:21:05.320 --> 01:21:07.080
And so, yes, it would be great


01:21:07.080 --> 01:21:09.440
to have other contributors here.


01:21:09.440 --> 01:21:14.040
I already have like 15 contributors.


01:21:14.040 --> 01:21:14.880
- Nice, yeah.


01:21:14.880 --> 01:21:15.720
Yeah, that's why.


01:21:15.720 --> 01:21:18.960
- Quite a few people in the sidebar there.


01:21:18.960 --> 01:21:20.000
- Each one is a hero.


01:21:20.000 --> 01:21:21.040
(laughing)


01:21:21.040 --> 01:21:21.880
- That's awesome.


01:21:21.880 --> 01:21:24.360
- Yeah. - Cool.


01:21:24.360 --> 01:21:26.400
- But I need more, more and more.


01:21:26.400 --> 01:21:27.720
(laughing)


01:21:27.720 --> 01:21:29.200
And especially for documentation,


01:21:29.200 --> 01:21:34.200
because I really much better in Python than in English.


01:21:34.200 --> 01:21:36.200
(laughing)


01:21:36.200 --> 01:21:40.280
And documentation is my weak point.


01:21:40.280 --> 01:21:41.280
- Okay, cool.


01:21:41.280 --> 01:21:43.960
Well, definitely a neat project.


01:21:43.960 --> 01:21:45.800
So thank you for building it.


01:21:45.800 --> 01:21:46.920
Now, before you get out of here,


01:21:46.920 --> 01:21:49.800
you have to answer the final two questions.


01:21:49.800 --> 01:21:52.160
If you're gonna write some Python code,


01:21:52.160 --> 01:21:53.700
what editor are you using these days?


01:21:53.700 --> 01:21:56.300
What did you use to create Beanie with, for example?


01:21:56.300 --> 01:21:58.980
- I'm using Pesharm.


01:21:58.980 --> 01:22:04.780
JetBrains also gave me ProVersion for Beanie


01:22:04.780 --> 01:22:08.280
as a support program, I think.


01:22:08.280 --> 01:22:10.760
- Yeah, fantastic.


01:22:10.760 --> 01:22:12.360
- It's a really great tool.


01:22:12.360 --> 01:22:17.360
I'm expecting new one, I don't remember the name of,


01:22:17.360 --> 01:22:22.360
but they have new idea.


01:22:22.360 --> 01:22:24.080
I don't remember the name.


01:22:24.080 --> 01:22:25.080
Fleet, Fleet, yeah.


01:22:25.080 --> 01:22:27.640
- Yeah, I was about to mention Fleet.


01:22:27.640 --> 01:22:28.680
Fleet is interesting.


01:22:28.680 --> 01:22:32.760
Fleet is like JetBrains response to VS Code.


01:22:32.760 --> 01:22:33.600
- Yeah.


01:22:33.600 --> 01:22:36.000
- I'm pretty excited about it.


01:22:36.000 --> 01:22:37.800
You know, I really love PyCharm.


01:22:37.800 --> 01:22:41.400
Nobody's gonna be surprised that I say that.


01:22:41.400 --> 01:22:43.360
But if I've got just one file,


01:22:43.360 --> 01:22:44.840
like I'm gonna open that in VS code


01:22:44.840 --> 01:22:49.200
because all the JetBrains IDE tools,


01:22:49.200 --> 01:22:50.800
they expect like a project


01:22:50.800 --> 01:22:52.000
and they're gonna create all these things.


01:22:52.000 --> 01:22:53.480
I'm like, I just wanna look at the files,


01:22:53.480 --> 01:22:55.580
just the files, please, like just not too much.


01:22:55.580 --> 01:22:58.480
And this is kind of like that


01:22:58.480 --> 01:23:01.120
where you can later turn on some of the IDE features, right?


01:23:01.120 --> 01:23:02.200
It looks pretty cool.


01:23:02.200 --> 01:23:04.240
You're gonna try it out?


01:23:04.240 --> 01:23:06.720
- Not yet, I asked for it,


01:23:06.720 --> 01:23:09.280
but so JetBrains, if you hear me, please.


01:23:09.280 --> 01:23:11.080
- Yes, exactly JetBrains.


01:23:11.080 --> 01:23:12.940
I'm already on the early access list too.


01:23:12.940 --> 01:23:14.620
And I have an email.


01:23:14.620 --> 01:23:15.940
Maybe I haven't checked it this morning.


01:23:15.940 --> 01:23:17.120
Maybe it's there.


01:23:17.120 --> 01:23:21.860
Fantastic.


01:23:21.860 --> 01:23:23.840
All right.


01:23:23.840 --> 01:23:26.320
So PyCharm, maybe fleet in the future potentially.


01:23:26.320 --> 01:23:27.160
- Cool.


01:23:27.160 --> 01:23:29.100
- And then notable PyPI package.


01:23:29.100 --> 01:23:32.140
I mean, we've talked about a bunch of libraries already.


01:23:32.140 --> 01:23:32.960
- Yeah.


01:23:32.960 --> 01:23:34.280
So I really like one.


01:23:34.280 --> 01:23:38.140
It's not about identical fast API stuff,


01:23:38.140 --> 01:23:43.140
but I really, it's a great package called Yarl, Y-A-R-L.


01:23:43.140 --> 01:23:47.700
Yeah, it's like,


01:23:47.700 --> 01:23:58.460
it's like a pass library, but for URLs and it's great.


01:23:58.460 --> 01:24:03.060
You can combine strings with this URL stuff together


01:24:03.060 --> 01:24:05.060
and you can parse it, you can--


01:24:05.060 --> 01:24:06.620
- Oh, that's cool.


01:24:06.620 --> 01:24:08.920
- Yeah, so you can pass it a URL as a string,


01:24:08.920 --> 01:24:10.140
just like whatever you'd expect,


01:24:10.140 --> 01:24:11.780
but then you can say, give me the scheme,


01:24:11.780 --> 01:24:15.020
which is like HTTP, HTTPS, the host,


01:24:15.020 --> 01:24:16.860
the path, the query string.


01:24:16.860 --> 01:24:22.020
- I really like how they use this divide operator.


01:24:22.020 --> 01:24:25.380
You probably see in the bottom of your page now,


01:24:25.380 --> 01:24:28.020
like URL divide, full divide bar.


01:24:28.020 --> 01:24:28.860
- Oh, interesting.


01:24:28.860 --> 01:24:31.500
It's like Pathlib style.


01:24:31.500 --> 01:24:32.420
- It's like Pathlib, yeah.


01:24:32.420 --> 01:24:34.620
It's like Pathlib for URLs.


01:24:35.620 --> 01:24:37.920
and it's super great.


01:24:37.920 --> 01:24:40.260
- All right, this is totally new to me, awesome.


01:24:40.260 --> 01:24:42.100
Good recommendation, good recommendation.


01:24:42.100 --> 01:24:44.060
- Yeah, I use it in each project now.


01:24:44.060 --> 01:24:47.820
I don't know how to live without this.


01:24:47.820 --> 01:24:50.260
- All right, well, I'm gonna check it out for sure.


01:24:50.260 --> 01:24:53.100
One quick follow up from the audience here.


01:24:53.100 --> 01:24:54.900
Mario says, "Thank you for this project.


01:24:54.900 --> 01:24:58.160
"I'm about to launch my fast API Beanie blog soon.


01:24:58.160 --> 01:24:59.900
"Couldn't have done it without it."


01:24:59.900 --> 01:25:02.500
- Thank you.


01:25:02.500 --> 01:25:04.100
- Yeah, and Ollie's on it.


01:25:04.100 --> 01:25:07.180
He says, "Pathlibs for URLs."


01:25:07.180 --> 01:25:09.580
Indeed, it's Pathlib for URLs.


01:25:09.580 --> 01:25:10.740
Cool, that's a great one.


01:25:10.740 --> 01:25:12.420
All right, final call to action.


01:25:12.420 --> 01:25:13.860
People wanna get started with Beanie.


01:25:13.860 --> 01:25:14.700
What do you say?


01:25:14.700 --> 01:25:20.120
- I would say, have fun.


01:25:20.120 --> 01:25:22.500
(both laughing)


01:25:22.500 --> 01:25:23.340
- Awesome.


01:25:23.340 --> 01:25:26.900
Yeah, I would recommend that people go and check out the,


01:25:26.900 --> 01:25:28.500
if you go to the documentation,


01:25:28.500 --> 01:25:31.860
there's a tutorial that walks you through this pretty well,


01:25:33.340 --> 01:25:34.400
right there on the left.


01:25:34.400 --> 01:25:36.400
It just starts by defining a document


01:25:36.400 --> 01:25:38.100
and then initialization and so on.


01:25:38.100 --> 01:25:43.120
- Yeah, yeah, we try to do this as much simple


01:25:43.120 --> 01:25:45.400
to understand as possible.


01:25:45.400 --> 01:25:46.520
- Fantastic.


01:25:46.520 --> 01:25:49.000
All right, Roman, thank you for being here.


01:25:49.000 --> 01:25:51.480
- Thank you very much for being here.


01:25:51.480 --> 01:25:53.320
- Yeah, absolutely.


01:25:53.320 --> 01:25:55.240
Everyone out watching this on YouTube,


01:25:55.240 --> 01:25:56.320
thank you so much for being here.


01:25:56.320 --> 01:25:58.320
All of you who asked questions, that was really great.


01:25:58.320 --> 01:26:00.600
And if you enjoyed it, be sure to like the video


01:26:00.600 --> 01:26:02.160
and subscribe to hear about more.


01:26:02.160 --> 01:26:03.000
See you.


01:26:03.000 --> 01:26:04.440
See you!

