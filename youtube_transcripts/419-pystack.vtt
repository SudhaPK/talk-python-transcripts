WEBVTT

00:00:00.000 --> 00:00:07.000
- Hey, Pablo. Hey, Matt. - Hello.


00:00:07.000 --> 00:00:16.320
- Great to have you both here. I'm very excited to talk about some cool tools that give us


00:00:16.320 --> 00:00:21.000
a nice internal look inside of our Python apps.


00:00:21.000 --> 00:00:25.200
- Yeah, I'm really excited to talk about these tools as well.


00:00:25.200 --> 00:00:28.880
- Yeah, it sounds like you've been working on them for a couple of years, you two, and


00:00:28.880 --> 00:00:32.440
especially Pablo and it's going to be great.


00:00:32.440 --> 00:00:37.440
So that's looking at sort of debugging Python apps


00:00:37.440 --> 00:00:40.720
and even Python apps that have crashed,


00:00:40.720 --> 00:00:42.840
which is really, really fantastic.


00:00:42.840 --> 00:00:44.520
Maybe some profiling as well.


00:00:44.520 --> 00:00:47.680
- Maybe crashing apps is not that fantastic, brother.


00:00:47.680 --> 00:00:48.760
(laughs)


00:00:48.760 --> 00:00:50.160
But debugging them maybe.


00:00:50.160 --> 00:00:51.040
- Right.


00:00:51.040 --> 00:00:51.880
- Exactly.


00:00:51.880 --> 00:00:52.720
I'm so excited my app crashed


00:00:52.720 --> 00:00:54.720
because I get to use this PyStack tool


00:00:54.720 --> 00:00:55.920
that you all worked on.


00:00:55.920 --> 00:00:57.920
- For a while I actually was


00:00:57.920 --> 00:01:00.000
because that means that I could use it.


00:01:00.000 --> 00:01:02.320
But let's keep that secret.


00:01:02.320 --> 00:01:04.080
- Well, you need test cases, right?


00:01:04.080 --> 00:01:05.520
And you need examples.


00:01:05.520 --> 00:01:07.000
- I was about to say exactly that.


00:01:07.000 --> 00:01:08.760
It's a great way to see if we have any bugs.


00:01:08.760 --> 00:01:10.700
It's a great chance to try things out.


00:01:10.700 --> 00:01:15.320
- Meta debugging, if you're trying to debug the debugger.


00:01:15.320 --> 00:01:16.960
- Oh, we have done that for sure.


00:01:16.960 --> 00:01:20.680
- How funny, awesome.


00:01:20.680 --> 00:01:25.440
Well, let's just have a quick round of introductions


00:01:25.440 --> 00:01:29.780
from you guys before we can jump into it.


00:01:29.780 --> 00:01:32.260
- Absolutely, Matt, wanna go first?


00:01:32.260 --> 00:01:34.060
- Sure, I am Matt Wisniewski.


00:01:34.060 --> 00:01:36.940
I'm a senior software engineer at Bloomberg.


00:01:36.940 --> 00:01:40.660
I originally joined in 2009, I think,


00:01:40.660 --> 00:01:43.500
so I've been around for quite a while.


00:01:43.500 --> 00:01:46.180
I work on the Python infrastructure team at Bloomberg,


00:01:46.180 --> 00:01:50.340
so our job is building tools and libraries


00:01:50.340 --> 00:01:52.300
and maintaining the interpreters for use


00:01:52.300 --> 00:01:54.020
by other teams at Bloomberg.


00:01:54.900 --> 00:01:56.580
- Right on, sounds very fun.


00:01:56.580 --> 00:01:57.500
Pablo?


00:01:57.500 --> 00:01:59.860
- Hey, I'm Pablo Alino.


00:01:59.860 --> 00:02:01.260
Apart from working at Bloomer


00:02:01.260 --> 00:02:03.020
in exactly the same things as Matt,


00:02:03.020 --> 00:02:04.700
because he's my coworker,


00:02:04.700 --> 00:02:07.900
I do a bunch of things in the Python community.


00:02:07.900 --> 00:02:11.240
So let me see if I don't miss anything.


00:02:11.240 --> 00:02:13.100
So I'm in the Python team council.


00:02:13.100 --> 00:02:14.940
I think this is my third year.


00:02:14.940 --> 00:02:17.740
I'm also the release manager of 3.10 and 3.11.


00:02:17.740 --> 00:02:19.660
3.10 is going into security fixes,


00:02:19.660 --> 00:02:21.440
and today I actually need to do the last one.


00:02:21.440 --> 00:02:24.700
So that's kind of exciting, I suppose.


00:02:24.700 --> 00:02:27.260
- You have a 3.10 release coming today?


00:02:27.260 --> 00:02:29.780
- Yes, the 3.12 beta one,


00:02:29.780 --> 00:02:33.180
I think we are also releasing 3.11 and 3.10.


00:02:33.180 --> 00:02:36.540
Like 3.11 is a bug fix, 3.10 is a first security release,


00:02:36.540 --> 00:02:38.180
which means it's source only.


00:02:38.180 --> 00:02:39.740
And it's my first security release as well.


00:02:39.740 --> 00:02:41.860
But I think that makes it easier, hopefully.


00:02:41.860 --> 00:02:44.540
- Yeah, and you were on the podcast before


00:02:44.540 --> 00:02:48.420
talking about the actual release of 3.11


00:02:48.420 --> 00:02:49.380
and that whole process.


00:02:49.380 --> 00:02:51.140
So if people wanna go back and look


00:02:51.140 --> 00:02:54.220
and see that in more detail, that was really fun.


00:02:54.220 --> 00:02:58.020
We broke GitHub, so that's an exciting time


00:02:58.020 --> 00:02:59.140
when we release 3.11.


00:02:59.140 --> 00:03:04.140
So yeah, and I'm also in the Python core team,


00:03:04.140 --> 00:03:08.460
mainly working on the parser and the garbage collector,


00:03:08.460 --> 00:03:12.060
and therefore breaking black auto-formatters a lot


00:03:12.060 --> 00:03:14.820
with new syntax.


00:03:14.820 --> 00:03:17.420
- Yeah, and fastercpython, you can't forget fastercpython.


00:03:17.420 --> 00:03:18.260
- Oh, right, right, right, sorry,


00:03:18.260 --> 00:03:20.900
and I'm collaborating with the fastercpython team as well.


00:03:20.900 --> 00:03:23.980
Yes, sorry, I just see you, I always forget something.


00:03:23.980 --> 00:03:26.020
And as far as community stuff goes,


00:03:26.020 --> 00:03:28.700
I'd be remiss if I didn't mention that I am a moderator


00:03:28.700 --> 00:03:30.100
on the Python Discord, too.


00:03:30.100 --> 00:03:32.780
So if anyone is not a member of Python Discord,


00:03:32.780 --> 00:03:33.780
they should join.


00:03:33.780 --> 00:03:35.380
It's a cool place to hang out.


00:03:35.380 --> 00:03:35.940
>>Awesome.


00:03:35.940 --> 00:03:38.360
Yeah, we'll put a link to that in the show notes as well,


00:03:38.360 --> 00:03:40.260
so people can check that out.


00:03:40.260 --> 00:03:43.580
So you all are busy is what I hear you saying.


00:03:43.580 --> 00:03:45.220
>>Yes.


00:03:45.220 --> 00:03:47.100
>>Yes.


00:03:47.100 --> 00:03:48.460
>>Absolutely.


00:03:48.460 --> 00:03:49.340
All right, excellent.


00:03:49.340 --> 00:03:52.100
- Well, let's maybe set the stage


00:03:52.100 --> 00:03:55.840
for talking about PyStack here.


00:03:55.840 --> 00:04:01.540
The first thing I wanna talk about is just what,


00:04:01.540 --> 00:04:03.340
well, hold on, I do wanna point out,


00:04:03.340 --> 00:04:06.180
you said you both work on the infrastructure team


00:04:06.180 --> 00:04:07.260
at Bloomberg.


00:04:07.260 --> 00:04:10.100
I'm not sure people fully appreciate


00:04:10.100 --> 00:04:13.540
how much Python is happening at Bloomberg.


00:04:13.540 --> 00:04:15.660
So maybe we should just give a big picture


00:04:15.660 --> 00:04:18.460
because it's germane to this conversation,


00:04:18.460 --> 00:04:22.860
PySnack and other tools like Memray, which we may get a chance to talk about if we have time.


00:04:22.860 --> 00:04:31.180
Those are coming out of supporting this large community. And I got a sense of how big Python


00:04:31.180 --> 00:04:38.380
is at Bloomberg when there were 60 engineers from Bloomberg at PyCon and everybody's booth


00:04:38.380 --> 00:04:44.220
duty was measured in minutes. - Right, right. And they didn't copy paste the same engineer 60 times.


00:04:45.580 --> 00:04:50.580
Yeah, it's quite wild. So I can start if you want.


00:04:50.580 --> 00:04:53.880
It's very interesting, actually, that you point this out,


00:04:53.880 --> 00:04:56.880
because Bloomberg, being a very old company,


00:04:56.880 --> 00:04:58.880
you know, when people talk about legacy,


00:04:58.880 --> 00:05:02.380
and it's like, "Oh, we have legacy because we have this Python 2.7 script."


00:05:02.380 --> 00:05:08.080
Well, just you should see what a company that started in the '70s can do about that.


00:05:08.080 --> 00:05:10.380
But it used to be a C++ house.


00:05:10.380 --> 00:05:14.080
And when I started, actually, the main language were C++


00:05:14.080 --> 00:05:17.280
and JavaScript for the front end in Bloomberg terminal.


00:05:17.280 --> 00:05:22.480
And now we are actually, I think I'm, if I'm not mistaken, Matt can correct me,


00:05:22.480 --> 00:05:25.420
but I think we can say probably that now we have Python house


00:05:25.420 --> 00:05:27.620
because I think we just surpassed for the first time


00:05:27.620 --> 00:05:31.160
the amount of lines of Python compared with C++.


00:05:31.160 --> 00:05:36.400
And if that's not true, it's mostly there, which is quite exciting.


00:05:36.400 --> 00:05:38.800
At the point where I joined the company,


00:05:38.800 --> 00:05:41.500
we had onboarding training for juniors


00:05:41.500 --> 00:05:45.820
that included a Fortran for C programmers section.


00:05:45.820 --> 00:05:48.740
And at this point, we have a C++ for Python programmers


00:05:48.740 --> 00:05:49.620
section instead.


00:05:49.620 --> 00:05:54.420
So that's how much it's changed over the last decade or so.


00:05:54.420 --> 00:05:55.380
>> Wow, that's incredible.


00:05:55.380 --> 00:05:58.100
>> That's what I mean, the C++ is now legacy.


00:05:58.100 --> 00:06:00.980
Who said that?


00:06:00.980 --> 00:06:02.620
Certainly not me.


00:06:02.620 --> 00:06:04.220
The steering council member says that.


00:06:04.220 --> 00:06:06.700
[LAUGHTER]


00:06:06.700 --> 00:06:07.900
OK, so yeah.


00:06:07.900 --> 00:06:09.220
But this is interesting.


00:06:09.220 --> 00:06:11.620
and this goes into the tool itself.


00:06:11.620 --> 00:06:14.760
I think this is an interesting scenario


00:06:14.760 --> 00:06:17.820
because that C++ didn't went away.


00:06:17.820 --> 00:06:20.760
Among other things, because it's not legacy,


00:06:20.760 --> 00:06:23.300
Python is not the fastest language on the planet,


00:06:23.300 --> 00:06:24.520
although we are trying to make it fast,


00:06:24.520 --> 00:06:26.640
but certainly we are not trying to make it compete


00:06:26.640 --> 00:06:27.480
with C++.


00:06:27.480 --> 00:06:31.120
So that C++ is both there and needed


00:06:31.120 --> 00:06:34.160
because you cannot just do everything in Python, for sure.


00:06:34.160 --> 00:06:36.280
So the situation that we have at Bloomberg,


00:06:36.280 --> 00:06:38.560
which is served by many other big companies,


00:06:38.560 --> 00:06:42.960
and finance companies as well, is that we have a lot of C++ under that Python.


00:06:42.960 --> 00:06:46.880
So, the... Well, C++ by itself, but let's talk about the actual part


00:06:46.880 --> 00:06:48.400
that is interesting for Python.


00:06:48.400 --> 00:06:51.840
So, you can write a lot of pure Python scripts, right?


00:06:51.840 --> 00:06:56.280
But what most people, or companies, does is write some Python


00:06:56.280 --> 00:07:01.840
and 99% of the time, it ends up reaching some C++ underneath.


00:07:01.840 --> 00:07:05.360
And this is not just because they are using NumPy or Pandas


00:07:05.360 --> 00:07:08.800
or any of these compile very common scenarios as well,


00:07:08.800 --> 00:07:11.260
but also because they are using Bloomberg code underneath,


00:07:11.260 --> 00:07:13.900
which happens to be written in C++.


00:07:13.900 --> 00:07:19.340
And this means that now we have a huge community of people


00:07:19.340 --> 00:07:21.980
that need to be aware of both languages at the same time.


00:07:21.980 --> 00:07:24.480
So you have Python programmers that need to be aware of C++,


00:07:24.480 --> 00:07:28.280
as well as C++ programmers that need to be aware of Python,


00:07:28.280 --> 00:07:31.080
either because they just happen to switch to Python


00:07:31.080 --> 00:07:34.520
or because they use Python to run tests or things like that.


00:07:34.520 --> 00:07:37.320
So it's a very interesting scenario.


00:07:37.320 --> 00:07:40.880
>> Yeah, and I imagine, leading up to this conversation,


00:07:40.880 --> 00:07:45.320
if something goes wrong, you might not be entirely sure.


00:07:45.320 --> 00:07:47.120
Is it the Python code?


00:07:47.120 --> 00:07:48.480
Is it the C++ code?


00:07:48.480 --> 00:07:51.200
Is it the interaction of these things?


00:07:51.200 --> 00:07:52.920
Right? That can make it tricky.


00:07:52.920 --> 00:07:56.280
>> And this is quite, what you point out is basically,


00:07:56.280 --> 00:07:59.880
among all the things, one of the things that make us work


00:07:59.880 --> 00:08:02.200
on this in the first place, because what happened normally


00:08:02.200 --> 00:08:04.960
is that when an application, one of these applications


00:08:04.960 --> 00:08:08.360
is hybrid crash at Bloomberg, we used to have this,


00:08:08.360 --> 00:08:12.080
many companies does this, I mean, I assume all of them,


00:08:12.080 --> 00:08:14.400
but what happened is that when an application crashes,


00:08:14.400 --> 00:08:16.760
we either get a core file, right,


00:08:16.760 --> 00:08:20.160
which is this kind of like file that is dumped by the kernel


00:08:20.160 --> 00:08:22.660
with all the memory dump of the process


00:08:22.660 --> 00:08:25.920
and a bunch of information, and you can analyze it later,


00:08:25.920 --> 00:08:29.120
or a debugger basically attaches to the process


00:08:29.120 --> 00:08:30.520
and shows you the backtrace.


00:08:30.520 --> 00:08:32.860
But the problem is that this debugger was GDB,


00:08:32.860 --> 00:08:34.920
which means that the backtrace that you get


00:08:34.920 --> 00:08:38.760
is a C backtrace, it's not a Python backtrace, right?


00:08:38.760 --> 00:08:41.300
And the backtrace is useless for everyone.


00:08:41.300 --> 00:08:43.640
So it's like, it doesn't matter if you're a C++ programmer


00:08:43.640 --> 00:08:45.800
or you're a Python programmer, it's always useless.


00:08:45.800 --> 00:08:47.300
It's useless for Python programmers


00:08:47.300 --> 00:08:49.440
because you see C functions,


00:08:49.440 --> 00:08:51.560
and like a Python programmer normally is like,


00:08:51.560 --> 00:08:52.400
what is this?


00:08:52.400 --> 00:08:53.840
Like, what is that register, right?


00:08:53.840 --> 00:08:55.340
Well, on the other hand,


00:08:55.340 --> 00:08:57.240
it's also useless for C++ programmers


00:08:57.240 --> 00:08:59.440
because the function that evaluates Python code,


00:08:59.440 --> 00:09:01.480
which is called PyEvalEvalFrameDefault,


00:09:01.480 --> 00:09:05.440
is repeated 600 times, and it doesn't make any sense.


00:09:05.440 --> 00:09:08.160
Not only they also expect to see their Python code,


00:09:08.160 --> 00:09:10.280
but now their C++ code is just buried


00:09:10.280 --> 00:09:12.080
among this mysterious code.


00:09:12.080 --> 00:09:15.000
So nobody could make sense of what's going on,


00:09:15.000 --> 00:09:17.600
which means that for a long time,


00:09:17.600 --> 00:09:19.440
when a Python application crashed at Bloomberg,


00:09:19.440 --> 00:09:21.720
and we're talking crash here as like hard crash,


00:09:21.720 --> 00:09:25.320
like segfault, which is common in C++ segfaults,


00:09:25.320 --> 00:09:28.040
or sometimes even Python can segfault, right?


00:09:28.040 --> 00:09:29.040
In some situations.


00:09:29.040 --> 00:09:32.220
So obviously, a Python exception is reported as a Python exception.


00:09:32.220 --> 00:09:34.740
We are not talking that our system picked GDB.


00:09:34.740 --> 00:09:37.360
If a Python exception is raised, obviously, that is fine.


00:09:37.360 --> 00:09:41.480
It's when this kind of hybrid setup crashes very deeply,


00:09:41.480 --> 00:09:43.860
either because Python crashes or because NumPy crashes


00:09:43.860 --> 00:09:45.360
or because the Bloomberg code crashes.


00:09:45.360 --> 00:09:49.360
So in those cases, nobody could make sense of what's going on


00:09:49.360 --> 00:09:54.160
because the backtracing is useless by itself.


00:09:54.880 --> 00:09:56.640
And not just crashes.


00:09:56.640 --> 00:10:02.200
I'd add that it's also a problem for deadlocks as well.


00:10:02.200 --> 00:10:06.360
One of the big differences between Python and C++,


00:10:06.360 --> 00:10:07.960
they've got very different models


00:10:07.960 --> 00:10:10.760
for how they represent the lifetimes of objects


00:10:10.760 --> 00:10:11.720
and things like that.


00:10:11.720 --> 00:10:13.920
You can very easily get into a situation


00:10:13.920 --> 00:10:22.160
where a C++ object that is owned by a Python object


00:10:22.160 --> 00:10:27.160
in our hybrid work environment is trying to communicate


00:10:27.160 --> 00:10:29.600
with a background thread to, I don't know,


00:10:29.600 --> 00:10:31.440
tell it to stop or something like that.


00:10:31.440 --> 00:10:32.960
But that background thread winds up needing


00:10:32.960 --> 00:10:34.480
to pick up the GIL for some reason.


00:10:34.480 --> 00:10:37.680
And if you have the foreground thread still holding the gill,


00:10:37.680 --> 00:10:39.080
you've just introduced a deadlock.


00:10:39.080 --> 00:10:41.860
And it's very difficult to track that down


00:10:41.860 --> 00:10:44.080
if the only tool at your disposal is GDB


00:10:44.080 --> 00:10:47.280
and you can't easily see what Python stuff is being called.


00:10:47.280 --> 00:10:51.300
- Yeah, and Python, oh, sorry, C++ multithreading


00:10:51.300 --> 00:10:54.100
is like critical sections and locks,


00:10:54.100 --> 00:10:56.300
and it's really explicit.


00:10:56.300 --> 00:10:59.300
You enter a lock, you exit a lock,


00:10:59.300 --> 00:11:01.260
and Python has that as well.


00:11:01.260 --> 00:11:04.380
But in addition, it just has this implicit gill


00:11:04.380 --> 00:11:05.660
that you're talking about, right?


00:11:05.660 --> 00:11:08.860
And that throws a whole nother layer


00:11:08.860 --> 00:11:11.300
of potential deadlocks in there that I imagine


00:11:11.300 --> 00:11:12.420
is pretty tricky.


00:11:12.420 --> 00:11:14.900
- And some of them are not only difficult to spot,


00:11:14.900 --> 00:11:16.540
but it's very difficult to reason about


00:11:16.540 --> 00:11:19.300
just because most of these things are implicit.


00:11:19.300 --> 00:11:23.540
It's so difficult actually that even if you go to some popular tools in the wild, they


00:11:23.540 --> 00:11:27.740
don't handle all the S cases because it's quite hardcore.


00:11:27.740 --> 00:11:32.900
The fact that you can just request the gil in the middle of, for instance, I don't know


00:11:32.900 --> 00:11:39.940
if we will end talking about memory profilers here, but most memory profilers that are measuring


00:11:39.940 --> 00:11:45.340
like native allocations in Python and C++, they need to see the Python stack somehow.


00:11:45.340 --> 00:11:48.020
When an allocation is made, you say, "Oh, give me some memory."


00:11:48.020 --> 00:11:49.700
you need to say who called this function.


00:11:49.700 --> 00:11:52.100
And then you need to see both the C sometimes,


00:11:52.100 --> 00:11:53.860
or you only call Python, you just need to say,


00:11:53.860 --> 00:11:55.500
okay, what is the Python stack trace, right?


00:11:55.500 --> 00:11:57.940
Like an exception, but like, who called this function?


00:11:57.940 --> 00:11:59.460
And for that, you need the gil.


00:11:59.460 --> 00:12:01.060
So you need to say, give me the gil,


00:12:01.060 --> 00:12:02.100
and then I will print the stack.


00:12:02.100 --> 00:12:04.620
But like sometimes, one of the situations


00:12:04.620 --> 00:12:07.620
that Matt is describing will introduce a dialogue.


00:12:07.620 --> 00:12:09.260
It's very, very rare situations,


00:12:09.260 --> 00:12:12.220
but it's the kind of situations that will involve threads


00:12:12.220 --> 00:12:14.820
and like, you know, specific things.


00:12:14.820 --> 00:12:18.120
which means that it will happen very, very rarely,


00:12:18.120 --> 00:12:20.580
but it will happen, or it can happen.


00:12:20.580 --> 00:12:23.300
So it's both going to be rare to debug


00:12:23.300 --> 00:12:26.100
because this person who's going to appear


00:12:26.100 --> 00:12:28.700
when the moon is high and Wednesday,


00:12:28.700 --> 00:12:33.300
so he's going to say, "Well, only in this case is the deck looks."


00:12:33.300 --> 00:12:36.100
And it's going to be very difficult to fix as well


00:12:36.100 --> 00:12:37.780
because now you cannot just have the Guild,


00:12:37.780 --> 00:12:40.980
so you need a complete redesign sometimes.


00:12:40.980 --> 00:12:44.140
So it can be very challenging to fix, to find,


00:12:44.140 --> 00:12:46.420
and to debug as well.


00:12:46.420 --> 00:12:48.460
- Those situations are so tricky.


00:12:48.460 --> 00:12:53.260
You know, they often get the term Heisenbugs


00:12:53.260 --> 00:12:58.260
to indicate kind of the quantum mechanical uncertainty.


00:12:58.260 --> 00:13:00.800
It could be in some state, but if you measure it,


00:13:00.800 --> 00:13:02.900
then it's in a different state.


00:13:02.900 --> 00:13:04.580
How do you actually track these down?


00:13:04.580 --> 00:13:07.720
And they happen a lot of times in production,


00:13:07.720 --> 00:13:10.820
but only under heavy load after like 12 hours.


00:13:10.820 --> 00:13:13.700
So how do you use normal debugging techniques


00:13:13.700 --> 00:13:14.700
to step through that?


00:13:14.700 --> 00:13:16.700
All these things are really, really tricky.


00:13:16.700 --> 00:13:17.700
But it sounds like--


00:13:17.700 --> 00:13:19.700
- And they're also-- - Okay.


00:13:19.700 --> 00:13:21.200
- They are very also interesting as well.


00:13:21.200 --> 00:13:23.700
We can certainly discuss exactly what you just said


00:13:23.700 --> 00:13:25.200
because it's spot on.


00:13:25.200 --> 00:13:28.200
And one of the reasons here is that, as you mentioned,


00:13:28.200 --> 00:13:30.200
the moment you touch a debugger,


00:13:30.200 --> 00:13:32.700
because the debugging process normally slows down the code,


00:13:32.700 --> 00:13:35.200
means that reproducing the dialogue may be harder.


00:13:35.200 --> 00:13:38.200
So sometimes the only way to properly debug this thing


00:13:38.200 --> 00:13:41.000
is letting it crash without the debugger,


00:13:41.000 --> 00:13:43.500
producing a core file and then analyzing the core file.


00:13:43.500 --> 00:13:45.500
But because the core file is dead,


00:13:45.500 --> 00:13:48.900
I mean, it's basically a dump, you cannot call functions now,


00:13:48.900 --> 00:13:51.200
then GDB can be useless


00:13:51.200 --> 00:13:54.400
if you don't know how to use certain tools.


00:13:54.400 --> 00:13:56.400
So PyStack actually is very useful here as well


00:13:56.400 --> 00:13:59.900
because you can reproduce the deadlock at full speed,


00:13:59.900 --> 00:14:02.500
generating a core or letting it crash,


00:14:02.500 --> 00:14:05.400
and then use PyStack. But we can talk about that later.


00:14:05.400 --> 00:14:06.860
Or maybe you don't know that you're


00:14:06.860 --> 00:14:08.360
trying to reproduce a deadlock.


00:14:08.360 --> 00:14:09.600
[INTERPOSING VOICES]


00:14:09.600 --> 00:14:13.360
And you're like, it won't respond,


00:14:13.360 --> 00:14:16.880
but the CPU load on the server is zero.


00:14:16.880 --> 00:14:17.380
That--


00:14:17.380 --> 00:14:17.880
>>Right.


00:14:17.880 --> 00:14:18.880
[CHUCKLES]


00:14:18.880 --> 00:14:19.380
>>Right.


00:14:19.380 --> 00:14:21.760
>>Yeah, that sort of-- is it waiting for something,


00:14:21.760 --> 00:14:24.380
or is it ever going to respond, or you just


00:14:24.380 --> 00:14:26.320
don't know what it's doing yet?


00:14:26.320 --> 00:14:28.600
>>Yeah, yeah, exactly.


00:14:28.600 --> 00:14:31.200
Logging will help a little bit, but not--


00:14:31.200 --> 00:14:33.320
you've got to have some pretty intense logging to get


00:14:33.320 --> 00:14:35.640
that level of what's going on.


00:14:35.640 --> 00:14:39.040
And usually you don't want that in production either.


00:14:39.040 --> 00:14:42.800
So let's start our conversation about just the spectrum


00:14:42.800 --> 00:14:46.320
of what the options are out there, Pablo.


00:14:46.320 --> 00:14:50.600
Now, you mentioned GDB,


00:14:50.600 --> 00:14:55.040
but I guess on one side of the spectrum,


00:14:55.040 --> 00:14:59.120
we have PyCharm and VS Code and Friends


00:14:59.120 --> 00:15:01.960
where you press F5 or you press the little debug thing


00:15:01.960 --> 00:15:03.800
and you step through your code.


00:15:03.800 --> 00:15:06.680
And that's helpful when you're actually developing


00:15:06.680 --> 00:15:10.280
your application, but you're talking about


00:15:10.280 --> 00:15:12.600
running a production or running applications


00:15:12.600 --> 00:15:15.640
or applications that have crashed and here's a core file.


00:15:15.640 --> 00:15:20.720
Those are not exactly the same situation, are they?


00:15:20.720 --> 00:15:24.200
- Right, so we are talking about the specific case.


00:15:24.200 --> 00:15:27.000
We are sending ourselves into many scenarios,


00:15:27.000 --> 00:15:28.800
although you can certainly use it in others,


00:15:28.800 --> 00:15:31.360
but just to have a good mental model


00:15:31.360 --> 00:15:33.840
over what these tools are going to be useful for


00:15:33.840 --> 00:15:38.200
and what are they different from PDB or VS Code, right?


00:15:38.200 --> 00:15:40.200
We're talking about things that crash


00:15:40.200 --> 00:15:42.640
and crash like hard crash, like, you know,


00:15:42.640 --> 00:15:44.240
or things that are frozen.


00:15:44.240 --> 00:15:45.920
It could be a deadlock, but it could be also


00:15:45.920 --> 00:15:47.720
that your application is waiting for something


00:15:47.720 --> 00:15:51.080
and it never arrives and you want to know what is going on.


00:15:51.080 --> 00:15:53.960
And specifically when these tools


00:15:53.960 --> 00:15:55.920
are going to become even more useful


00:15:55.920 --> 00:15:59.880
is when this code involves C++ or C code or RAS code,


00:15:59.880 --> 00:16:02.400
for that matter, so some native code, right?


00:16:02.400 --> 00:16:04.000
And the reason this is going to be more useful


00:16:04.000 --> 00:16:06.440
is because PDB or VS Code, the buyer,


00:16:06.440 --> 00:16:09.240
or PyCharm normally attach Python to the buyers,


00:16:09.240 --> 00:16:10.460
which means that these buyers


00:16:10.460 --> 00:16:12.520
only know about the Python world,


00:16:12.520 --> 00:16:14.160
and that normally is insufficient


00:16:14.160 --> 00:16:17.520
because you want to see both worlds at the same time.


00:16:17.520 --> 00:16:19.280
And this is going to become very critical.


00:16:19.280 --> 00:16:22.120
You don't want to be one world and the other separately.


00:16:22.120 --> 00:16:24.200
You want some tool that understands both worlds


00:16:24.200 --> 00:16:27.360
at the same time and can show you what really is happening


00:16:27.360 --> 00:16:29.760
and how this works, like you're entering one word,


00:16:29.760 --> 00:16:31.200
leaving it, but then you're entering again


00:16:31.200 --> 00:16:32.320
or something like that.


00:16:32.320 --> 00:16:33.160
So that is what we are-- - Right, so if you've got


00:16:33.160 --> 00:16:37.200
this mixed code, you know, a Python profiler won't,


00:16:37.200 --> 00:16:39.280
they won't see the steps happening


00:16:39.280 --> 00:16:40.120
below that, right? - Right, so for instance,


00:16:40.120 --> 00:16:42.400
a Bloomberg, a Python profiler will tell you


00:16:42.400 --> 00:16:44.800
that the application, if it's, let's say it's frozen,


00:16:44.800 --> 00:16:46.520
and then you say, you use VS Code,


00:16:46.520 --> 00:16:49.280
it's going to tell you that it's frozen on run,


00:16:49.280 --> 00:16:51.760
a function called run, and then there's 600 layers


00:16:51.760 --> 00:16:54.720
of C++ underneath, which ones you don't know.


00:16:54.720 --> 00:16:59.160
Or, for instance, let's say for mysterious reasons


00:16:59.160 --> 00:17:01.160
that NumPy has a bug or something,


00:17:01.160 --> 00:17:03.160
and then you're adding two NumPy arrays,


00:17:03.160 --> 00:17:05.660
and it's telling you that the addition of the NumPy arrays


00:17:05.660 --> 00:17:07.660
is what is being frozen,


00:17:07.660 --> 00:17:09.960
but you don't know what is happening underneath.


00:17:09.960 --> 00:17:12.560
And then you want to see what's happening


00:17:12.560 --> 00:17:16.300
on the NumPy C++ code, or the SciPy code,


00:17:16.300 --> 00:17:18.300
or the TensorFlow code.


00:17:18.300 --> 00:17:21.400
There are countless examples of heavy C++


00:17:21.400 --> 00:17:23.680
or compile code underneath.


00:17:23.680 --> 00:17:26.780
Like for instance, Pythontic these days is running on Rust,


00:17:26.780 --> 00:17:29.080
which means that if something goes wrong there,


00:17:29.080 --> 00:17:31.820
or it just crashes or is freezing or whatever,


00:17:31.820 --> 00:17:33.420
you're going to not see it either, right?


00:17:33.420 --> 00:17:36.480
So we are talking about those cases.


00:17:36.480 --> 00:17:38.020
- Right.


00:17:38.020 --> 00:17:43.020
- We've seen deadlocks on the GC-Dell


00:17:43.020 --> 00:17:47.260
of a object that's defined in an extension module.


00:17:47.260 --> 00:17:48.860
And when that happens, all the Python debugger


00:17:48.860 --> 00:17:50.800
is gonna tell you is absolutely nothing.


00:17:50.800 --> 00:17:54.160
It doesn't see the call into the tpdel method.


00:17:54.160 --> 00:17:56.160
It doesn't see...


00:17:56.160 --> 00:17:59.540
All it shows you is that there is a variable that's going out of scope


00:17:59.540 --> 00:18:01.540
or being reassigned or something like that


00:18:01.540 --> 00:18:04.040
on the last Python line that was run,


00:18:04.040 --> 00:18:07.140
and anything happening under that is just totally opaque to it.


00:18:07.140 --> 00:18:08.640
Right.


00:18:08.640 --> 00:18:11.440
On the other hand, just talking about the other tools,


00:18:11.440 --> 00:18:13.440
on the other hand, things like GDB


00:18:13.440 --> 00:18:15.440
have the same problem that we're talking about.


00:18:15.440 --> 00:18:17.440
GDB only understands C code.


00:18:17.440 --> 00:18:19.440
So what it's going to show you is that


00:18:19.440 --> 00:18:23.240
your interpreter is going to show you the NumPy code underneath


00:18:23.240 --> 00:18:25.920
or the C++ code underneath or the Rust code underneath.


00:18:25.920 --> 00:18:29.040
But it's not going to show you the Python code, so you don't know what code that is.


00:18:29.040 --> 00:18:30.540
So this is the other side of the coin.


00:18:30.540 --> 00:18:31.540
You're going to see...


00:18:31.540 --> 00:18:33.040
- There's a lot of C action happening.


00:18:33.040 --> 00:18:35.280
- But how I reach this C, we don't know.


00:18:35.280 --> 00:18:40.080
And the situation when this is really bad is when you kind of enter and exit the C


00:18:40.080 --> 00:18:41.760
realm multiple times, right?


00:18:41.760 --> 00:18:44.640
So you have some Python code that calls some C code, and in turn,


00:18:44.640 --> 00:18:48.240
it calls some Python code again and some C code again.


00:18:48.240 --> 00:18:52.400
So that's really hard because you're going to not see anything.


00:18:52.400 --> 00:18:55.740
It's impossible because you don't know how you reach this situation.


00:18:55.740 --> 00:18:58.780
And that's quite hard.


00:18:58.780 --> 00:19:02.580
The classic debuggers won't be able to do so.


00:19:02.580 --> 00:19:05.260
Interestingly, though, because we are going to see


00:19:05.260 --> 00:19:07.820
that there is some other tools that have some functionality


00:19:07.820 --> 00:19:10.620
close to what PyStack does.


00:19:10.620 --> 00:19:15.700
So in Python, in CPython, we provide some plugins, let's call it.


00:19:15.700 --> 00:19:20.100
It's basically an extension files that you can add to GDB


00:19:20.100 --> 00:19:22.940
that allows you to do some similar things.


00:19:22.940 --> 00:19:28.140
So for instance, the Python files that you can put in GDB


00:19:28.140 --> 00:19:30.140
allows you to pretty print Python objects.


00:19:30.140 --> 00:19:33.540
So even if you're in the C world, you can print some objects.


00:19:33.540 --> 00:19:36.620
And you can also print some kind of Python stack tree.


00:19:36.620 --> 00:19:40.420
So you can ask, "Hey, can you show me what I'm in Python?"


00:19:40.420 --> 00:19:41.660
But it's not a hybrid one.


00:19:41.660 --> 00:19:43.660
So it will only tell you where you're in Python,


00:19:43.660 --> 00:19:46.640
which means that you're going to miss the C version.


00:19:46.640 --> 00:19:49.240
Because this GDB, you can also ask for the C version,


00:19:49.240 --> 00:19:50.760
but you're not going to see them together.


00:19:50.760 --> 00:19:52.680
You're going to see either one or the other.


00:19:52.680 --> 00:19:56.440
And then it's up to you how to merge them,


00:19:56.440 --> 00:20:00.140
which sometimes is very hard because there's very hard rules


00:20:00.140 --> 00:20:02.040
to know how to do that, especially, for instance,


00:20:02.040 --> 00:20:04.720
in Python 3.11 and some of the optimizations


00:20:04.720 --> 00:20:08.400
within the Python 3, in the Fastest in Python project


00:20:08.400 --> 00:20:11.120
means that the same evaluator loop can be reused


00:20:11.120 --> 00:20:13.180
for multiple Python functions.


00:20:13.180 --> 00:20:16.180
So in 3.11, you are not even able to do it


00:20:16.180 --> 00:20:18.180
without extra metadata.


00:20:18.180 --> 00:20:20.680
So it's quite hard.


00:20:20.680 --> 00:20:22.680
And even if these, let's say,


00:20:22.680 --> 00:20:25.420
plugins are actually useful and can get you closer,


00:20:25.420 --> 00:20:27.720
and for a lot of time, that was useful


00:20:27.720 --> 00:20:29.720
and the only way to do that,


00:20:29.720 --> 00:20:31.720
it's difficult for Core files,


00:20:31.720 --> 00:20:34.220
because if you have a Core file, your only option is using DDB


00:20:34.220 --> 00:20:36.220
or WASP before Biostack.


00:20:36.220 --> 00:20:38.220
You could somehow do it.


00:20:38.220 --> 00:20:41.900
The problem is that DDB relies on...


00:20:42.900 --> 00:20:46.240
to do this relies on debugging information inside the core.


00:20:46.240 --> 00:20:48.400
Which means that if you have Python interpreters


00:20:48.400 --> 00:20:50.480
that don't have the right information, which by the way,


00:20:50.480 --> 00:20:55.480
is most Python interpreters that are shipping distributions,


00:20:55.480 --> 00:20:57.520
or most Python interpreters that are used normally


00:20:57.520 --> 00:20:59.980
because you don't want to ship gigantic debugging information


00:20:59.980 --> 00:21:01.100
to production most of the time,


00:21:01.100 --> 00:21:03.040
because this can get really big.


00:21:03.040 --> 00:21:04.900
Means that GDB is not going to work


00:21:04.900 --> 00:21:08.580
because it relies on the fact that it can inspect


00:21:08.580 --> 00:21:11.660
local C variables inside the frames.


00:21:11.660 --> 00:21:14.900
And as many C programmers will tell you,


00:21:14.900 --> 00:21:18.060
is the most common thing that DDB will tell you


00:21:18.060 --> 00:21:19.300
is optimized expression,


00:21:19.300 --> 00:21:22.020
which means that I cannot tell you anything here,


00:21:22.020 --> 00:21:24.460
which means there is no one to work.


00:21:24.460 --> 00:21:25.700
There is ways to make it work,


00:21:25.700 --> 00:21:27.900
but we are entering the expert realm here.


00:21:27.900 --> 00:21:30.780
Like, making DDB kind of work here


00:21:30.780 --> 00:21:33.980
is the kind of like, you need two staff engineers


00:21:33.980 --> 00:21:35.700
and like, or a CPython coder


00:21:35.700 --> 00:21:36.740
that knows what is going on.


00:21:36.740 --> 00:21:40.300
So that's certainly not for your average Python program,


00:21:40.300 --> 00:21:43.820
which let's remember, we are trying to debug something,


00:21:43.820 --> 00:21:45.500
which probably we're under pressure,


00:21:45.500 --> 00:21:49.940
and we don't want to read the main page of GDB and Python


00:21:49.940 --> 00:21:52.900
and how to debug Python with GDB and debugging,


00:21:52.900 --> 00:21:54.620
what is the debugging information?


00:21:54.620 --> 00:21:59.060
So if you're a Python programmer and just want to paste a stack trace


00:21:59.060 --> 00:22:02.180
in a bug report, for instance, because someone asked you to do that,


00:22:02.180 --> 00:22:03.980
or you just want to see what's going on,


00:22:03.980 --> 00:22:06.340
or you just want to tell someone where it's crashing,


00:22:06.340 --> 00:22:08.100
you don't want to learn all of these things,


00:22:08.100 --> 00:22:10.420
You don't even have time. Maybe you need to fix it.


00:22:10.420 --> 00:22:12.420
It's crashing in production.


00:22:12.420 --> 00:22:14.960
You cannot just tell your boss, "Oh, yes, wait here


00:22:14.960 --> 00:22:16.960
until I read the man page of GDB."


00:22:16.960 --> 00:22:18.960
It's not going to happen.


00:22:18.960 --> 00:22:21.500
- I don't know how many people, I imagine a good number,


00:22:21.500 --> 00:22:26.600
but not all of the people listening have had an application


00:22:26.600 --> 00:22:29.220
or an API or something crashing in production


00:22:29.220 --> 00:22:31.860
when people are trying to get to it. It's very stressful.


00:22:31.860 --> 00:22:33.860
- Right.


00:22:33.860 --> 00:22:37.100
- I should add that distributions do generally give you a way


00:22:37.100 --> 00:22:41.060
to get at the debug data for an interpreter.


00:22:41.060 --> 00:22:42.980
It's not as though they strip it off entirely


00:22:42.980 --> 00:22:44.900
and it's gone forever.


00:22:44.900 --> 00:22:47.180
It's just that the way that you get at it after the fact


00:22:47.180 --> 00:22:49.780
is different per distribution.


00:22:49.780 --> 00:22:51.940
And it's not something that necessarily everyone


00:22:51.940 --> 00:22:54.740
who's firing up GDB knows how to do.


00:22:54.740 --> 00:22:56.400
So it's not that it's gone forever.


00:22:56.400 --> 00:22:59.540
It's just that it's not easily accessible to everyone,


00:22:59.540 --> 00:23:00.580
I'd say.


00:23:00.580 --> 00:23:01.420
- Sure.


00:23:01.420 --> 00:23:02.240
- And sometimes it doesn't even--


00:23:02.240 --> 00:23:03.460
- Do you add it afterwards?


00:23:03.460 --> 00:23:05.260
Like if my app crashes and I'm like,


00:23:05.260 --> 00:23:08.260
"Oh, no, I didn't have the debug information."


00:23:08.260 --> 00:23:11.260
You can, actually. It'll either be like on Ubuntu,


00:23:11.260 --> 00:23:15.260
it'll be a Python 3-debug package that you install,


00:23:15.260 --> 00:23:19.260
or there's also a thing called DebugInfoD


00:23:19.260 --> 00:23:22.260
that can download the debug information


00:23:22.260 --> 00:23:25.260
from servers managed by your distribution


00:23:25.260 --> 00:23:28.260
as needed when a debugger requests it,


00:23:28.260 --> 00:23:30.260
which is pretty cool.


00:23:30.260 --> 00:23:32.260
But the problem is that this still doesn't assure you


00:23:32.260 --> 00:23:33.460
that GDB is going to work.


00:23:33.460 --> 00:23:35.180
It's just that it gives you more chances,


00:23:35.180 --> 00:23:38.700
but still, if your Python interpreter is heavily optimized,


00:23:38.700 --> 00:23:40.100
this may be not enough.


00:23:40.100 --> 00:23:43.400
And actually, for the sake of giving data,


00:23:43.400 --> 00:23:45.900
in most distributions, it's actually not enough


00:23:45.900 --> 00:23:49.100
because these variables, particularly the frame variable


00:23:49.100 --> 00:23:51.940
in the Python evaluator loop, is extremely heavily optimized


00:23:51.940 --> 00:23:54.120
among other things because it has to be


00:23:54.120 --> 00:23:56.300
because the Python evaluator loop is very hot path.


00:23:56.300 --> 00:24:00.420
So most of the time, these tools are, let's say, unreliable.


00:24:02.020 --> 00:24:05.980
So let's introduce what PyStack does then,


00:24:05.980 --> 00:24:08.820
and let's talk about also what other tools you can use


00:24:08.820 --> 00:24:10.580
that are not PyStack maybe.


00:24:10.580 --> 00:24:11.860
- Yeah, sure.


00:24:11.860 --> 00:24:14.900
So I think that's probably a good setup for PyStack.


00:24:14.900 --> 00:24:16.520
Like why does it exist?


00:24:16.520 --> 00:24:19.700
Why do people really, why is it such a game changer?


00:24:19.700 --> 00:24:20.540
Right?


00:24:20.540 --> 00:24:25.300
It understands both of these worlds in a really nice way.


00:24:25.300 --> 00:24:26.380
Tell us about it.


00:24:26.380 --> 00:24:27.220
- Exactly.


00:24:27.220 --> 00:24:29.460
So the short version, because, and this is quite funny


00:24:29.460 --> 00:24:31.060
because when we were at PyCon,


00:24:31.060 --> 00:24:33.940
we were presenting both projects that we maintain here,


00:24:33.940 --> 00:24:34.780
PyStack and Memory.


00:24:34.780 --> 00:24:38.400
And Memory, everybody knew, but PyStack was the new one.


00:24:38.400 --> 00:24:40.660
And a lot of people didn't kind of catch


00:24:40.660 --> 00:24:41.900
exactly what it does,


00:24:41.900 --> 00:24:44.260
and it's actually easier to explain than the profiler,


00:24:44.260 --> 00:24:47.740
which I think is quite funny that it was the other way.


00:24:47.740 --> 00:24:50.120
So the PyStack, what it does is very simple.


00:24:50.120 --> 00:24:53.620
So PyStack is a tool when you give it a Python program


00:24:53.620 --> 00:24:56.740
that is running or frozen, right?


00:24:56.740 --> 00:24:59.940
But let's say it's alive, or a core file,


00:24:59.940 --> 00:25:02.500
And it will tell you what it's doing.


00:25:02.500 --> 00:25:04.220
So it will give you the stack trace basically.


00:25:04.220 --> 00:25:05.700
So it's going to tell you, okay,


00:25:05.700 --> 00:25:08.300
so this Python program has these many threads


00:25:08.300 --> 00:25:10.780
and for every thread is going to show you the stack trace.


00:25:10.780 --> 00:25:12.100
So this function is calling this function


00:25:12.100 --> 00:25:14.620
is calling this function and is running currently.


00:25:14.620 --> 00:25:16.220
- Like a snapshot in time, right?


00:25:16.220 --> 00:25:18.340
When you asked it, it's like, boom,


00:25:18.340 --> 00:25:19.940
what are all the threads doing?


00:25:19.940 --> 00:25:20.780
- Exactly.


00:25:20.780 --> 00:25:21.900
So the program is running,


00:25:21.900 --> 00:25:23.340
which you can absolutely run PyStack


00:25:23.340 --> 00:25:24.740
on a healthy running program.


00:25:24.740 --> 00:25:26.620
It's going to tell you what it was doing at that time.


00:25:26.620 --> 00:25:28.460
So by default, it's going to stop the program


00:25:28.460 --> 00:25:31.500
for a super small amount of time.


00:25:31.500 --> 00:25:33.780
It's going to take a photo of what the program is doing


00:25:33.780 --> 00:25:35.800
and it's going to tell you what everything was doing.


00:25:35.800 --> 00:25:37.740
So who calls who and what the program


00:25:37.740 --> 00:25:39.580
was actually running at the time.


00:25:39.580 --> 00:25:41.540
The program is frozen because you have a log


00:25:41.540 --> 00:25:42.620
or something like that.


00:25:42.620 --> 00:25:46.620
It's going to show you what is blocked basically.


00:25:46.620 --> 00:25:48.940
And if you have a core file because your program crash


00:25:48.940 --> 00:25:50.860
or because you generate one on demand,


00:25:50.860 --> 00:25:51.680
because by the way,


00:25:51.680 --> 00:25:53.660
you can absolutely generate one core on demand,


00:25:53.660 --> 00:25:55.740
just take a snapshot and it's there.


00:25:55.740 --> 00:25:57.220
It will tell you what the program was doing,


00:25:57.220 --> 00:25:59.000
with the core was generated.


00:25:59.000 --> 00:25:59.840
And this is a-


00:25:59.840 --> 00:26:02.960
- That's what you can do in Linux, just in the terminal.


00:26:02.960 --> 00:26:06.120
You can just say, take a core dump of some running process.


00:26:06.120 --> 00:26:08.000
- Yep. For instance, you can do it with GDB


00:26:08.000 --> 00:26:11.120
or with a utility that sells out to GDB called Gcore.


00:26:11.120 --> 00:26:14.480
Which is installed by default when you install GDB.


00:26:14.480 --> 00:26:16.160
And the cherry on the top here is that


00:26:16.160 --> 00:26:19.840
it will tell you both what the Python code and the C code.


00:26:19.840 --> 00:26:21.840
So it will tell you like,


00:26:21.840 --> 00:26:24.000
okay, so we are calling these Python functions,


00:26:24.000 --> 00:26:25.640
you know, main and main calls,


00:26:25.640 --> 00:26:28.760
createDictionary and createDictionary calls


00:26:28.760 --> 00:26:32.240
and NumPy array, but then when it enters C code,


00:26:32.240 --> 00:26:35.080
the C Realm is going to show you also the C calls.


00:26:35.080 --> 00:26:37.080
And then if it enters Python again,


00:26:37.080 --> 00:26:38.960
it's going to show you Python again and C again.


00:26:38.960 --> 00:26:41.280
And it's going to tell you if it's Python or C.


00:26:41.280 --> 00:26:44.520
And also it's going to show you the code that is running.


00:26:44.520 --> 00:26:48.320
So if the source code is available, which most time it is,


00:26:48.320 --> 00:26:50.160
it's going to show you exactly what line,


00:26:50.160 --> 00:26:51.480
like the same thing as a Traceback.


00:26:51.480 --> 00:26:54.360
Basically it's going to show you what line was running.


00:26:54.360 --> 00:26:57.000
And very cool as well, since Python 3.11,


00:26:57.000 --> 00:27:00.160
is you can just use the, what sub-expression is running.


00:27:00.160 --> 00:27:04.920
Because in Python 3.11, we have this vector error project


00:27:04.920 --> 00:27:06.180
that I started.


00:27:06.180 --> 00:27:09.680
And now we have line, sorry, column information.


00:27:09.680 --> 00:27:12.120
So we know you have a very complicated expression


00:27:12.120 --> 00:27:14.360
and something crashes, we can point you exactly


00:27:14.360 --> 00:27:17.320
to what part of the expression was generating the crash.


00:27:17.320 --> 00:27:20.140
But now we can use the same information in this tool


00:27:20.140 --> 00:27:22.000
to show you what part of the expression was running.


00:27:22.000 --> 00:27:25.400
So for instance, you were adding four NumPy arrays


00:27:25.400 --> 00:27:27.040
and the application crashes


00:27:27.040 --> 00:27:28.820
adding the second and the third one,


00:27:28.820 --> 00:27:30.560
we can show you, okay, it's crashing,


00:27:30.560 --> 00:27:31.720
adding the second and the third one.


00:27:31.720 --> 00:27:35.280
So you can know exactly that was that operation


00:27:35.280 --> 00:27:37.880
and not the other one, which is quite cool.


00:27:37.880 --> 00:27:38.840
And the same for C.


00:27:38.840 --> 00:27:41.520
- It sounds awesome.


00:27:41.520 --> 00:27:43.360
I also like the description here.


00:27:43.360 --> 00:27:45.840
PyStack is a tool that uses forbidden magic


00:27:45.840 --> 00:27:48.300
to let you inspect the stack frames.


00:27:48.300 --> 00:27:49.400
I love the process.


00:27:49.400 --> 00:27:51.400
- I got a funny trivia.


00:27:51.400 --> 00:27:55.100
I got a funny conversation with Mark Shannon.


00:27:55.100 --> 00:27:58.360
We worked together on the 5.30 Python project


00:27:58.360 --> 00:28:02.500
because we say here nasty CPython internals.


00:28:02.500 --> 00:28:04.660
Which mostly, you know, we were into


00:28:04.660 --> 00:28:06.160
what is a nasty CPython internal


00:28:06.160 --> 00:28:08.860
because we both do those nasty CPython internals.


00:28:08.860 --> 00:28:11.500
But you know, I think nobody really enjoys


00:28:11.500 --> 00:28:14.020
internal CPython, not even Core Devs.


00:28:14.020 --> 00:28:15.700
So there you go.


00:28:15.700 --> 00:28:17.900
- Well, and I imagine that you're making your life harder


00:28:17.900 --> 00:28:19.580
3.11 all of you.


00:28:19.580 --> 00:28:20.100
>> Yeah, yeah.


00:28:20.100 --> 00:28:22.780
I mean, this is kind of weird because I'm making my own job


00:28:22.780 --> 00:28:23.940
harder every single time.


00:28:23.940 --> 00:28:25.060
So I work on Python.


00:28:25.060 --> 00:28:25.580
I'm happy.


00:28:25.580 --> 00:28:29.620
And then I'm sad because I just make my own life harder


00:28:29.620 --> 00:28:32.060
on the other side of the pool, right?


00:28:32.060 --> 00:28:34.580
>> This is a project that would be much, much harder to maintain


00:28:34.580 --> 00:28:36.420
if Pablo wasn't around to help on it.


00:28:36.420 --> 00:28:40.060
Because, yeah, in order to keep this forbidden magic working,


00:28:40.060 --> 00:28:43.100
we do need to keep up with changes to the interpreter.


00:28:43.100 --> 00:28:45.940
And it's a place where if we didn't have core devs telling


00:28:45.940 --> 00:28:50.740
what changed in the interpreter, it would be very hard to keep up with those changes and figure out


00:28:50.740 --> 00:28:57.060
what has changed. >> Especially since the faster CPython stuff has kicked into gear. >> Right.


00:28:57.060 --> 00:29:02.500
One thing here which is also quite interesting is that we are not the only people to enjoy this


00:29:02.500 --> 00:29:08.420
forbidden magic. We have a coen, let's say. This forbidden magic is shared in one way or the other


00:29:08.420 --> 00:29:15.540
with performance profilers. So, for instance, some of the ones that use similar techniques are


00:29:15.540 --> 00:29:19.100
Austin Austin the Austin provider and also by a spy


00:29:19.100 --> 00:29:26.240
And it's quite interesting because the there is a different like both both tools can actually do something similar


00:29:26.240 --> 00:29:31.980
So both by a stack and Austin can kind of take a snapshot and show you what the application is doing


00:29:31.980 --> 00:29:38.220
At the time of this podcast they can do it for a live process. They cannot do it for a core file


00:29:38.220 --> 00:29:41.780
Okay, so you have a core file you are out of lag


00:29:41.780 --> 00:29:46.140
you can only use PyStack. If you have a live process, you can use PyStack,


00:29:46.140 --> 00:29:49.480
but you can also use PySpy or Austin. Both can do that.


00:29:49.480 --> 00:29:52.980
The main difference here, even if we share functionality,


00:29:52.980 --> 00:29:59.380
is that we are not a profiler. We are a debugger, which means that we try really,


00:29:59.380 --> 00:30:05.100
really hard to find that information, even in the most weird situation.


00:30:05.100 --> 00:30:09.700
So, for instance, even if you have corrupted memory or your file or your core file is


00:30:09.700 --> 00:30:14.660
corrupted or your process is really in a bad state, we can still give you the


00:30:14.660 --> 00:30:20.420
information even if you don't have the back symbols. So we are slower than


00:30:20.420 --> 00:30:25.260
both profilers because both PySpy and Austin need to basically take photos at


00:30:25.260 --> 00:30:28.980
a very high speed because that's what the profiler does. It basically takes a


00:30:28.980 --> 00:30:32.580
lot of photos very fast and then you're going to show you, "Okay, I took like 1


00:30:32.580 --> 00:30:36.340
million photos in a second," and most of the time the photos show that you


00:30:36.340 --> 00:30:40.800
wearing this function called various low function so that is going to tell you


00:30:40.800 --> 00:30:43.500
well you're spending most of the time this function you should optimize that


00:30:43.500 --> 00:30:47.240
function so for them is really really important to take those photos really


00:30:47.240 --> 00:30:52.940
fast right sometimes even sacrificing correctness in some cases yeah


00:30:52.940 --> 00:30:56.260
especially yeah they have some option to control the correctness because they


00:30:56.260 --> 00:31:00.580
need to kind of sometimes guess and sometimes these photos they take with


00:31:00.580 --> 00:31:04.360
the process running so you know you can be like half of the photo in one


00:31:04.360 --> 00:31:06.360
and have all the other in the other,


00:31:06.360 --> 00:31:10.160
and both have options to control if you want that or not.


00:31:10.160 --> 00:31:12.160
- That's like frame-sharing in video games.


00:31:12.160 --> 00:31:14.160
- Yeah, pretty much.


00:31:14.160 --> 00:31:17.120
I always think about that particular metaphor


00:31:17.120 --> 00:31:18.560
when I explain this.


00:31:18.560 --> 00:31:20.080
But most people don't know what that is,


00:31:20.080 --> 00:31:24.120
so I'm very happy to know that you're a connoisseur as well.


00:31:24.120 --> 00:31:29.120
But, yeah, the main difference is that for them,


00:31:29.120 --> 00:31:31.080
they do a very good work, just to be clear here.


00:31:31.080 --> 00:31:33.520
But for them, their main concern is speed,


00:31:33.520 --> 00:31:37.060
and the whole thing is surrounded by this idea


00:31:37.060 --> 00:31:39.860
of doing this operation very fast, and because they do it very fast,


00:31:39.860 --> 00:31:42.520
they can do it once, so you just ask for one photo,


00:31:42.520 --> 00:31:44.520
they can give you that photo.


00:31:44.520 --> 00:31:47.760
In our case, our concern is not speed, because we're not a profiler,


00:31:47.760 --> 00:31:50.760
our concern is correctness and the photo.


00:31:50.760 --> 00:31:54.460
So we really, really, really hard try to get the correct photo


00:31:54.460 --> 00:31:56.960
and the photo if it's possible.


00:31:56.960 --> 00:31:58.960
So that's the main difference.


00:31:58.960 --> 00:32:01.680
This means that if you are already using...


00:32:01.680 --> 00:32:03.680
A lot of people are using PySpy, for instance,


00:32:03.680 --> 00:32:06.600
for this kind of, my Python application is frozen.


00:32:06.600 --> 00:32:09.080
So in that case, you don't care if the photo is fast or slow


00:32:09.080 --> 00:32:11.680
because it's already frozen, like who cares, right?


00:32:11.680 --> 00:32:14.040
But on the other hand, if you have a crashing application,


00:32:14.040 --> 00:32:15.920
especially a core file, then you're kind of over the luck


00:32:15.920 --> 00:32:18.200
because these projects don't work at the time


00:32:18.200 --> 00:32:19.800
that we're speaking for core files.


00:32:19.800 --> 00:32:22.880
- Yeah, PyStack really seems to have a unique feature set,


00:32:22.880 --> 00:32:26.060
a special place in the ecosystem, yeah.


00:32:26.060 --> 00:32:30.600
- And most of the kind of extra features that PyStack has,


00:32:30.600 --> 00:32:32.600
which are not the main functionality,


00:32:32.600 --> 00:32:36.440
are basically around this idea of we are the buyer.


00:32:36.440 --> 00:32:38.840
So for instance, we can give you extra metadata.


00:32:38.840 --> 00:32:42.520
Some of this metadata actually also is shared


00:32:42.520 --> 00:32:43.920
with these tools, but some other is not.


00:32:43.920 --> 00:32:47.360
So we give you things like which thread has the gil


00:32:47.360 --> 00:32:51.480
at the time, or if the GC is running on the thread or not.


00:32:51.480 --> 00:32:55.880
We also tell you the call offsets and things like that.


00:32:55.880 --> 00:33:00.000
So there is a lot of extra stuff that we can provide to you


00:33:00.000 --> 00:33:04.800
so you can debug more easily your applications.


00:33:04.800 --> 00:33:07.280
For instance, for the C code, if it's available,


00:33:07.280 --> 00:33:10.520
which means that we can give you the column offsets


00:33:10.520 --> 00:33:13.840
as well of the source code that generated the binaries.


00:33:13.840 --> 00:33:17.120
You need a modern compiler to do that.


00:33:17.120 --> 00:33:20.080
Only DWARF 4, I think, has this information.


00:33:20.080 --> 00:33:22.880
DWARF is the debugging format for C,


00:33:22.880 --> 00:33:25.240
which is kind of funny because the binary format is ELF.


00:33:25.240 --> 00:33:27.400
So, you know, it's ELF and DWARF.


00:33:27.400 --> 00:33:31.000
ELF stands for X-Axonal Unlinkable Format.


00:33:31.000 --> 00:33:34.520
But DWARF doesn't have an acronym.


00:33:34.520 --> 00:33:36.320
It's just funny.


00:33:36.320 --> 00:33:39.120
Well, they come with this weird acronym,


00:33:39.120 --> 00:33:39.940
I think they call it,


00:33:39.940 --> 00:33:42.120
when you come with acronym after the fact.


00:33:42.120 --> 00:33:44.000
So you just say, oh, DWARF is very funny.


00:33:44.000 --> 00:33:45.280
Let's try to put it.


00:33:45.280 --> 00:33:48.200
And I think now it stands on debugging


00:33:48.200 --> 00:33:50.320
with arbitrary format or something.


00:33:50.320 --> 00:33:51.800
Like, it's just really bad.


00:33:51.800 --> 00:33:53.200
- Yeah, yeah, yeah.


00:33:53.200 --> 00:33:56.360
Try to fit the acronym into the thing, yeah, yeah.


00:33:56.360 --> 00:33:59.720
But we call it the Truck Service, and we'll see where it goes from there.


00:33:59.720 --> 00:34:01.720
- Exactly, yeah, literally.


00:34:01.720 --> 00:34:05.960
So the idea is that we give you this extra kind of metadata around it.


00:34:05.960 --> 00:34:08.840
And every time we do this, we try to do more.


00:34:08.840 --> 00:34:13.400
For instance, we are now talking about with 3.12,


00:34:13.400 --> 00:34:16.040
we are going to release in Python subinterpreters.


00:34:16.040 --> 00:34:20.200
So we are discussing the possibility of showing subinterpreters also in PyStack


00:34:20.200 --> 00:34:21.560
or maybe as in Coyote task.


00:34:21.560 --> 00:34:23.800
I mean, these are not actual features that we are running right now,


00:34:23.800 --> 00:34:26.540
but the idea is that we are considering these things


00:34:26.540 --> 00:34:28.840
that for a profiler maybe it's just too hard


00:34:28.840 --> 00:34:32.180
because it means that you need to inspect a lot more memory


00:34:32.180 --> 00:34:36.280
and your photo is going to be prohibited as low.


00:34:36.280 --> 00:34:38.580
But for us, it's not because we just take one photo


00:34:38.580 --> 00:34:41.080
and it just needs to be a very good one.


00:34:41.080 --> 00:34:42.820
- Yeah, excellent.


00:34:42.820 --> 00:34:45.520
Yeah, see, you are making your life harder over and over.


00:34:45.520 --> 00:34:48.560
Quick question from the audience in the live stream.


00:34:48.560 --> 00:34:50.960
Tony says, "Could this be utilized in something


00:34:50.960 --> 00:34:53.760
like AWS Lambda as error handling?


00:34:53.760 --> 00:34:56.760
Grab the core dump if it bombs,


00:34:56.760 --> 00:34:58.500
since you wouldn't have access to the runtime


00:34:58.500 --> 00:34:59.940
after the Lambda executed.


00:34:59.940 --> 00:35:04.160
- Yeah, I mean, I wouldn't, it's not the,


00:35:04.160 --> 00:35:07.840
I like, as a compiler engineer, I would say,


00:35:07.840 --> 00:35:09.880
I don't know anything about AWS,


00:35:09.880 --> 00:35:12.840
so I don't know if it's the best way to do it,


00:35:12.840 --> 00:35:14.840
but yeah, absolutely, this is something that you can do.


00:35:14.840 --> 00:35:15.960
If you generate a core file,


00:35:15.960 --> 00:35:18.680
then Fivestack can absolutely handle your core file.


00:35:18.680 --> 00:35:19.520
No problem.


00:35:19.520 --> 00:35:23.520
I think the only question I have there is if you can get the core file out after it has crashed.


00:35:23.520 --> 00:35:28.520
But as long as there's some way to get the core file out, you definitely could inspect it with PyStack.


00:35:28.520 --> 00:35:36.520
Oh, interesting. Is there a Python code level API for working with PyStack, or is it an outside-only thing?


00:35:36.520 --> 00:35:39.520
Not at the time. It's just a command line application.


00:35:39.520 --> 00:35:44.520
We could expose it. Like, PyStack is mainly a library with a lot of functionality.


00:35:44.520 --> 00:35:47.440
So if there is people that want to use it for other things,


00:35:47.440 --> 00:35:49.760
we are quite happy to expose it.


00:35:49.760 --> 00:35:57.080
>> Yeah, I'm thinking things like for, say, C Profile,


00:35:57.080 --> 00:35:59.680
you can turn off the profiling at startup


00:35:59.680 --> 00:36:02.120
and then turn it back on with Python code,


00:36:02.120 --> 00:36:06.160
or you could set an at exit callback, potentially,


00:36:06.160 --> 00:36:08.920
to those kind of things.


00:36:08.920 --> 00:36:12.680
>> We don't have this, but we do have some other cool thing


00:36:12.680 --> 00:36:17.360
that I mean, let's say intersects 20% with what you said,


00:36:17.360 --> 00:36:19.480
just to be clear, I'm not trying to answer your question fully,


00:36:19.480 --> 00:36:20.960
but I think it's related.


00:36:20.960 --> 00:36:25.240
We have this pytest plugin, which basically you can install.


00:36:25.240 --> 00:36:28.400
And if some of your tests crashes, it's going to just run PyStack.


00:36:28.400 --> 00:36:31.520
It crashes or freezes. It's going to run PyStack on that.


00:36:31.520 --> 00:36:33.320
And it's going to show you what happened.


00:36:33.320 --> 00:36:36.640
And we are talking also to have something similar to FoldHandler,


00:36:36.640 --> 00:36:39.880
which is a standard library module that you can activate.


00:36:39.880 --> 00:36:42.400
And if your process crashes, it shows you the Python stack.


00:36:42.400 --> 00:36:44.400
But again, you're missing the C stack.


00:36:44.400 --> 00:36:47.780
So we are going to allow you to also have this idea of like,


00:36:47.780 --> 00:36:50.120
"Oh, I want to just run my Python application.


00:36:50.120 --> 00:36:53.680
If it crashes, then I want PyStack to be run on the process


00:36:53.680 --> 00:36:56.780
so I can see what was happening there."


00:36:56.780 --> 00:37:00.120
By the way, this literally is something that was used.


00:37:00.120 --> 00:37:05.120
For instance, URLib3, the project URLib3,


00:37:05.120 --> 00:37:07.760
I think it's the most downloaded package on PyPI,


00:37:07.760 --> 00:37:09.060
or it's close to it.


00:37:09.060 --> 00:37:10.320
- I think so.


00:37:10.320 --> 00:37:14.000
Yeah, so they use Membrane, which is our memory profiler.


00:37:14.000 --> 00:37:16.960
And sometimes, you know, again,


00:37:16.960 --> 00:37:19.200
when the mall was full on Wednesdays,


00:37:19.200 --> 00:37:23.080
it was crashing on some weird test.


00:37:23.080 --> 00:37:25.880
And, you know, at the time we asked them,


00:37:25.880 --> 00:37:29.120
well, you know, Membrane uses C++ code underneath,


00:37:29.120 --> 00:37:30.440
no surprise there.


00:37:30.440 --> 00:37:32.840
And you're using Python code that uses Membrane,


00:37:32.840 --> 00:37:35.200
so the crash is happening in some combination of both.


00:37:35.200 --> 00:37:38.200
And we needed both stacks to debug what was going on.


00:37:38.200 --> 00:37:42.440
And I thought, "Man, if only we have PyStack open source.


00:37:42.440 --> 00:37:45.200
We could just tell them, 'Run this thing on your test suite.'"


00:37:45.200 --> 00:37:46.600
But at the time, we didn't have it.


00:37:46.600 --> 00:37:50.120
So we had to ask them for a core file.


00:37:50.120 --> 00:37:55.120
They tried, but at the end, we ended up having to try to reproduce it on our side,


00:37:55.120 --> 00:37:58.360
which was really hard because this was a race condition, basically.


00:37:58.360 --> 00:38:01.800
And the race-- So I did all the weird techniques,


00:38:01.800 --> 00:38:06.640
like running a Docker container with 0.001 CPU quota,


00:38:06.640 --> 00:38:10.480
like running hundreds of test suites at the same time.


00:38:10.480 --> 00:38:12.520
It was not a fun afternoon, let's say.


00:38:12.520 --> 00:38:14.840
- If I recall correctly,


00:38:14.840 --> 00:38:17.480
that took us like a full 24 hours to reproduce


00:38:17.480 --> 00:38:18.720
just running the tests in a loop


00:38:18.720 --> 00:38:20.800
until we managed to catch it the first time.


00:38:20.800 --> 00:38:22.080
- Wow.


00:38:22.080 --> 00:38:24.720
- You run into my room at the time,


00:38:24.720 --> 00:38:26.680
you see this meme when there's this guy


00:38:26.680 --> 00:38:28.440
with the blackboard without the threads,


00:38:28.440 --> 00:38:31.720
like moving their hands like super crazy.


00:38:31.720 --> 00:38:32.960
So that was me at the time,


00:38:32.960 --> 00:38:37.520
running like six max splits with the test suite running.


00:38:37.520 --> 00:38:40.320
So yeah, this tool is, when you need it,


00:38:40.320 --> 00:38:41.920
it's really useful.


00:38:41.920 --> 00:38:44.760
- Yeah, it's the kind of thing that a lot of times


00:38:44.760 --> 00:38:46.360
you don't need, you're like, "Ah, that's interesting."


00:38:46.360 --> 00:38:49.160
And then when you do need it, amazing.


00:38:49.160 --> 00:38:51.280
- And this is key because what happens normally


00:38:51.280 --> 00:38:53.120
with the bargaining tools, like GDB


00:38:53.120 --> 00:38:54.440
is a very good example of this,


00:38:54.440 --> 00:38:56.120
is that they are very hard to use.


00:38:56.120 --> 00:38:59.760
Like the kind of like amount of knowledge that you need


00:38:59.760 --> 00:39:00.880
is quite high.


00:39:00.880 --> 00:39:02.320
They are not very ergonomic,


00:39:02.320 --> 00:39:04.320
which means that it's not the easiest thing,


00:39:04.320 --> 00:39:06.660
you need to get used to them and their language


00:39:06.660 --> 00:39:09.060
and what they can do and what they cannot do.


00:39:09.060 --> 00:39:12.800
It's the kind of thing that normally people learn when they need to,


00:39:12.800 --> 00:39:16.000
which is the worst time to learn it because you need to solve the problem.


00:39:16.000 --> 00:39:17.000
[INTERPOSING VOICES]


00:39:17.000 --> 00:39:19.000
It's very annoying.


00:39:19.000 --> 00:39:22.140
So what we are trying to do quite a lot,


00:39:22.140 --> 00:39:26.540
both on PyStack but also on Memory Profiler Membrane,


00:39:26.540 --> 00:39:29.620
is to offer a really good UX around these tools.


00:39:29.620 --> 00:39:32.220
That's why we are offering this pytest plugin


00:39:32.220 --> 00:39:34.920
and thinking about doing this full handler thing.


00:39:34.920 --> 00:39:39.260
Because it's not just the tool itself that you can execute,


00:39:39.260 --> 00:39:42.460
but also we want you to not have to think about it.


00:39:42.460 --> 00:39:46.420
It's not the tool to reach, it's the tool that is backing you up.


00:39:46.420 --> 00:39:49.920
You set it once, you forget about the fact that it exists,


00:39:49.920 --> 00:39:52.820
and when something happens, you are really happy


00:39:52.820 --> 00:39:54.820
that you set that thing up.


00:39:54.820 --> 00:39:57.460
And that's the experience that we want people.


00:39:57.460 --> 00:39:59.780
And this is the other extra thing


00:39:59.780 --> 00:40:02.100
that we are trying to put into Biostack,


00:40:02.100 --> 00:40:03.940
that the UX is really good.


00:40:03.940 --> 00:40:08.020
So, Matt, I think you want to--


00:40:08.020 --> 00:40:10.220
>>And as far as the UX goes, I think


00:40:10.220 --> 00:40:12.340
it's helpful to keep in mind that when people are using


00:40:12.340 --> 00:40:13.980
these tools, it's almost certainly not


00:40:13.980 --> 00:40:15.100
because they want to.


00:40:15.100 --> 00:40:16.380
No one is having a good time when


00:40:16.380 --> 00:40:17.460
they're using these tools.


00:40:17.460 --> 00:40:19.500
They're using these tools because something has already


00:40:19.500 --> 00:40:20.980
gone wrong and stopped them from doing


00:40:20.980 --> 00:40:22.980
what they wanted to be doing in the first place,


00:40:22.980 --> 00:40:25.900
and now they need to backtrack and figure out why.


00:40:25.900 --> 00:40:28.200
You're kind of like an emergency room doctor.


00:40:28.200 --> 00:40:30.400
People don't ever want to meet the emergency room doctor,


00:40:30.400 --> 00:40:31.640
but they're happy they're there.


00:40:31.640 --> 00:40:32.480
- I'm sorry.


00:40:32.480 --> 00:40:34.020
Yeah, that was a key.


00:40:34.020 --> 00:40:34.920
- Yeah.


00:40:34.920 --> 00:40:37.980
Matt, I noticed looking at the GitHub repo for PySec


00:40:37.980 --> 00:40:40.420
that there's a lot of languages involved here.


00:40:40.420 --> 00:40:44.880
We got a good chunk of Python, C++, Cython, C,


00:40:44.880 --> 00:40:46.460
only a little bit of C, I guess,


00:40:46.460 --> 00:40:51.180
but you both have to keep a lot of technology interplay


00:40:51.180 --> 00:40:53.460
in mind just working on this, right?


00:40:53.460 --> 00:40:54.460
- Yeah, definitely.


00:40:55.620 --> 00:40:58.460
My career has been as a C++ developer mostly.


00:40:58.460 --> 00:41:04.100
So it tends to surprise people when we tell them that on the Python infrastructure team,


00:41:04.100 --> 00:41:09.540
we spend most of our time working on C++ and relatively little time writing Python,


00:41:09.540 --> 00:41:10.740
comparatively little.


00:41:10.740 --> 00:41:14.620
If you actually looked at the way this code breaks down in the PyStack repo,


00:41:14.620 --> 00:41:17.540
you would see that even though it's predominantly Python code,


00:41:17.540 --> 00:41:20.420
the Python code is predominantly in the test suite.


00:41:20.420 --> 00:41:28.260
most of the actual code for PyStack is in C++ or in Cython, not in Python.


00:41:28.260 --> 00:41:33.700
I was going to guess that Python might be in there, like, reporting, CLI parsing.


00:41:33.700 --> 00:41:35.900
Literally is what it is, yes.


00:41:35.900 --> 00:41:37.700
Yeah, you're exactly right.


00:41:37.700 --> 00:41:43.420
And then is there in some parts when really C++ will be overkill or too verbose or too annoying?


00:41:43.420 --> 00:41:50.260
Like, I think parsing some stuff, I think, is preparing the input to the C++ code, let's say.


00:41:50.260 --> 00:41:53.940
Yeah, parsing maps or things like that.


00:41:53.940 --> 00:41:54.940
Right.


00:41:54.940 --> 00:41:59.060
But that's the thing, like one of the reasons there is so much C++, actually, not only because


00:41:59.060 --> 00:42:04.580
of performance, but because these tools need to play quite heavily on systems programming


00:42:04.580 --> 00:42:05.580
techniques.


00:42:05.580 --> 00:42:10.860
So PyStack plays a lot of, let's say, quote unquote, "dark magic."


00:42:10.860 --> 00:42:15.380
It's not as dark as our other tool, the profiler, because the profiler is just in another level


00:42:15.380 --> 00:42:22.380
of darkness that has gone through many dark rituals already.


00:42:22.380 --> 00:42:26.380
But here as well, because at the end of the day, what these tools do,


00:42:26.380 --> 00:42:31.380
what PyStack does, is that it's reading memory from a different program.


00:42:31.380 --> 00:42:34.380
And that is quite complicated, because when you read memory


00:42:34.380 --> 00:42:36.380
from a different program, there is nothing. It's just bytes.


00:42:36.380 --> 00:42:39.380
Here are some bytes. And then you need to figure out what they are.


00:42:39.380 --> 00:42:44.380
And most of the time, the bytes that you're reading are not backed


00:42:44.380 --> 00:42:46.660
anything that you can use to make sense of.


00:42:46.660 --> 00:42:47.660
Because, you know, for instance,


00:42:47.660 --> 00:42:49.980
DDB, when it reads those bytes,


00:42:49.980 --> 00:42:51.300
it has the debugging information.


00:42:51.300 --> 00:42:54.660
So it knows that, oh, I'm reading bytes at this address,


00:42:54.660 --> 00:42:56.420
but these bytes means like,


00:42:56.420 --> 00:42:58.860
oh, a PI interpreter stayed abstract.


00:42:58.860 --> 00:42:59.740
So I know that, you know,


00:42:59.740 --> 00:43:01.660
the first eight bytes are this and that,


00:43:01.660 --> 00:43:03.500
I know where to locate things.


00:43:03.500 --> 00:43:05.340
We do that if it's available,


00:43:05.340 --> 00:43:07.540
because we don't want to make our lives harder


00:43:07.540 --> 00:43:08.540
just for no reason,


00:43:08.540 --> 00:43:10.100
but because we have to support the cases


00:43:10.100 --> 00:43:11.860
when that information is not there,


00:43:11.860 --> 00:43:15.040
we employ these extra techniques


00:43:15.040 --> 00:43:17.100
that are trying to make sense of those bytes


00:43:17.100 --> 00:43:18.300
without knowing what they are.


00:43:18.300 --> 00:43:20.060
So there is like a bunch of heuristics


00:43:20.060 --> 00:43:21.460
and checks the heuristics.


00:43:21.460 --> 00:43:23.180
And this can get like quite hardcore


00:43:23.180 --> 00:43:24.660
because like, I think at some point


00:43:24.660 --> 00:43:27.140
we had like four levels of checks


00:43:27.140 --> 00:43:28.500
just because of one heuristic.


00:43:28.500 --> 00:43:30.100
You know, the kind of thing when you say,


00:43:30.100 --> 00:43:32.260
well, there is no way in the world


00:43:32.260 --> 00:43:35.860
if these things are true is not what I'm searching for.


00:43:35.860 --> 00:43:38.260
Well, I will tell you, yes, it will happen.


00:43:38.260 --> 00:43:40.020
We have seen those when like,


00:43:40.020 --> 00:43:42.880
I remember that we were having this discussion.


00:43:42.880 --> 00:43:45.080
We have four checks for something, basically,


00:43:45.080 --> 00:43:46.120
we are reading some bytes


00:43:46.120 --> 00:43:48.360
and we are making some pointers,


00:43:48.360 --> 00:43:50.300
and if a bunch of conditions are true,


00:43:50.300 --> 00:43:51.800
we are sure that we have located


00:43:51.800 --> 00:43:53.600
some important piece of information,


00:43:53.600 --> 00:43:54.800
the interpreter state, I think,


00:43:54.800 --> 00:43:56.680
or the thread state, whatever it is.


00:43:56.680 --> 00:43:59.000
And Matt was saying, "Well, but you know,


00:43:59.000 --> 00:44:01.040
"there is this case when these things can be true


00:44:01.040 --> 00:44:02.660
"and it's still not it because, you know,


00:44:02.660 --> 00:44:05.360
"it just happens to have these properties."


00:44:05.360 --> 00:44:07.720
And I said, "Okay, let me calculate mathematically


00:44:07.720 --> 00:44:09.140
"the probability of that happening."


00:44:09.140 --> 00:44:11.220
And it was 0.001%, right?


00:44:11.220 --> 00:44:13.660
And then we said, cool, never happening.


00:44:13.660 --> 00:44:15.220
I think it was three months until it happened.


00:44:15.220 --> 00:44:19.140
So, you know, like, yes, we need to take care


00:44:19.140 --> 00:44:21.420
a lot of these things to ensure that.


00:44:21.420 --> 00:44:22.380
- A lot of edge cases.


00:44:22.380 --> 00:44:25.700
I'm starting to understand the black magic reference here.


00:44:25.700 --> 00:44:26.940
- So that's part of it.


00:44:26.940 --> 00:44:29.500
The other part is just like all the synonyms


00:44:29.500 --> 00:44:31.260
with like, you know, stopping the process,


00:44:31.260 --> 00:44:33.060
making the sender self CPython,


00:44:33.060 --> 00:44:35.220
trying to extract information from CPython


00:44:35.220 --> 00:44:39.060
in ways that CPython is not prepared to.


00:44:39.060 --> 00:44:41.060
So you need to know a lot about everything,


00:44:41.060 --> 00:44:42.520
a lot about systems programming,


00:44:42.520 --> 00:44:44.240
so how to read memory from processes,


00:44:44.240 --> 00:44:45.880
how to stop processes.


00:44:45.880 --> 00:44:47.240
And also these tools,


00:44:47.240 --> 00:44:48.640
this is quite important to mention as well,


00:44:48.640 --> 00:44:50.840
these tools are supposed to GDB


00:44:50.840 --> 00:44:53.400
because when you attach GDB to a project,


00:44:53.400 --> 00:44:54.680
GDB can do whatever you want.


00:44:54.680 --> 00:44:56.660
It can either inject code into the process,


00:44:56.660 --> 00:44:58.480
it can call things in the process.


00:44:58.480 --> 00:45:02.000
So many teams have GDB forbidden in production


00:45:02.000 --> 00:45:04.720
because attaching GDB can do arbitrary things, right?


00:45:04.720 --> 00:45:07.000
So you don't want that a lot of the time,


00:45:07.000 --> 00:45:08.560
especially if you are under compliance


00:45:08.560 --> 00:45:09.840
or you have like secrets.


00:45:09.840 --> 00:45:10.680
- Right, right.


00:45:10.680 --> 00:45:12.520
If you're in a banking industry, say,


00:45:12.520 --> 00:45:13.680
or something like that,


00:45:13.680 --> 00:45:17.880
and you try to catch a problem and it changes,


00:45:17.880 --> 00:45:20.240
it makes decisions, that might not be awesome.


00:45:20.240 --> 00:45:22.200
- And GDB can make your application crash.


00:45:22.200 --> 00:45:23.520
Like, you can absolutely do that


00:45:23.520 --> 00:45:24.680
because it can inject code.


00:45:24.680 --> 00:45:26.400
And it's like, you see,


00:45:26.400 --> 00:45:28.680
like I invite everyone interested on,


00:45:28.680 --> 00:45:32.120
like try to learn how GDB calls functions in your process.


00:45:32.120 --> 00:45:35.400
So you attach GDB, you can call a function in the process,


00:45:35.400 --> 00:45:36.680
just learn how that is done.


00:45:36.680 --> 00:45:38.680
and you're going to cry.


00:45:38.680 --> 00:45:41.040
And if you want to cry even more because you say,


00:45:41.040 --> 00:45:43.240
"Well, man, I still have some tears in my eyes,


00:45:43.240 --> 00:45:46.760
and it's not enough," just learn how LLDB does it.


00:45:46.760 --> 00:45:49.520
Like this is the other debugger from LLVM,


00:45:49.520 --> 00:45:50.800
because that is just bananas.


00:45:50.800 --> 00:45:52.680
That is just another level of craziness.


00:45:52.680 --> 00:45:54.120
So these tools are very powerful,


00:45:54.120 --> 00:45:55.780
but they are also a bit dangerous.


00:45:55.780 --> 00:45:58.240
So the other thing that we really, really put a lot of effort


00:45:58.240 --> 00:46:00.480
in is that these tools just read memory.


00:46:00.480 --> 00:46:02.700
That they don't modify the process at all.


00:46:02.700 --> 00:46:03.860
The only thing they do is stop it,


00:46:03.860 --> 00:46:05.740
which is always a safe operation.


00:46:05.740 --> 00:46:08.640
and then they restart the process, that's all.


00:46:08.640 --> 00:46:11.040
And you can also choose not to stop it if you don't want to.


00:46:11.040 --> 00:46:14.120
Because, for instance, you have some super performance


00:46:14.120 --> 00:46:16.480
applications, so Biostack can still take snapshots


00:46:16.480 --> 00:46:18.620
with the process running if you really need to,


00:46:18.620 --> 00:46:21.820
sacrificing, obviously, that the photo may be blurry,


00:46:21.820 --> 00:46:25.120
let's say, most of the time it will be, but it can be.


00:46:25.120 --> 00:46:26.060
But you can also ask for that.


00:46:26.060 --> 00:46:27.800
But the idea is that these are safe to use


00:46:27.800 --> 00:46:29.820
on running processes because we don't touch


00:46:29.820 --> 00:46:31.840
the memory at all, we just read it.


00:46:31.840 --> 00:46:33.900
- I will say, you say that stopping a process


00:46:33.900 --> 00:46:34.940
is always safe.


00:46:34.940 --> 00:46:36.580
That's not necessarily true.


00:46:36.580 --> 00:46:38.340
It does change the behavior of syscalls


00:46:38.340 --> 00:46:40.740
that are in the middle of happening.


00:46:40.740 --> 00:46:41.900
They'll get a--


00:46:41.900 --> 00:46:48.020
They get a E--


00:46:48.020 --> 00:46:50.020
E enter.


00:46:50.020 --> 00:46:51.220
Yeah, they'll get an E enter.


00:46:51.220 --> 00:46:53.180
And that can change the behavior of the program.


00:46:53.180 --> 00:46:55.380
What's supposed to happen is that the program detects


00:46:55.380 --> 00:46:58.220
that the syscall has been interrupted and retries it.


00:46:58.220 --> 00:47:00.460
But not all of them do that all the time.


00:47:00.460 --> 00:47:03.060
Because it's C and your error handling is all manual,


00:47:03.060 --> 00:47:05.660
it's very easy to miss a place where you needed to retry something.


00:47:05.660 --> 00:47:07.260
Well, C++ and Python does it.


00:47:07.260 --> 00:47:09.940
So it's kind of, unless you have like your custom code,


00:47:09.940 --> 00:47:11.660
most of the times it's safe to do.


00:47:11.660 --> 00:47:12.260
That's true.


00:47:12.260 --> 00:47:14.900
But this can happen also, you send signals to your process.


00:47:14.900 --> 00:47:17.860
So for instance, you have any process,


00:47:17.860 --> 00:47:22.260
and then it just happens to send a signal or someone interrupts the process,


00:47:22.260 --> 00:47:24.140
like for instance, because you have it under a scheduler,


00:47:24.140 --> 00:47:28.460
or you're using some very old kernel, for instance, that sends six stops.


00:47:28.460 --> 00:47:32.100
Or you're running it in a cluster when you can put it in the freeze.


00:47:32.100 --> 00:47:37.100
a C group, you will get the same situation.


00:47:37.100 --> 00:47:38.060
And you will see, for instance,


00:47:38.060 --> 00:47:39.540
you see Python all the time,


00:47:39.540 --> 00:47:41.300
this loop that just checks,


00:47:41.300 --> 00:47:42.900
for instance, you're reading bytes,


00:47:42.900 --> 00:47:44.860
and then your read call finishes.


00:47:44.860 --> 00:47:46.940
And then you normally assume, well, it has finished


00:47:46.940 --> 00:47:48.860
because I have read all the bytes that I wanted.


00:47:48.860 --> 00:47:50.700
Well, it may be not true


00:47:50.700 --> 00:47:52.620
because you may have been interrupted.


00:47:52.620 --> 00:47:54.500
So you need to try again.


00:47:54.500 --> 00:47:56.880
- Sure, and at a higher level, it could be,


00:47:56.880 --> 00:48:00.380
I was calling an API and it paused,


00:48:00.380 --> 00:48:02.380
that actually caused it to time out,


00:48:02.380 --> 00:48:06.080
or something like that, or a database connection reset,


00:48:06.080 --> 00:48:08.760
or something weird at that level.


00:48:08.760 --> 00:48:11.320
But I think a big difference here is,


00:48:11.320 --> 00:48:16.700
these are a single call went crazy while you paused it,


00:48:16.700 --> 00:48:19.960
whereas when you talk about injecting code,


00:48:19.960 --> 00:48:23.000
you could have messed it up for the rest of the life of the process.


00:48:23.000 --> 00:48:25.000
In unknown ways, yeah, absolutely.


00:48:25.000 --> 00:48:27.680
Technically, attaching GDB is undefined behavior


00:48:27.680 --> 00:48:30.220
because you can modify a retry memory in ways


00:48:30.220 --> 00:48:31.720
that you don't know what's going on.


00:48:31.720 --> 00:48:33.420
Obviously, it's not going to be the case


00:48:33.420 --> 00:48:35.680
because GDB doesn't do that by default.


00:48:35.680 --> 00:48:38.520
But the desk calling functions can alter--


00:48:38.520 --> 00:48:40.720
especially if you're calling to a C API.


00:48:40.720 --> 00:48:42.480
If you just happen to have a pointer


00:48:42.480 --> 00:48:44.100
and then you want to print the pointer


00:48:44.100 --> 00:48:48.120
and you call PyDumpObject, now you are like,


00:48:48.120 --> 00:48:49.640
who knows what happened?


00:48:49.640 --> 00:48:51.960
You are just calling-- you need the GIL, for instance,


00:48:51.960 --> 00:48:52.520
to do that.


00:48:52.520 --> 00:48:55.120
So it's very unclear what's going on.


00:48:55.120 --> 00:48:56.640
So we don't do any of that.


00:48:56.640 --> 00:49:00.140
Even in cases where you're able to successfully call a function with GDB,


00:49:00.140 --> 00:49:04.280
it manages to get its stuff injected and do everything that it needs to do to set up the call.


00:49:04.280 --> 00:49:09.320
You can wind up in a situation where you don't satisfy some of the invariants for that call,


00:49:09.320 --> 00:49:12.820
and that call winds up segfaulting in code injected by GDB.


00:49:12.820 --> 00:49:15.620
And it tries to recover from that, but it can't always.


00:49:15.620 --> 00:49:19.960
So you can very easily get yourself in a situation where you thought you were doing something read-only


00:49:19.960 --> 00:49:22.660
and managed to crash the process that you were trying to inspect.


00:49:23.260 --> 00:49:27.260
You can see that we learned this the hard way for our other tool,


00:49:27.260 --> 00:49:30.460
because one thing our memory profiler does,


00:49:30.460 --> 00:49:33.900
this is memory, so not PyStack, this is the other tool.


00:49:33.900 --> 00:49:37.060
So the other tool allows you to attach to a process, right?


00:49:37.060 --> 00:49:39.740
You have a process that is happily running,


00:49:39.740 --> 00:49:43.380
and then you say, "Now I want to profile this process that is already running."


00:49:43.380 --> 00:49:46.220
So I just want to know, every time it makes allocations,


00:49:46.220 --> 00:49:49.500
I just want to know that it's happening, or you just want to see it live.


00:49:49.500 --> 00:49:51.780
And so what we do is that in that case,


00:49:51.780 --> 00:49:53.820
we inject memory into the process


00:49:53.820 --> 00:49:56.700
to just prepare the profiler and all do all the stuff.


00:49:56.700 --> 00:49:58.700
And then we learn the hard way all the cases


00:49:58.700 --> 00:50:01.180
when you cannot do that.


00:50:01.180 --> 00:50:02.900
Like calling malloc under malloc.


00:50:02.900 --> 00:50:06.900
Because if your setup process requires memory,


00:50:06.900 --> 00:50:09.580
and your process is already allocated memory,


00:50:09.580 --> 00:50:11.820
then you're calling malloc under malloc,


00:50:11.820 --> 00:50:13.780
and that is undefined behavior.


00:50:13.780 --> 00:50:16.700
Well, most of the times, that's a crash.


00:50:16.700 --> 00:50:18.740
>>Yeah, I can't imagine how tricky that stuff is,


00:50:18.740 --> 00:50:19.940
of the memory stuff.


00:50:19.940 --> 00:50:21.600
Let's talk through some of the features.


00:50:21.600 --> 00:50:22.900
We've touched on a lot of these,


00:50:22.900 --> 00:50:26.020
but I just got a great long list of amazing things


00:50:26.020 --> 00:50:27.280
that PyStack can do.


00:50:27.280 --> 00:50:31.500
I'll just breeze over the ones we've talked about already,


00:50:31.500 --> 00:50:34.620
but then potentially dive into the others.


00:50:34.620 --> 00:50:38.340
So it works on both running processes,


00:50:38.340 --> 00:50:40.740
and one of the really unique aspects


00:50:40.740 --> 00:50:43.060
is on the core dump files.


00:50:43.060 --> 00:50:44.480
That's very cool.


00:50:44.480 --> 00:50:46.580
- And just to complete this part,


00:50:46.580 --> 00:50:51.260
It works on all CorelAMP files, which is a huge...


00:50:51.260 --> 00:50:55.780
Like, if you are in the world of how these things work, it's really hard


00:50:55.780 --> 00:50:59.300
because CorelAMPs don't have a specification.


00:50:59.300 --> 00:51:00.300
So this is very important.


00:51:00.300 --> 00:51:03.740
There is no document that will tell you how CorelAMPs work.


00:51:03.740 --> 00:51:06.980
This is the first surprise that you will have if you try to search for it.


00:51:06.980 --> 00:51:10.780
So you will see how they normally work,


00:51:10.780 --> 00:51:14.620
but the amount of weird stuff that can happen is just countless.


00:51:14.620 --> 00:51:17.160
Because this is whatever the kernel is doing


00:51:17.160 --> 00:51:19.620
and whatever the version of the kernel is doing.


00:51:19.620 --> 00:51:22.220
So you can see super weird stuff.


00:51:22.220 --> 00:51:24.720
And not just the kernel either.


00:51:24.720 --> 00:51:27.220
What gcore does doesn't go through the kernel.


00:51:27.220 --> 00:51:29.420
So if you're using GDB to generate a core file,


00:51:29.420 --> 00:51:31.720
you might get something that's in an entirely different format


00:51:31.720 --> 00:51:33.920
than what the kernel would have dumped.


00:51:33.920 --> 00:51:35.920
And the core files can miss data.


00:51:35.920 --> 00:51:39.320
So it's not really always a memory dump of the process,


00:51:39.320 --> 00:51:40.620
like a complete one.


00:51:40.620 --> 00:51:43.220
Because, for instance, imagine that you're in a system


00:51:43.220 --> 00:51:45.220
and you have like five Python applications,


00:51:45.220 --> 00:51:47.220
and then you generate the whole dump of the process.


00:51:47.220 --> 00:51:49.220
Well, those five Python applications are going to have


00:51:49.220 --> 00:51:51.220
loaded a lot of libraries that are common,


00:51:51.220 --> 00:51:53.220
like libc, you know,


00:51:53.220 --> 00:51:55.220
OpenSSL,


00:51:55.220 --> 00:51:57.220
so a bunch of these libraries.


00:51:57.220 --> 00:51:59.220
So are you going to just include all of them?


00:51:59.220 --> 00:52:01.220
Well, technically you should, because that's what was loaded


00:52:01.220 --> 00:52:03.220
in the memory, but that's going to generate


00:52:03.220 --> 00:52:05.220
a huge core file, like gigabytes


00:52:05.220 --> 00:52:07.220
in size. So a lot of the optimizations


00:52:07.220 --> 00:52:09.220
that are done is that, well, you know,


00:52:09.220 --> 00:52:11.220
if it's a cell library, just go and read the cell


00:52:11.220 --> 00:52:16.020
library. So I'm not going to include it. Which means that tools need to know that this is happening.


00:52:16.020 --> 00:52:20.020
And then when they see a pointer and they try to search in the core, they're going to find


00:52:20.020 --> 00:52:24.820
there is nothing there. So they need to go to the library. So there is a lot of layers that you need


00:52:24.820 --> 00:52:30.260
to go. So the second part when it says works on core and files, it works on all of them, which is


00:52:30.260 --> 00:52:39.540
quite a huge statement. I guess we should touch on what platforms PyStack can run on. Just Linux.


00:52:39.540 --> 00:52:41.540
- I mean, it could work.


00:52:41.540 --> 00:52:42.540
And this is an important fact.


00:52:42.540 --> 00:52:46.220
Like for instance, you're running on Windows or macOS,


00:52:46.220 --> 00:52:47.900
you probably want to use the other tools


00:52:47.900 --> 00:52:50.380
like that we mentioned like PySpy or Austin.


00:52:50.380 --> 00:52:53.980
I think both run on all platforms.


00:52:53.980 --> 00:52:57.220
But yes, this is because we want to ensure


00:52:57.220 --> 00:53:01.820
that we do this very well and we cover all the cases


00:53:01.820 --> 00:53:04.300
and we have enough with the one operative system.


00:53:04.300 --> 00:53:07.380
Our other tools work on macOS as well.


00:53:07.380 --> 00:53:09.420
- Our other tools work on macOS as well.


00:53:09.420 --> 00:53:11.380
So the profiler memory works on macOS.


00:53:11.380 --> 00:53:13.760
So we don't only do tools that work on Linux,


00:53:13.760 --> 00:53:16.060
but this one only works on Linux.


00:53:16.060 --> 00:53:20.380
- And to be clear, it does also work on Windows in WSL.


00:53:20.380 --> 00:53:22.220
That is my main development environment.


00:53:22.220 --> 00:53:24.540
So if not natively on Windows,


00:53:24.540 --> 00:53:26.620
but at least if you're in a virtual machine on Windows,


00:53:26.620 --> 00:53:27.620
you're fine.


00:53:27.620 --> 00:53:30.740
- PyStack will work on WSL?


00:53:30.740 --> 00:53:31.860
- Yeah, absolutely.


00:53:31.860 --> 00:53:33.700
- Yeah. Okay, cool.


00:53:33.700 --> 00:53:37.020
And I suppose it works on Docker running Linux on-


00:53:37.020 --> 00:53:39.100
- On a bunch of machines, either like on, you know,


00:53:39.100 --> 00:53:40.460
parallels on Mac.


00:53:40.460 --> 00:53:43.380
And there's a lot of ways on different platforms.


00:53:43.380 --> 00:53:44.780
- Yeah, I develop on Docker on Mac.


00:53:44.780 --> 00:53:47.020
So for instance, I run PyStack on Docker on Mac,


00:53:47.020 --> 00:53:47.860
no problem.


00:53:47.860 --> 00:53:51.740
And even in the new ones, the M1 ones works nicely.


00:53:51.740 --> 00:53:52.580
- Cool.


00:53:52.580 --> 00:53:56.420
Let's see, what are some of the other ones here?


00:53:56.420 --> 00:54:00.540
Includes calls to inline functions in the native stack.


00:54:00.540 --> 00:54:02.140
- Ah, that's a funny one.


00:54:02.140 --> 00:54:05.100
So one of the things we do is that,


00:54:06.340 --> 00:54:10.220
One thing that can happen is that the C compilers,


00:54:10.220 --> 00:54:13.300
they really like to do this because it's very efficient.


00:54:13.300 --> 00:54:15.540
Sometimes following some heuristics,


00:54:15.540 --> 00:54:17.580
they can say, "Well, you're calling this function,


00:54:17.580 --> 00:54:19.460
"but this function is kind of small."


00:54:19.460 --> 00:54:23.400
So generating all the assembly code to prepare the call


00:54:23.400 --> 00:54:25.780
and finalize the call, plus all the locals


00:54:25.780 --> 00:54:28.660
and the stack and whatnot is kind of very expensive.


00:54:28.660 --> 00:54:30.780
So what they do basically is copy paste the code


00:54:30.780 --> 00:54:33.580
in the caller, and they set up everything


00:54:33.580 --> 00:54:36.920
so it works nicely, and the locals are not overwritten


00:54:36.920 --> 00:54:38.920
just because you use the name "foo" in both.


00:54:38.920 --> 00:54:41.720
So it kind of works, but the idea is that instead of calling


00:54:41.720 --> 00:54:44.480
a function, just copy-paste the code.


00:54:44.480 --> 00:54:49.260
But basically, the effect that this has on the backtrace


00:54:49.260 --> 00:54:51.260
is that there is no function call, so there is no function.


00:54:51.260 --> 00:54:53.840
So when you are calling that function, it disappears.


00:54:53.840 --> 00:54:55.840
So it's like you never call it.


00:54:55.840 --> 00:54:57.600
And this can be quite confusing when you're looking


00:54:57.600 --> 00:54:59.580
at stack trace because you have function B


00:54:59.580 --> 00:55:02.040
that calls function C, and C calls D,


00:55:02.040 --> 00:55:04.440
and the middle one is inline, you're not going to see it,


00:55:04.440 --> 00:55:06.240
and then you're going to say A calling C.


00:55:06.240 --> 00:55:07.840
And you say, well, there's no way that happens


00:55:07.840 --> 00:55:09.680
because I'm not calling C here.


00:55:09.680 --> 00:55:12.640
So this can make this kind of like backtrace


00:55:12.640 --> 00:55:13.920
is very confusing.


00:55:13.920 --> 00:55:14.760
- Yeah.


00:55:14.760 --> 00:55:16.480
This is in C, not in Python, right?


00:55:16.480 --> 00:55:18.000
Because Python doesn't have inlining.


00:55:18.000 --> 00:55:19.360
- Exactly.


00:55:19.360 --> 00:55:22.160
No, exactly, Python doesn't have inlining, that's true.


00:55:22.160 --> 00:55:24.000
We have something that we call inlining,


00:55:24.000 --> 00:55:25.240
but it's not the same thing.


00:55:25.240 --> 00:55:27.120
So I'm not going to explain that.


00:55:27.120 --> 00:55:28.520
- Compiler optimization type thing.


00:55:28.520 --> 00:55:29.360
- Right, right.


00:55:29.360 --> 00:55:33.760
Yeah, so there is no inlining in Python, that's correct, let's just leave it like that.


00:55:33.760 --> 00:55:37.200
And that is in C and C++ and Rust and whatnot.


00:55:37.200 --> 00:55:42.160
So if there is debugging information, we can recover these inline calls,


00:55:42.160 --> 00:55:47.760
which is something that by the way GDB can also do, but we can do it as well.


00:55:47.760 --> 00:55:50.560
So there is enough debugging information.


00:55:50.560 --> 00:55:53.040
We actually work in some cases when GDB doesn't,


00:55:53.040 --> 00:55:56.000
just because GDB tries to be very correct in some of these cases,


00:55:56.000 --> 00:56:00.460
but for whatever reason, it's overcorrect.


00:56:00.460 --> 00:56:03.000
We can actually do it most of the time.


00:56:03.000 --> 00:56:05.580
But yes, this is a feature that we do.


00:56:05.580 --> 00:56:08.300
So you have one of these inline calls,


00:56:08.300 --> 00:56:09.580
and we do more than that.


00:56:09.580 --> 00:56:12.940
So for instance, if you have extreme debug information


00:56:12.940 --> 00:56:15.320
that you can activate by passing, for instance,


00:56:15.320 --> 00:56:18.520
you compile something with GCC, you can pass -G3,


00:56:18.520 --> 00:56:22.360
that's debug information level 3, so put everything there.


00:56:22.360 --> 00:56:23.960
We can even show you macros.


00:56:23.960 --> 00:56:28.040
So you're using macros, which the macro expands to source, basically,


00:56:28.040 --> 00:56:30.040
and then that source is passed to the compiler.


00:56:30.040 --> 00:56:32.720
So there is no macro at the compiler level.


00:56:32.720 --> 00:56:34.420
The compiler is going to see the source itself


00:56:34.420 --> 00:56:37.520
because the processor kind of expands the macro.


00:56:37.520 --> 00:56:40.800
But there is a technique in the debugging information


00:56:40.800 --> 00:56:43.040
that can include the fact that there was a macro there.


00:56:43.040 --> 00:56:44.400
So we can show you the macro.


00:56:44.400 --> 00:56:45.760
We can say this was a macro.


00:56:45.760 --> 00:56:48.440
So we can pretend that that was a function call.


00:56:48.440 --> 00:56:49.880
That's quite cool.


00:56:49.880 --> 00:56:51.880
That's great. I didn't see that coming. Yeah.


00:56:51.880 --> 00:56:55.960
So when are we getting inlining of functions as an optimization in Python?


00:56:55.960 --> 00:57:02.920
Probably not soon. But to be honest, there is some interesting things that are close.


00:57:02.920 --> 00:57:10.120
There is this PEP that was approved to inline least comprehensions in function calls.


00:57:10.120 --> 00:57:11.640
Yes, I was about to say.


00:57:11.640 --> 00:57:17.960
But you see, as you can see, what I said, the consequence is that you basically copy paste


00:57:17.960 --> 00:57:19.960
so the function call disappears.


00:57:19.960 --> 00:57:21.960
This will happen in Python, by the way,


00:57:21.960 --> 00:57:23.960
so when the PEP is implemented,


00:57:23.960 --> 00:57:25.960
which, by the way, it is implemented,


00:57:25.960 --> 00:57:27.960
if I recall correctly,


00:57:27.960 --> 00:57:29.960
what happens is that you see a backtrace


00:57:29.960 --> 00:57:31.960
with PyStack, for instance,


00:57:31.960 --> 00:57:33.960
you're now going to see the list comprehension


00:57:33.960 --> 00:57:35.960
frame, which is fine, because most of the time


00:57:35.960 --> 00:57:37.960
it doesn't tell you anything, because it's going to tell you


00:57:37.960 --> 00:57:39.960
here's a list comprehension, and then


00:57:39.960 --> 00:57:41.960
you're calling a function called list comprehension,


00:57:41.960 --> 00:57:43.960
so it's kind of weird.


00:57:43.960 --> 00:57:45.960
But the interesting parts of list comprehensions


00:57:45.960 --> 00:57:48.520
comprehensions being function calls basically.


00:57:48.520 --> 00:57:50.400
I mean, it's not really functions call,


00:57:50.400 --> 00:57:52.060
is they have their own frame.


00:57:52.060 --> 00:57:53.160
But the interesting part here,


00:57:53.160 --> 00:57:55.600
which was one big change from Python 2 to Python 3,


00:57:55.600 --> 00:57:57.840
is that variables inside the comprehensions


00:57:57.840 --> 00:57:59.720
are local to the comprehension.


00:57:59.720 --> 00:58:01.200
Which means that you have a function,


00:58:01.200 --> 00:58:03.160
a variable called x outside,


00:58:03.160 --> 00:58:04.940
and then you use a variable called x inside,


00:58:04.940 --> 00:58:08.280
and you assign to that by using the comprehension name.


00:58:08.280 --> 00:58:10.740
The one outside is not modified, right?


00:58:10.740 --> 00:58:13.080
This is maintained here, even if it's in line,


00:58:13.080 --> 00:58:15.540
because even if it's in line, that is maintained.


00:58:15.540 --> 00:58:18.820
But there is some cases when that behavior is very, very


00:58:18.820 --> 00:58:21.020
tricky, particularly class scopes.


00:58:21.020 --> 00:58:23.700
So you have a comprehension in a class scope, which already


00:58:23.700 --> 00:58:26.340
is something weird to do, but you can absolutely do it.


00:58:26.340 --> 00:58:28.580
Like class scopes are quite wild.


00:58:28.580 --> 00:58:32.060
They are not-- they don't behave like function scopes.


00:58:32.060 --> 00:58:36.340
So there was a bunch of edge cases that we saw.


00:58:36.340 --> 00:58:39.660
So this comprehension inlining is deactivated on class scopes,


00:58:39.660 --> 00:58:42.460
for instance, just because there was some consequences


00:58:42.460 --> 00:58:43.740
of the inlining.


00:58:43.740 --> 00:58:45.820
There is some in the discussion of the PEP


00:58:45.820 --> 00:58:47.480
that is the case if you want to see it.


00:58:47.480 --> 00:58:48.440
He explained this here.


00:58:48.440 --> 00:58:49.740
It will be everywhere.


00:58:49.740 --> 00:58:52.120
But it's quite important because aligning always


00:58:52.120 --> 00:58:54.200
has consequences.


00:58:54.200 --> 00:58:55.860
One of them is the frame is missing.


00:58:55.860 --> 00:58:57.940
But this frame is not going to be missed by anyone


00:58:57.940 --> 00:58:59.980
because it doesn't really add anything.


00:58:59.980 --> 00:59:02.320
>>All right, so we sort of have them.


00:59:02.320 --> 00:59:03.820
One of the things I think is really


00:59:03.820 --> 00:59:06.880
cool about asking for information here,


00:59:06.880 --> 00:59:10.180
and it's just really helpful, maybe


00:59:10.180 --> 00:59:12.500
beyond even a good log message and stuff,


00:59:12.500 --> 00:59:15.500
is not only do you see the stack trace,


00:59:15.500 --> 00:59:18.260
the call stack here, when you--


00:59:18.260 --> 00:59:21.460
this line and this file called this function and so on,


00:59:21.460 --> 00:59:24.700
but you can see optionally the local variables, right?


00:59:24.700 --> 00:59:26.260
Yes.


00:59:26.260 --> 00:59:29.140
And what's extremely interesting about that is that


00:59:29.140 --> 00:59:33.060
you would normally need to call the dunder wrapper method


00:59:33.060 --> 00:59:35.600
of an object in order to figure out how to print it out


00:59:35.600 --> 00:59:38.300
in a user-friendly way, but we can't do that, right?


00:59:38.300 --> 00:59:40.160
We're working on crash processes.


00:59:40.160 --> 00:59:42.060
We're reading one byte of memory at a time


00:59:42.060 --> 00:59:43.180
to try to interpret it.


00:59:43.180 --> 00:59:45.020
So in order to give you these locals,


00:59:45.020 --> 00:59:47.740
PyStack needs to be able to understand


00:59:47.740 --> 00:59:49.740
the CPython representation of a list


00:59:49.740 --> 00:59:51.780
and know how to iterate over a list manually


00:59:51.780 --> 00:59:53.780
to figure out what elements it contains


00:59:53.780 --> 00:59:57.020
and recursively turn, recursively get the repper


00:59:57.020 --> 00:59:58.820
for each of those methods,


00:59:58.820 --> 00:59:59.880
or for each of those objects


00:59:59.880 --> 01:00:01.860
that are in the collection as well.


01:00:01.860 --> 01:00:04.580
It can't just rely on being able to call Python code


01:00:04.580 --> 01:00:06.180
to get you this string.


01:00:06.180 --> 01:00:08.700
- Right, and manually here means that it needs to know


01:00:08.700 --> 01:00:10.140
that at least in Python release,


01:00:10.140 --> 01:00:12.260
a bunch of pointers that points to a buffer


01:00:12.260 --> 01:00:14.100
and the buffer is a bunch of Py objects


01:00:14.100 --> 01:00:16.420
and then every object can be different.


01:00:16.420 --> 01:00:19.380
So obviously this means that we cannot print all objects.


01:00:19.380 --> 01:00:22.020
So if you have a custom object, we cannot print that.


01:00:22.020 --> 01:00:23.220
We will print something.


01:00:23.220 --> 01:00:25.220
We will tell you, for instance, the name of the class.


01:00:25.220 --> 01:00:29.180
We will say, we will almost act like if there is no report.


01:00:29.180 --> 01:00:33.780
So we will say custom object instance at location,


01:00:33.780 --> 01:00:34.620
blah, blah, blah.


01:00:34.620 --> 01:00:36.020
So the default report that you will get


01:00:36.020 --> 01:00:37.420
if you create a class.


01:00:37.420 --> 01:00:41.220
But for most of the common types, dictionary sets,


01:00:41.220 --> 01:00:44.920
integer floats, et cetera, functions, all of these things,


01:00:44.920 --> 01:00:46.920
we actually are able to print it.


01:00:46.920 --> 01:00:50.380
Again, here the idea is adding debugging,


01:00:50.380 --> 01:00:52.540
like help you debug these things.


01:00:52.540 --> 01:00:54.740
So obviously it's not going to be the same as,


01:00:54.740 --> 01:00:57.300
you know, having a debugger attached to something


01:00:57.300 --> 01:01:00.020
that you can inspect, but most of the time


01:01:00.020 --> 01:01:02.580
that you don't really need it because most of the time


01:01:02.580 --> 01:01:04.900
you need to know the locales is because


01:01:04.900 --> 01:01:06.800
you have a function call and the function call


01:01:06.800 --> 01:01:10.160
has a specific argument that are passed to the function


01:01:10.160 --> 01:01:11.920
and it modifies how the function behaves.


01:01:11.920 --> 01:01:14.160
Like for instance, imagine that it has a keyword argument


01:01:14.160 --> 01:01:16.600
and the keyword argument is strict or replaced


01:01:16.600 --> 01:01:21.040
like the unique encode call.


01:01:21.040 --> 01:01:23.620
So you really want to know if you pass one or the other


01:01:23.620 --> 01:01:26.580
because otherwise it's going to trigger different call paths.


01:01:26.580 --> 01:01:30.920
So that you use this, that's this locals option in PyS


01:01:30.920 --> 01:01:33.880
that you will see what arguments were passed


01:01:33.880 --> 01:01:35.640
to the functions and also the local variables


01:01:35.640 --> 01:01:39.840
the functions and if most of the time it's just this you know built-in types


01:01:39.840 --> 01:01:45.440
like lists or things like that then it's going to be very useful and it's going


01:01:45.440 --> 01:01:51.080
to be mostly a laugh I think I mean it's kind of weird being the authors we


01:01:51.080 --> 01:01:54.080
said this because obviously we're going to say nice things but I swear it's true


01:01:54.080 --> 01:01:58.720
every time I particularly myself needed this option the things that we were


01:01:58.720 --> 01:02:02.120
printing were the things that I needed to know so I didn't really need to know


01:02:02.120 --> 01:02:05.160
Because you will say, well, if I have a NumPy array,


01:02:05.160 --> 01:02:07.280
I won't see the array, right?


01:02:07.280 --> 01:02:09.200
You will show me NumPy array.


01:02:09.200 --> 01:02:12.880
Well, sure, but that won't help you debug the crashing code


01:02:12.880 --> 01:02:16.100
because it doesn't really matter what is in the NumPy array.


01:02:16.100 --> 01:02:18.560
- It's also fair to point out that if someone ever finds


01:02:18.560 --> 01:02:21.340
like a built-in type that they needed to know the value of


01:02:21.340 --> 01:02:24.040
in order to debug a problem, they can bring it to us


01:02:24.040 --> 01:02:25.520
and we can see if we can implement it.


01:02:25.520 --> 01:02:26.900
Benefits of open source.


01:02:26.900 --> 01:02:31.520
- Yeah, two thoughts sort of came up for me


01:02:31.520 --> 01:02:32.960
when I was listening, you all described that.


01:02:32.960 --> 01:02:35.240
And this is just such a cool feature.


01:02:35.240 --> 01:02:39.680
One, if it's a class, a custom object


01:02:39.680 --> 01:02:42.400
that does not have slots,


01:02:42.400 --> 01:02:44.280
you could grab just the dunderdick


01:02:44.280 --> 01:02:46.520
and kind of print it as a dict.


01:02:46.520 --> 01:02:47.960
Would be one, like if you...


01:02:47.960 --> 01:02:51.960
- Yes, but no.


01:02:51.960 --> 01:02:54.840
This is a very interesting question, actually, you ask.


01:02:54.840 --> 01:02:56.760
For instance, in Python 3.12,


01:02:56.760 --> 01:03:00.400
there is an optimization in which there is no dunderdick.


01:03:00.400 --> 01:03:03.520
So this is quite funny actually.


01:03:03.520 --> 01:03:05.800
It's quite funny because what happens is that


01:03:05.800 --> 01:03:07.400
this is one of the optimizations


01:03:07.400 --> 01:03:08.600
of the fastest CPython project.


01:03:08.600 --> 01:03:11.760
This I think was done by Inada Sun and Mark Shannon.


01:03:11.760 --> 01:03:16.440
So the idea here is that if you think about it,


01:03:16.440 --> 01:03:19.080
if you have a object that has a under dig, right?


01:03:19.080 --> 01:03:20.760
And it has a hash table,


01:03:20.760 --> 01:03:23.800
unless you want the dictionary itself


01:03:23.800 --> 01:03:26.080
and wants to just say, here is a dictionary.


01:03:26.080 --> 01:03:27.920
I can just, you know, take a photo


01:03:27.920 --> 01:03:29.880
and put it in a poster in my room


01:03:29.880 --> 01:03:30.880
because I like it.


01:03:30.880 --> 01:03:33.180
Unless you want the dictionary as itself,


01:03:33.180 --> 01:03:34.020
you normally want--


01:03:34.020 --> 01:03:35.320
- Should we maybe take a second


01:03:35.320 --> 01:03:37.660
to explain what DunderDict is?


01:03:37.660 --> 01:03:40.960
- All right, so most objects in Python,


01:03:40.960 --> 01:03:44.760
like you have a class, like my class, Animal.


01:03:44.760 --> 01:03:47.880
And Animal has a bunch of attributes like name and age,


01:03:47.880 --> 01:03:51.120
and like, you know, kind of animal or whatever.


01:03:51.120 --> 01:03:53.800
So in Python, those attributes are internally represented


01:03:53.800 --> 01:03:57.040
with a hash table, which in Python we call a dictionary.


01:03:57.040 --> 01:03:59.800
And you can ask the Python interpreter


01:03:59.800 --> 01:04:05.160
you that internal dictionary. So normally you will say myAnimal.name, that will print


01:04:05.160 --> 01:04:12.680
"Beebo" which is the name of my cat. But you can actually ask for that hash table that


01:04:12.680 --> 01:04:18.680
is internally, and for that you will need to know myAnimal.dunderdick, so __dick__,


01:04:18.680 --> 01:04:21.800
and that will give you the internal hash table with the name of all the attributes that you


01:04:21.800 --> 01:04:27.240
have. So it will show name, kind, age as strings, and they will show you the actual values.


01:04:27.240 --> 01:04:30.760
So that's normally how Python is represented internally.


01:04:30.760 --> 01:04:34.600
And when you do attribute access, internally goes to this hash table in


01:04:34.600 --> 01:04:39.480
different ways and fetches this out, right? But in Python 3.12, we said, well,


01:04:39.480 --> 01:04:43.480
among other things, because this optimization touches many things,


01:04:43.480 --> 01:04:48.200
really having a hash table represented with a full dictionary is a bit expensive


01:04:48.200 --> 01:04:52.200
because if you think about it, if you access an attribute,


01:04:52.200 --> 01:04:55.960
having the full hash table is not really needed. Among other things, because the


01:04:55.960 --> 01:05:00.160
because the Hashtable has a bunch of things that allow it to work as a Python object,


01:05:00.160 --> 01:05:01.920
but you don't really enjoy those things.


01:05:01.920 --> 01:05:06.080
Like for instance, it has a pointer to the class and it tells you, "I'm a dictionary,"


01:05:06.080 --> 01:05:08.880
but you already know it's a dictionary because that's what we put there.


01:05:08.880 --> 01:05:13.480
So having the whole full dictionary with reference counts and all that stuff as a normal Python


01:05:13.480 --> 01:05:20.240
object is expensive memory-wise, but also forces you to have a bunch of indirections.


01:05:20.240 --> 01:05:22.680
And we already have a bunch of optimizations here.


01:05:22.680 --> 01:05:25.000
For instance, one of the optimizations that we had


01:05:25.000 --> 01:05:27.680
is that if you have a class, let's say Animal again,


01:05:27.680 --> 01:05:29.760
most of the instances of the class, if not all,


01:05:29.760 --> 01:05:31.240
are going to have the same attributes


01:05:31.240 --> 01:05:34.800
because normally all animals, all cats have name,


01:05:34.800 --> 01:05:36.600
age, and whatever, right?


01:05:36.600 --> 01:05:38.600
You absolutely can add new attributes,


01:05:38.600 --> 01:05:40.560
so this is something that you can, but normally you don't.


01:05:40.560 --> 01:05:44.560
So what we do is that instead of storing the same names


01:05:44.560 --> 01:05:47.280
in the dictionary of every instance,


01:05:47.280 --> 01:05:48.920
we put those names in the class


01:05:48.920 --> 01:05:50.720
because they are going to be common.


01:05:50.720 --> 01:05:53.960
And then if you add kind of like extra attributes,


01:05:53.960 --> 01:05:56.160
we kind of add it to the dictionary after the fact.


01:05:56.160 --> 01:05:58.040
But there is already the diction,


01:05:58.040 --> 01:05:59.580
that dictionary is already weird.


01:05:59.580 --> 01:06:01.520
Like in the sense that sometimes the keys


01:06:01.520 --> 01:06:03.680
are outside the dictionary just because they're shared.


01:06:03.680 --> 01:06:07.000
This is the shared key dictionary optimization.


01:06:07.000 --> 01:06:08.600
So we went a step ahead


01:06:08.600 --> 01:06:10.880
and we just eliminated the dictionary.


01:06:10.880 --> 01:06:13.720
So now what we'll have is the internals of the hash table,


01:06:13.720 --> 01:06:15.080
like let's say row.


01:06:15.080 --> 01:06:18.560
So there is no Python object kind of wrapping around it.


01:06:18.560 --> 01:06:21.480
It's kind of like just raw pointers.


01:06:21.480 --> 01:06:24.520
And if only if you ask for that Dunderdigs


01:06:24.520 --> 01:06:25.360
and you want, you say,


01:06:25.360 --> 01:06:27.040
"Well, I don't care about your optimization,


01:06:27.040 --> 01:06:28.080
"just give me the hashtag."


01:06:28.080 --> 01:06:30.880
Because code that does that still needs to see the hashtag.


01:06:30.880 --> 01:06:32.040
We cannot break that.


01:06:32.040 --> 01:06:33.520
So only when you ask for the dictionary,


01:06:33.520 --> 01:06:37.300
we instantiate that dictionary and then we give it to you.


01:06:37.300 --> 01:06:40.260
So before calling Dunderdig was just getting a pointer


01:06:40.260 --> 01:06:41.880
and that's it, here's the dictionary.


01:06:41.880 --> 01:06:43.960
Now calling Dunderdig computes stuff.


01:06:43.960 --> 01:06:46.200
Like it just creates a dictionary on the fly


01:06:46.200 --> 01:06:47.560
and give it to you.


01:06:47.560 --> 01:06:51.040
which means, by the way, this is a nice piece of trivia.


01:06:51.040 --> 01:06:55.160
Before, if you want to calculate the approximate,


01:06:55.160 --> 01:06:56.720
because this is always approximate,


01:06:56.720 --> 01:07:00.000
there is no full way to say how big is my Python object


01:07:00.000 --> 01:07:01.040
and everything it contains,


01:07:01.040 --> 01:07:02.960
because Python objects are a graph,


01:07:02.960 --> 01:07:06.520
and that question, most of the time, doesn't make sense.


01:07:06.520 --> 01:07:09.080
For instance, Python objects point to their module,


01:07:09.080 --> 01:07:11.760
and you don't want to also include the module in the size,


01:07:11.760 --> 01:07:13.360
right, among other things.


01:07:13.360 --> 01:07:16.640
But if you want to know the size of, you know,


01:07:17.520 --> 01:07:20.120
custom object, you normally say size of the instance


01:07:20.120 --> 01:07:21.760
plus size of the dict.


01:07:21.760 --> 01:07:24.520
But now in Python 3.12, just by asking for the size


01:07:24.520 --> 01:07:26.920
of the dict by doing my instance.otherdict,


01:07:26.920 --> 01:07:29.040
you just make it bigger.


01:07:29.040 --> 01:07:31.680
So the real size of the object was actually smaller


01:07:31.680 --> 01:07:33.080
than what you will get.


01:07:33.080 --> 01:07:36.280
- I think that sounds like a great optimization,


01:07:36.280 --> 01:07:38.840
but it does make your life harder here.


01:07:38.840 --> 01:07:40.560
The other thought that I had is--


01:07:40.560 --> 01:07:42.640
- Well, I mean, it's nothing really harder,


01:07:42.640 --> 01:07:44.400
among other things, because we know already


01:07:44.400 --> 01:07:46.760
how to print dictionaries, so that's fine.


01:07:46.760 --> 01:07:48.920
If it's a dictionary, we print dictionaries.


01:07:48.920 --> 01:07:51.320
And if it's not a dictionary, we are already in the business


01:07:51.320 --> 01:07:53.760
of inspecting internal structures.


01:07:53.760 --> 01:07:57.320
And we know absolutely how to interpret parts of hash tables.


01:07:57.320 --> 01:07:59.120
And at the end of the day, what we have here


01:07:59.120 --> 01:08:01.320
is parts of hash tables for now.


01:08:01.320 --> 01:08:03.920
The problem here is more about what


01:08:03.920 --> 01:08:05.480
happens if it changes in the future.


01:08:05.480 --> 01:08:07.320
Because right now, for instance, it's easy.


01:08:07.320 --> 01:08:10.520
But as we optimize more and more in the next release,


01:08:10.520 --> 01:08:12.240
it's not going to be easy.


01:08:12.240 --> 01:08:14.000
And right now, we can say, well, we


01:08:14.000 --> 01:08:16.160
support this, this, that, and this other thing.


01:08:16.160 --> 01:08:19.360
And we means that every time a new Python version is published,


01:08:19.360 --> 01:08:21.000
we need to just go to all those things


01:08:21.000 --> 01:08:23.880
and check if they were changed, and then change our code,


01:08:23.880 --> 01:08:26.240
which is quite a lot of work.


01:08:26.240 --> 01:08:27.840
But if we support more types, it means


01:08:27.840 --> 01:08:29.680
that we need to do the same for more things.


01:08:29.680 --> 01:08:31.200
And sometimes it's harder, right?


01:08:31.200 --> 01:08:34.200
Especially custom objects, who knows what we find there.


01:08:34.200 --> 01:08:37.520
So we kind of stay away from that,


01:08:37.520 --> 01:08:40.240
because it may be a lot of work.


01:08:40.240 --> 01:08:42.520
>>You're already busy, like we established.


01:08:42.520 --> 01:08:43.880
All right.


01:08:43.880 --> 01:08:46.380
Let me just flip through here and see if there's anything else


01:08:46.380 --> 01:08:47.080
that we want to cover.


01:08:47.080 --> 01:08:48.920
I feel like that's pretty much it.


01:08:48.920 --> 01:08:52.200
Maybe just one more shout out to the pytest plugin


01:08:52.200 --> 01:08:54.160
and whatever else you all think we should--


01:08:54.160 --> 01:08:56.680
>>One last thing I think is interesting here just


01:08:56.680 --> 01:08:59.480
to highlight, which is kind of cool,


01:08:59.480 --> 01:09:04.400
is that in both our tools, so PyStack and the VarioLand,


01:09:04.400 --> 01:09:06.060
this kind of links into the conversation


01:09:06.060 --> 01:09:08.120
that we had before around the UX and how


01:09:08.120 --> 01:09:09.940
we put a lot of emphasis on UX and making


01:09:09.940 --> 01:09:11.640
these tools super easy.


01:09:11.640 --> 01:09:14.200
So for instance, as we mentioned before,


01:09:14.200 --> 01:09:15.720
we were talking about some of these features,


01:09:15.720 --> 01:09:17.840
and then I say, for instance, the inline, right?


01:09:17.840 --> 01:09:19.680
We said, well, if you have the right information,


01:09:19.680 --> 01:09:21.480
we do this, but as I said before,


01:09:21.480 --> 01:09:23.160
at the beginning of the podcast,


01:09:23.160 --> 01:09:25.640
I said, most of the things don't have the right information.


01:09:25.640 --> 01:09:28.120
So most people will say, well,


01:09:28.120 --> 01:09:29.440
what is this point of this, right?


01:09:29.440 --> 01:09:31.120
So, but then we said, okay,


01:09:31.120 --> 01:09:33.160
so we really want to make this thing easy.


01:09:33.160 --> 01:09:34.520
So we don't want to tell people,


01:09:34.520 --> 01:09:35.960
well, if you want to use this feature,


01:09:35.960 --> 01:09:37.080
then you need to install this thing


01:09:37.080 --> 01:09:38.400
and just find your distribution,


01:09:38.400 --> 01:09:40.920
how to, it's kind of annoying, right?


01:09:40.920 --> 01:09:43.200
So one of the things we leverage in both our tools,


01:09:43.200 --> 01:09:45.040
in PyStack and Membrane, is this thing


01:09:45.040 --> 01:09:48.460
that Matt mentioned before, this debugging for the server.


01:09:48.460 --> 01:09:50.400
So this means that in most distributions,


01:09:50.400 --> 01:09:52.240
the most modern distributions,


01:09:52.240 --> 01:09:53.640
so this means that the latest versions


01:09:53.640 --> 01:09:55.840
of Ubuntu, Debian, Fedora, Arc, Linux,


01:09:55.840 --> 01:09:59.360
it works on most of the new ones,


01:09:59.360 --> 01:10:02.880
there is a way that debugging tools can say,


01:10:02.880 --> 01:10:06.040
okay, I have here a binary, like let's say Python,


01:10:06.040 --> 01:10:07.880
and this binary doesn't have the right information,


01:10:07.880 --> 01:10:09.200
but I really need it.


01:10:09.200 --> 01:10:11.200
So can you give me the debug information?


01:10:11.200 --> 01:10:13.400
And it will download it automatically for you,


01:10:13.400 --> 01:10:14.640
so you don't need to do anything.


01:10:14.640 --> 01:10:15.720
The tool will do it for you.


01:10:15.720 --> 01:10:18.480
So it will figure out what debug information it needs


01:10:18.480 --> 01:10:20.640
from the processes analyzing.


01:10:20.640 --> 01:10:22.200
It will go to the distribution.


01:10:22.200 --> 01:10:24.560
It will say, hey, can you give me the information


01:10:24.560 --> 01:10:26.080
for this, this, this, and this?


01:10:26.080 --> 01:10:27.160
It will download it for you.


01:10:27.160 --> 01:10:29.240
It will automatically merge it to the binary,


01:10:29.240 --> 01:10:32.280
and it will use it for showing the inlines


01:10:32.280 --> 01:10:34.560
or the C code or whatever it is.


01:10:34.560 --> 01:10:36.200
This means that most of the time,


01:10:36.200 --> 01:10:37.560
what you will see is that the first time


01:10:37.560 --> 01:10:38.960
you analyze a Python process,


01:10:38.960 --> 01:10:41.880
it will take a bit more time just because you're downloading these files,


01:10:41.880 --> 01:10:43.380
and these files can be a bit big.


01:10:43.380 --> 01:10:45.520
It will tell you that it's doing it, right?


01:10:45.520 --> 01:10:47.520
And then it will--


01:10:47.520 --> 01:10:50.040
these files then are cached for subsequent calls,


01:10:50.040 --> 01:10:52.200
so you don't download it every single time.


01:10:52.200 --> 01:10:53.840
But then it just works by magic.


01:10:53.840 --> 01:10:55.640
So you have this kind of process,


01:10:55.640 --> 01:10:57.880
and you have the information, and voila, it just works.


01:10:57.880 --> 01:10:58.920
So you don't need to do anything.


01:10:58.920 --> 01:11:02.000
You don't need to know about the fact that you need the right information


01:11:02.000 --> 01:11:05.600
or the fact that your Python is optimized and doesn't have anything.


01:11:05.600 --> 01:11:07.200
You just work.


01:11:07.200 --> 01:11:08.080
It just works.


01:11:08.080 --> 01:11:10.080
So you just need a new enough distribution.


01:11:10.080 --> 01:11:12.320
And even if you don't have a new enough distribution,


01:11:12.320 --> 01:11:14.080
there's a way to set up in the old ones.


01:11:14.080 --> 01:11:16.400
But anyway, if you're using one of the latest support


01:11:16.400 --> 01:11:19.200
to the Ubuntu, Debian, Arc, Fedora, Red Hat,


01:11:19.200 --> 01:11:22.960
all of these have it, then magically it will just work,


01:11:22.960 --> 01:11:26.280
which is something that we really, really are happy about


01:11:26.280 --> 01:11:28.000
because it means that you don't need to know


01:11:28.000 --> 01:11:29.600
about all of these things.


01:11:29.600 --> 01:11:31.000
You will just get it.


01:11:31.000 --> 01:11:32.880
>>That's really fantastic and go out and grab it


01:11:32.880 --> 01:11:35.120
and just get it for you without you worrying about it.


01:11:35.120 --> 01:11:36.720
>>It feels magical.


01:11:36.720 --> 01:11:38.920
The first time I saw it, I need this.


01:11:38.920 --> 01:11:40.840
Like, this is the future.


01:11:40.840 --> 01:11:41.680
Like, this is the future.


01:11:41.680 --> 01:11:43.440
Because if you have to do this manually,


01:11:43.440 --> 01:11:44.760
it just makes you miserable.


01:11:44.760 --> 01:11:45.800
And I know how to do it.


01:11:45.800 --> 01:11:47.000
I know how you need to do it,


01:11:47.000 --> 01:11:48.480
and it still makes me miserable.


01:11:48.480 --> 01:11:50.880
So I don't want to do it.


01:11:50.880 --> 01:11:52.120
I just want the tool to figure it out.


01:11:52.120 --> 01:11:53.800
And these both tools do it.


01:11:53.800 --> 01:11:55.360
So that's kind of cool.


01:11:55.360 --> 01:11:56.800
- Yeah, that's fantastic.


01:11:56.800 --> 01:11:59.960
All right, guys, I think we're out of time here,


01:11:59.960 --> 01:12:01.560
but, you know, final thoughts.


01:12:01.560 --> 01:12:04.640
People are excited about PyStack.


01:12:04.640 --> 01:12:06.560
Matt, what would you tell them?


01:12:06.560 --> 01:12:08.520
Go ahead, check it out, how would they use it?


01:12:08.520 --> 01:12:10.240
- Yeah, try it out, download it.


01:12:10.240 --> 01:12:13.080
It's as easy as pip install PyStack,


01:12:13.080 --> 01:12:15.440
find something that isn't working the way you expect it to,


01:12:15.440 --> 01:12:18.040
point PyStack at it and see if you can figure it out.


01:12:18.040 --> 01:12:19.520
And of course we're open to contributions.


01:12:19.520 --> 01:12:22.160
So if you find especially issues,


01:12:22.160 --> 01:12:24.400
if you find something that's broken, let us know.


01:12:24.400 --> 01:12:28.200
If you find some platform it doesn't work on, let us know.


01:12:28.200 --> 01:12:32.240
But yeah, it is my single go-to debugging tool


01:12:32.240 --> 01:12:33.480
whenever something gets stuck


01:12:33.480 --> 01:12:35.280
or doesn't do what I'm expecting it to do


01:12:35.280 --> 01:12:37.400
when I run a Python command at a command prompt


01:12:37.400 --> 01:12:39.600
and it just doesn't return.


01:12:39.600 --> 01:12:40.960
I reach for this all the time.


01:12:40.960 --> 01:12:44.200
I'm convinced it's a very useful tool for people.


01:12:44.200 --> 01:12:45.400
- Yeah, it looks amazing.


01:12:45.400 --> 01:12:46.960
Pablo, final thoughts?


01:12:46.960 --> 01:12:49.000
- Yeah, the only thing I will add to what Matt said


01:12:49.000 --> 01:12:50.760
is that one of the things,


01:12:50.760 --> 01:12:53.320
in general, don't do only this thing for PyStack


01:12:53.320 --> 01:12:56.480
and our tools, do it for every tool that you use.


01:12:56.480 --> 01:12:59.320
Is that giving success a story,


01:12:59.320 --> 01:13:00.480
so when you use the tool


01:13:00.480 --> 01:13:02.320
in that particular challenging situation


01:13:02.320 --> 01:13:03.160
and it really worked,


01:13:03.160 --> 01:13:06.200
and you just say, "Wow, it just works."


01:13:06.200 --> 01:13:09.100
Just go to the repo, again, not only us,


01:13:09.100 --> 01:13:12.040
but any tool that you see that actually does this,


01:13:12.040 --> 01:13:14.240
and tell the maintainers what you were trying to do


01:13:14.240 --> 01:13:15.760
and that you were really happy.


01:13:15.760 --> 01:13:18.520
Among other things, this really helps maintainers


01:13:18.520 --> 01:13:20.080
because at the end of the day, you think about it,


01:13:20.080 --> 01:13:22.200
we are putting all this work and then we just get


01:13:22.200 --> 01:13:25.880
the case that it doesn't work, so it's a bit discouraging.


01:13:25.880 --> 01:13:27.960
So it will keep us happy, and that's kind of important


01:13:27.960 --> 01:13:30.480
in open source since these things are free.


01:13:30.480 --> 01:13:33.000
The other thing is that it allows us to know


01:13:33.000 --> 01:13:35.000
how people are using the tool.


01:13:35.000 --> 01:13:38.460
When we discuss new features and how we evolve the tool,


01:13:38.460 --> 01:13:41.040
we know how to do that.


01:13:41.040 --> 01:13:43.740
For instance, for memory, we have the Success Stories page,


01:13:43.740 --> 01:13:46.740
where you have... we're going to have the same as in Biostack.


01:13:46.740 --> 01:13:49.240
So if you just happen to use it and you like it,


01:13:49.240 --> 01:13:52.180
or you use it successfully to fix something, just tell us.


01:13:52.180 --> 01:13:55.980
We are super happy to learn from you and to know


01:13:55.980 --> 01:13:58.820
why it was useful to you and what kind of features you used


01:13:58.820 --> 01:14:00.820
from the tool so we can keep improving.


01:14:01.920 --> 01:14:03.120
Excellent.


01:14:03.120 --> 01:14:04.880
Yeah, I think that's a really great idea.


01:14:04.880 --> 01:14:07.040
I encourage people to do that as well.


01:14:07.040 --> 01:14:09.480
So Pablo, Matt, thanks for being on the show.


01:14:09.480 --> 01:14:11.120
- Always a pleasure, Michael.


01:14:11.120 --> 01:14:12.640
- Thanks for having us.

