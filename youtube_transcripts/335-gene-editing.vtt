WEBVTT

00:00:00.000 --> 00:00:25.000
Hey David. Hey Michael. Hey. How are you? I'm awesome. Thanks for being here on the YouTube channel and of course on Talk Python.me. It's going to be fun to talk about biology, genetics, and Python. Yeah, I'm excited to talk about it. Cool. All right, let's kick this off. David, welcome to Talk Python.me.


00:00:25.000 --> 00:00:28.000
- Thanks, Michael.


00:00:28.000 --> 00:00:29.280
It's great to be here.


00:00:29.280 --> 00:00:30.960
- Yeah, it's great to have you here.


00:00:30.960 --> 00:00:33.560
You know, one of the things I really love to explore


00:00:33.560 --> 00:00:38.560
is the somewhat non-traditional use cases of Python


00:00:38.560 --> 00:00:42.040
that are not straight down the, I'm building an API


00:00:42.040 --> 00:00:45.240
and something that talks to a database for a startup,


00:00:45.240 --> 00:00:46.280
right, something like that,


00:00:46.280 --> 00:00:50.160
but blending it with other technologies


00:00:50.160 --> 00:00:51.760
and science and whatnot,


00:00:51.760 --> 00:00:54.940
and genetics plus Python, it's gonna be interesting.


00:00:54.940 --> 00:00:57.760
- It sure is.


00:00:57.760 --> 00:01:01.640
- Yeah, so when you got into this,


00:01:01.640 --> 00:01:04.200
did you start out on the biology side


00:01:04.200 --> 00:01:06.700
or the programming side of the world?


00:01:06.700 --> 00:01:09.760
- I definitely started out on the biology side.


00:01:09.760 --> 00:01:12.000
Yeah, so I went all the way through grad school


00:01:12.000 --> 00:01:16.240
with relatively minimal formal programming experience.


00:01:16.240 --> 00:01:19.920
- Yeah, okay, so you studied biology and genetics


00:01:19.920 --> 00:01:22.380
and whatnot, and then how'd you end up here


00:01:22.380 --> 00:01:24.020
on a Python podcast?


00:01:24.020 --> 00:01:28.580
- Yeah, so I always thought that programming would be cool,


00:01:28.580 --> 00:01:30.900
but I didn't really have much of an opportunity


00:01:30.900 --> 00:01:32.780
through my undergraduate studies


00:01:32.780 --> 00:01:35.700
to really do much formal programming.


00:01:35.700 --> 00:01:37.580
I took one computer science class


00:01:37.580 --> 00:01:39.020
that my college had to offer.


00:01:39.020 --> 00:01:40.680
It was in C++.


00:01:40.680 --> 00:01:43.500
I think I wrote a Bogle program or something


00:01:43.500 --> 00:01:44.780
with some recursion in there.


00:01:44.780 --> 00:01:45.820
It was pretty fun.


00:01:46.740 --> 00:01:50.240
I didn't really get to use Python until graduate school.


00:01:50.240 --> 00:01:53.920
I was in a genetics course and we were basically tasked


00:01:53.920 --> 00:01:58.520
with doing some data analysis on published data


00:01:58.520 --> 00:02:01.600
and then reproducing some plots in a figure


00:02:01.600 --> 00:02:03.200
and then extending it further.


00:02:03.200 --> 00:02:07.880
My partner and I decided to learn Python,


00:02:07.880 --> 00:02:10.520
teach it to ourselves so that we could do this.


00:02:10.520 --> 00:02:12.320
We heard that it was a good way


00:02:12.320 --> 00:02:14.680
to do data analysis in biology.


00:02:14.680 --> 00:02:17.600
And so we basically taught it to ourselves


00:02:17.600 --> 00:02:22.600
and we used NumPy and some basic string searching


00:02:22.600 --> 00:02:24.960
and things to redo this analysis.


00:02:24.960 --> 00:02:27.120
And it was really amazing what we could do


00:02:27.120 --> 00:02:28.480
with Python for that.


00:02:28.480 --> 00:02:29.640
So we brought back--


00:02:29.640 --> 00:02:30.480
- That's awesome.


00:02:30.480 --> 00:02:31.600
How'd the learning project go?


00:02:31.600 --> 00:02:34.840
Like coming from not having a ton of programming,


00:02:34.840 --> 00:02:36.320
what was your experience like?


00:02:36.320 --> 00:02:40.400
- It was relatively easy, I would say.


00:02:40.400 --> 00:02:42.920
I think my brain sort of fits pretty well


00:02:42.920 --> 00:02:45.520
with how programming languages work,


00:02:45.520 --> 00:02:47.920
but it was definitely a lot in a short amount of time


00:02:47.920 --> 00:02:51.280
to really dive into how to make sure


00:02:51.280 --> 00:02:53.620
your while loops don't stay open


00:02:53.620 --> 00:02:54.920
and then someone tells you


00:02:54.920 --> 00:02:57.760
maybe you shouldn't use a while loop at all.


00:02:57.760 --> 00:03:00.800
I was learning a lot of things not to do right away.


00:03:00.800 --> 00:03:02.240
- Yeah, of course, but you had to get


00:03:02.240 --> 00:03:03.440
all the analysis done, right?


00:03:03.440 --> 00:03:06.640
So you gotta solve all the problems and power through.


00:03:06.640 --> 00:03:08.160
- Yeah, yeah, so we did.


00:03:08.160 --> 00:03:10.280
We got our analysis done there


00:03:10.280 --> 00:03:15.280
and we reproduced some plots and got some new analysis made.


00:03:15.280 --> 00:03:17.120
And I think we really just,


00:03:17.120 --> 00:03:19.440
I really came to appreciation of how much you can do


00:03:19.440 --> 00:03:20.560
in a short amount of time


00:03:20.560 --> 00:03:22.520
with just a little bit of coding knowledge


00:03:22.520 --> 00:03:24.600
or essentially none.


00:03:24.600 --> 00:03:27.280
- Yeah, I think that's really an important takeaway


00:03:27.280 --> 00:03:28.800
that a lot of people,


00:03:28.800 --> 00:03:30.600
you know, maybe many people listen to the podcast


00:03:30.600 --> 00:03:31.440
already kind of know,


00:03:31.440 --> 00:03:35.040
but I think looking in from the outside,


00:03:35.040 --> 00:03:37.600
it feels like, oh, I've got to, you know,


00:03:37.600 --> 00:03:40.200
go get a degree in this to be productive


00:03:40.200 --> 00:03:45.320
useful and really what you need is like a couple of weeks and a small problem and you're already


00:03:45.320 --> 00:03:52.760
there. Absolutely, yeah. I've definitely found that just learning through doing has been the way


00:03:52.760 --> 00:03:59.320
I've worked entirely. I have essentially no formal programming training, no coursework, and


00:03:59.320 --> 00:04:05.080
I'm using Python every day. That's fantastic. Yeah, I didn't take that much computer science


00:04:05.080 --> 00:04:08.960
that are just enough to do the extra stuff


00:04:08.960 --> 00:04:10.720
from my math degree.


00:04:10.720 --> 00:04:11.560
Very cool.


00:04:11.560 --> 00:04:13.200
All right, now how about today?


00:04:13.200 --> 00:04:16.500
You're working at Beam Therapeutics doing genetic stuff.


00:04:16.500 --> 00:04:18.840
Tell us about what you do day to day.


00:04:18.840 --> 00:04:22.120
- Yeah, so I'm on the computational sciences team


00:04:22.120 --> 00:04:23.520
at Beam Therapeutics.


00:04:23.520 --> 00:04:27.000
We're a gene editing company.


00:04:27.000 --> 00:04:30.480
So we develop these precision genetic medicines


00:04:30.480 --> 00:04:33.080
that are, we're trying to develop them


00:04:33.080 --> 00:04:36.080
to cure genetic diseases that are caused


00:04:36.080 --> 00:04:41.080
by single genetic changes in the genome.


00:04:41.080 --> 00:04:42.000
So one example of it--


00:04:42.000 --> 00:04:45.060
- You got a shift mutation or something like that?


00:04:45.060 --> 00:04:45.900
- Yep, yep.


00:04:45.900 --> 00:04:49.320
And so if you have one of these genetic changes,


00:04:49.320 --> 00:04:53.920
you might have a disease that is lifelong


00:04:53.920 --> 00:04:57.560
and there aren't any cures for most of these diseases.


00:04:57.560 --> 00:05:00.080
So we're trying to create these,


00:05:00.080 --> 00:05:02.980
we call them hopefully lifelong cures for patients,


00:05:02.980 --> 00:05:07.120
by changing the genetic code back to what it should be.


00:05:07.120 --> 00:05:09.020
- That's incredible.


00:05:09.020 --> 00:05:13.460
It seems really out of the future.


00:05:13.460 --> 00:05:18.460
I mean, I think it's one thing to understand genetics


00:05:18.460 --> 00:05:22.660
at play and it's even amazing to be able to read


00:05:22.660 --> 00:05:25.340
the gene sequences, but it's entirely another thing


00:05:25.340 --> 00:05:27.460
I think to say, and let's rewrite that.


00:05:27.460 --> 00:05:31.220
- Yeah, we're definitely at the cutting edge


00:05:31.220 --> 00:05:34.860
of a lot of biotechnology and science


00:05:34.860 --> 00:05:37.500
that has really come to a head in the last decade


00:05:37.500 --> 00:05:42.220
with CRISPR and technologies that use CRISPR,


00:05:42.220 --> 00:05:46.460
which ours do, to be able to precisely target


00:05:46.460 --> 00:05:51.140
genetic sequences, it's a really fascinating place to work


00:05:51.140 --> 00:05:52.580
and it's a privilege.


00:05:52.580 --> 00:05:56.620
- I bet, you know, a lot of people go to work


00:05:56.620 --> 00:05:59.480
and they end up writing what you might classify


00:05:59.480 --> 00:06:01.400
as forms over data.


00:06:01.400 --> 00:06:04.680
It's like, well, I need a view into this bit of our database


00:06:04.680 --> 00:06:06.600
or I need to be able to run a query


00:06:06.600 --> 00:06:09.400
to just see who's got the most sales this week


00:06:09.400 --> 00:06:10.640
or something like that.


00:06:10.640 --> 00:06:15.240
And that's important work and it's useful


00:06:15.240 --> 00:06:17.020
and there's cool design patterns


00:06:17.020 --> 00:06:18.200
and whatnot you can focus on.


00:06:18.200 --> 00:06:20.920
But it's also, it's not like what people dream


00:06:20.920 --> 00:06:22.800
of necessarily building when they wake up.


00:06:22.800 --> 00:06:26.480
But this kind of science, like maybe so, right?


00:06:26.480 --> 00:06:29.460
Like these are the really interesting problems


00:06:29.460 --> 00:06:32.000
that both have a positive outcome, right?


00:06:32.000 --> 00:06:35.180
You're helping cure disease, not just, you know,


00:06:35.180 --> 00:06:39.300
shave another one 100th of a percent off of a transaction


00:06:39.300 --> 00:06:41.460
that you get a key for, you know, something like that,


00:06:41.460 --> 00:06:42.960
right, from like in finance.


00:06:42.960 --> 00:06:46.180
- Yeah, I think we--


00:06:46.180 --> 00:06:48.700
- Yeah, you can use really cool tech to do it too,


00:06:48.700 --> 00:06:50.500
like programming wise.


00:06:50.500 --> 00:06:54.220
- Yeah, I mean, one of our dreams that we joke about


00:06:54.220 --> 00:06:57.300
on the computational team is that, like,


00:06:57.300 --> 00:06:59.900
it's conceivable one day we could say,


00:06:59.900 --> 00:07:04.460
like, hey, Alexa, how do we cure sickle cell disease?


00:07:04.460 --> 00:07:08.060
And it'll tell you what parts of our technology


00:07:08.060 --> 00:07:09.860
we should put together to cure that disease.


00:07:09.860 --> 00:07:12.700
And that's sort of like the pipe dream


00:07:12.700 --> 00:07:15.500
of where we could go if we combine all our data


00:07:15.500 --> 00:07:16.380
in the right ways.


00:07:16.380 --> 00:07:18.860
And I think all of the stuff we'll talk about today


00:07:18.860 --> 00:07:22.420
is really just laying out the framework for that.


00:07:22.420 --> 00:07:23.420
- Yeah, absolutely.


00:07:23.420 --> 00:07:24.700
So you mentioned CRISPR.


00:07:24.700 --> 00:07:28.000
maybe tell people a bit about that biotechnology.


00:07:28.000 --> 00:07:32.380
- Yeah, so CRISPR is a molecular machine


00:07:32.380 --> 00:07:37.060
which targets a very specific place


00:07:37.060 --> 00:07:40.280
in a specific genetic sequence.


00:07:40.280 --> 00:07:43.660
And so usually people are using CRISPR


00:07:43.660 --> 00:07:47.860
to target a specific place in the genome,


00:07:47.860 --> 00:07:49.660
a specific sequence.


00:07:49.660 --> 00:07:54.660
And what CRISPR does naturally is to cut at that point


00:07:54.660 --> 00:07:59.500
that sequence. So it'll cut in a very specific place in the genome.


00:07:59.500 --> 00:08:03.580
And as people who are using CRISPR,


00:08:03.580 --> 00:08:07.860
we can actually decide where it's going to cut by giving it a different


00:08:07.860 --> 00:08:10.620
targeting sequence. so this,


00:08:10.620 --> 00:08:15.380
this sort of like directed molecular machine is a basis of a whole new


00:08:15.380 --> 00:08:20.060
field of biotechnology using CRISPR and CRISPR derived technology.


00:08:20.780 --> 00:08:24.260
So our technology is like kind of a CRISPR 2.0


00:08:24.260 --> 00:08:26.540
where we don't use CRISPR to cut,


00:08:26.540 --> 00:08:29.660
we use the localization machinery


00:08:29.660 --> 00:08:32.460
and we add onto it another protein


00:08:32.460 --> 00:08:34.500
which just changes a base


00:08:34.500 --> 00:08:37.040
instead of cutting the DNA itself.


00:08:37.040 --> 00:08:39.140
So it's slight variation,


00:08:39.140 --> 00:08:42.580
but it's still using this same CRISPR technology.


00:08:42.580 --> 00:08:43.900
- Okay.


00:08:43.900 --> 00:08:48.900
So let me see if my not very knowledge filled background


00:08:50.300 --> 00:08:53.100
understand here is kind of a, has a decent analogy.


00:08:53.100 --> 00:08:59.060
So is it, does it work basically like you give it like almost like find and


00:08:59.060 --> 00:09:05.460
replace, like you give it a sequence of, of, pairs and it says, okay, if I


00:09:05.460 --> 00:09:11.420
find a TTC, a T like enough specificity and that it's like, that's the unique


00:09:11.420 --> 00:09:14.180
one, and then it does like cut at that point.


00:09:14.180 --> 00:09:15.180
Is that kind of how it works?


00:09:15.180 --> 00:09:16.420
Yep.


00:09:16.420 --> 00:09:18.300
It's pretty much just like that.


00:09:18.300 --> 00:09:21.180
You give it the sequence you want to target,


00:09:21.180 --> 00:09:24.500
and then if it finds that sequence in the genome,


00:09:24.500 --> 00:09:28.700
it will cut the genetic material, the DNA,


00:09:28.700 --> 00:09:31.740
at that position for normal CRISPR.


00:09:31.740 --> 00:09:33.580
>>Yeah.


00:09:33.580 --> 00:09:37.780
So when you're coming up with these cures--


00:09:37.780 --> 00:09:39.660
and we'll get to the Python in just a second,


00:09:39.660 --> 00:09:41.960
but I want to set the foundation of the science, right?


00:09:41.960 --> 00:09:43.780
So when you're coming up with these,


00:09:43.780 --> 00:09:46.900
and you say, we're going to rewrite the DNA to solve


00:09:46.900 --> 00:09:51.900
this problem, how do you do it on a large enough scale?


00:09:51.900 --> 00:09:54.540
Like how do you, I mean, how much of the body


00:09:54.540 --> 00:09:58.160
has to be changed for this to be permanent, right?


00:09:58.160 --> 00:10:01.980
- Right, it's definitely a tricky question.


00:10:01.980 --> 00:10:06.020
I think we definitely leverage human biology,


00:10:06.020 --> 00:10:08.860
how the human body works for a lot of these problems.


00:10:08.860 --> 00:10:12.680
For example, some of our leading drug candidates


00:10:12.680 --> 00:10:14.860
are for sickle cell disease.


00:10:14.860 --> 00:10:18.620
And because of the way sickle cell disease manifests


00:10:18.620 --> 00:10:23.180
in red blood cells, and red blood cells are created


00:10:23.180 --> 00:10:26.100
through a set of, through, there's a specific type of cell


00:10:26.100 --> 00:10:27.780
that creates red blood cells.


00:10:27.780 --> 00:10:30.460
And we can, if you access that type of cell


00:10:30.460 --> 00:10:35.460
and you cure a sickle cell in these progenitor cells,


00:10:35.460 --> 00:10:40.540
the stem cells, then you can create all red blood cells


00:10:40.540 --> 00:10:42.920
from a cured population.


00:10:42.920 --> 00:10:46.540
So if you can target it to the progenitor cells,


00:10:46.540 --> 00:10:50.260
you can cure sickle cell throughout the body essentially,


00:10:50.260 --> 00:10:53.560
because the symptoms are from the red blood cells.


00:10:53.560 --> 00:10:56.100
There's a lot of diseases that which,


00:10:56.100 --> 00:10:58.180
by curing a single organ,


00:10:58.180 --> 00:11:02.260
you can cure the symptoms of the disease.


00:11:02.260 --> 00:11:04.940
- All right, like diabetes or sickle cell anemia


00:11:04.940 --> 00:11:06.680
or something like that?


00:11:06.680 --> 00:11:10.380
- Yeah, like sickle cell diseases in the liver,


00:11:10.380 --> 00:11:13.120
like some blindnesses in the eye,


00:11:13.120 --> 00:11:15.960
by just targeting specifically where the symptoms occur,


00:11:15.960 --> 00:11:17.520
you can cure the disease.


00:11:17.520 --> 00:11:19.520
- Yeah, that's amazing.


00:11:19.520 --> 00:11:20.520
Is it a shot?


00:11:20.520 --> 00:11:22.120
Is it a blood transfusion?


00:11:22.120 --> 00:11:25.360
Or like, how do you deliver this stuff?


00:11:25.360 --> 00:11:29.880
- Yeah, delivery is a huge place of research.


00:11:29.880 --> 00:11:34.880
And it definitely depends on the type of targeting


00:11:34.880 --> 00:11:35.700
we're doing.


00:11:35.700 --> 00:11:36.880
So for something in the eye,


00:11:36.880 --> 00:11:39.200
it would probably be an injection.


00:11:39.200 --> 00:11:44.200
for something in the blood, it's slightly more complicated


00:11:44.200 --> 00:11:47.820
and it's not an injection.


00:11:47.820 --> 00:11:49.300
For something in the liver,


00:11:49.300 --> 00:11:53.860
it would probably be more akin to a injection


00:11:53.860 --> 00:11:56.220
or dosing regimen.


00:11:56.220 --> 00:11:57.780
- Yeah.


00:11:57.780 --> 00:12:00.020
Okay, it sounds really fascinating.


00:12:00.020 --> 00:12:01.700
Like I said, it feels like it's a little bit


00:12:01.700 --> 00:12:05.020
out of the future to be able to come up with these


00:12:05.020 --> 00:12:06.580
and just say, no, we're just gonna rewrite


00:12:06.580 --> 00:12:08.420
this little bit of the genetics.


00:12:08.420 --> 00:12:09.700
- And I think it'll be good.


00:12:09.700 --> 00:12:11.260
But if you can make it happen,


00:12:11.260 --> 00:12:13.880
it's pretty clear how it's obviously a benefit, right?


00:12:13.880 --> 00:12:16.140
Like those progenitor cells,


00:12:16.140 --> 00:12:18.180
they eventually have to recreate new ones.


00:12:18.180 --> 00:12:20.020
And then the way they do that is they clone


00:12:20.020 --> 00:12:23.540
their current copy of the DNA, which is the fixed one, right?


00:12:23.540 --> 00:12:25.300
So if you can get enough of them going,


00:12:25.300 --> 00:12:28.020
it'll just sort of propagate from there.


00:12:28.020 --> 00:12:28.840
- Yep.


00:12:28.840 --> 00:12:31.700
And we're also the benefit that sometimes


00:12:31.700 --> 00:12:34.420
you only need to cure a small fraction


00:12:34.420 --> 00:12:35.420
to remove the symptoms.


00:12:35.420 --> 00:12:38.220
And so lots of things going for us there.


00:12:38.220 --> 00:12:39.820
- Wow, that's awesome.


00:12:39.820 --> 00:12:43.140
So Derek, I'm sure there's a lot of people involved


00:12:43.140 --> 00:12:45.380
in this type of work.


00:12:45.380 --> 00:12:48.460
What exactly are you and your team working on?


00:12:48.460 --> 00:12:49.960
- Yeah, so our team,


00:12:49.960 --> 00:12:52.760
we call ourselves the computational sciences team.


00:12:52.760 --> 00:12:56.020
We really sit in the middle of the research


00:12:56.020 --> 00:12:58.820
and development arm of the organization,


00:12:58.820 --> 00:13:03.280
processing all of our sequencing data


00:13:03.280 --> 00:13:05.580
and some other data as well.


00:13:05.580 --> 00:13:10.580
And as you can imagine, with our technology changing DNA,


00:13:10.580 --> 00:13:16.180
changing genomes, there's a lot of sequencing data


00:13:16.180 --> 00:13:18.100
because what we're trying to do


00:13:18.100 --> 00:13:20.020
is change a genetic sequence.


00:13:20.020 --> 00:13:22.980
So we have to read out that genetic sequence


00:13:22.980 --> 00:13:25.180
and then figure out, has it changed?


00:13:25.180 --> 00:13:29.820
How many copies are changed and things like that.


00:13:29.820 --> 00:13:34.820
So the techniques of next generation sequencing,


00:13:35.180 --> 00:13:43.300
NGS are pretty broad, and we deal with a lot of different types of these next-generation


00:13:43.300 --> 00:13:46.880
sequencing assays that are being done at Beam.


00:13:46.880 --> 00:13:53.720
So our team really processes, analyzes, and collaborates with the experimental scientists


00:13:53.720 --> 00:13:57.040
on performing and developing these experiments.


00:13:57.040 --> 00:13:58.040
Cool.


00:13:58.040 --> 00:14:03.680
So the scientists will do some work and they'll attempt to use CRISPR-like technology to make


00:14:03.680 --> 00:14:10.160
changes and then they measure the changes they've made and it's you all sort of take that data and


00:14:10.160 --> 00:14:16.880
compare it and work with it. Right yeah and the act of measuring it's the act of measuring the


00:14:16.880 --> 00:14:24.480
changes itself is relatively computationally intensive so we run and support pipelines for


00:14:24.480 --> 00:14:31.520
all of these standard assays as well which is just as part of our our job. How much data is in


00:14:32.400 --> 00:14:38.560
DNA. I mean, I know that human biology stores or just biology stores an insane amount of data,


00:14:38.560 --> 00:14:44.160
but also computers store an insane amount of data and processing. So I'm not sure like which


00:14:44.160 --> 00:14:48.640
where the sort of trade off is, but what what sort of data are we talking about? How much?


00:14:48.640 --> 00:14:55.760
Yeah, I mean, it definitely depends on the type of assay that we're doing, like the scale of the


00:14:55.760 --> 00:15:01.040
the data, I would say, usually, we're not looking--


00:15:01.040 --> 00:15:03.520
sometimes we're looking at things that are looking at all


00:15:03.520 --> 00:15:07.240
the bases in the genome.


00:15:07.240 --> 00:15:11.880
More often, we're looking at defined regions of the genome


00:15:11.880 --> 00:15:13.480
where we're trying to make the change.


00:15:13.480 --> 00:15:14.480
>> This one gene is the problem, right?


00:15:14.480 --> 00:15:15.160
And let's look at that.


00:15:15.160 --> 00:15:15.960
>> Right, yeah.


00:15:15.960 --> 00:15:19.080
We're trying to target here, so that's where we're looking.


00:15:19.080 --> 00:15:20.960
It definitely depends on the assay.


00:15:20.960 --> 00:15:25.660
But I guess in terms of data scale, in terms of file sizes,


00:15:25.660 --> 00:15:28.240
perhaps that would be accessible.


00:15:28.240 --> 00:15:30.540
For standard things, it would be on the order


00:15:30.540 --> 00:15:35.540
of a few gigabytes per experimental run.


00:15:35.540 --> 00:15:38.580
For some of our larger assays,


00:15:38.580 --> 00:15:43.580
it's 10 to 100 times that per experiment.


00:15:43.580 --> 00:15:49.420
- That's a lot of data, but not impossible


00:15:49.420 --> 00:15:52.060
to transmit sort of amounts of data, right?


00:15:52.060 --> 00:15:53.380
Or store. - Right.


00:15:53.380 --> 00:15:55.680
- Yeah, I think every little piece of it


00:15:55.680 --> 00:15:57.440
is pretty manageable.


00:15:57.440 --> 00:16:00.000
When you start combining them together


00:16:00.000 --> 00:16:02.840
and looking at some down,


00:16:02.840 --> 00:16:04.380
like your downstream results and things,


00:16:04.380 --> 00:16:06.520
the data does get pretty large,


00:16:06.520 --> 00:16:08.240
but I wouldn't say we're at the scale


00:16:08.240 --> 00:16:12.040
of like big data analytics at Google or anything like that.


00:16:12.040 --> 00:16:13.480
- Yeah, yeah, or the LHC,


00:16:13.480 --> 00:16:17.120
if you've ever looked at the data flow layers at LHC,


00:16:17.120 --> 00:16:19.440
it's like the stuff near the collectors


00:16:19.440 --> 00:16:23.040
is just unimaginable amounts of data, right?


00:16:23.040 --> 00:16:26.200
Yeah, I haven't looked, but I'm sure it's certainly.


00:16:26.200 --> 00:16:28.120
- Yeah, they've got a lot of stuff built in,


00:16:28.120 --> 00:16:31.680
like on board the detectors to filter down a bunch,


00:16:31.680 --> 00:16:33.560
and then it goes for processing,


00:16:33.560 --> 00:16:34.920
then it gets filtered down some more,


00:16:34.920 --> 00:16:36.520
and then like eventually it gets to a point


00:16:36.520 --> 00:16:38.920
where like now we have enough space on hard drives


00:16:38.920 --> 00:16:40.720
to save it, but before that it was like,


00:16:40.720 --> 00:16:44.040
it couldn't be saved on hard drives, it was just too much.


00:16:44.040 --> 00:16:45.480
Yeah, very interesting.


00:16:45.480 --> 00:16:47.880
But it sounds to me like some of the real big challenges


00:16:47.880 --> 00:16:50.320
for you all is the computational bits, right?


00:16:50.320 --> 00:16:52.040
Because if you take all these things


00:16:52.040 --> 00:16:56.240
then you can end up in combinatorial comparison scenarios,


00:16:56.240 --> 00:16:59.800
I'm sure, that can really blow up the computing time.


00:16:59.800 --> 00:17:04.760
Yeah, I think definitely there's a lot of the challenges


00:17:04.760 --> 00:17:07.520
sometimes in these combinatorics,


00:17:07.520 --> 00:17:12.800
and there's also just a lot of steps that have to go on


00:17:12.800 --> 00:17:14.640
to process a lot of this data.


00:17:14.640 --> 00:17:19.520
There's a lot of biology-specific pieces of software


00:17:19.520 --> 00:17:21.800
that we use for various things,


00:17:21.800 --> 00:17:24.920
and we have to string them together


00:17:24.920 --> 00:17:28.720
to create a complete data processing pipeline.


00:17:28.720 --> 00:17:33.060
And a lot of that is part of our job,


00:17:33.060 --> 00:17:35.420
how to get all these tools to behave together


00:17:35.420 --> 00:17:39.360
and act in unison to actually process the data effectively.


00:17:39.360 --> 00:17:41.640
- I can just imagine some of these pipelines are tricky.


00:17:41.640 --> 00:17:45.460
It's like, well, okay, so it starts over here


00:17:45.460 --> 00:17:48.080
where the robot gets it and it reads this data


00:17:48.080 --> 00:17:49.800
and we can access that off the hard drive.


00:17:49.800 --> 00:17:52.440
and then it has to be sent to this Windows app


00:17:52.440 --> 00:17:54.680
that actually doesn't have an API.


00:17:54.680 --> 00:17:57.320
So we got to somehow like automate that thing


00:17:57.320 --> 00:17:59.000
and then get data out of it.


00:17:59.000 --> 00:18:01.400
And then is that what it's like?


00:18:01.400 --> 00:18:03.720
That's some of it.


00:18:03.720 --> 00:18:04.520
Tell us about your life.


00:18:04.520 --> 00:18:05.160
Okay.


00:18:05.160 --> 00:18:08.920
Yeah, there's a couple aspects that I think we might touch on.


00:18:08.920 --> 00:18:12.120
But for sequencing experiments,


00:18:12.120 --> 00:18:15.400
the pipelines are more defined


00:18:15.400 --> 00:18:16.760
because we usually get the data


00:18:16.760 --> 00:18:19.080
from a source that's already in the cloud,


00:18:19.080 --> 00:18:21.280
which I'm always happy about.


00:18:21.280 --> 00:18:23.560
If we can start in the cloud, we'll stay in the cloud.


00:18:23.560 --> 00:18:26.080
And that's a nice place to be.


00:18:26.080 --> 00:18:32.320
For data that's coming directly from instruments on premises,


00:18:32.320 --> 00:18:34.520
there is another layer of art that


00:18:34.520 --> 00:18:38.880
has to do with software on the instrument, software that


00:18:38.880 --> 00:18:41.120
gets the data to the cloud and moves it


00:18:41.120 --> 00:18:43.920
around between our other database sources.


00:18:43.920 --> 00:18:47.480
And that is some fun projects in itself there.


00:18:47.480 --> 00:18:49.380
- Yeah, I can imagine.


00:18:49.380 --> 00:18:51.680
I've worked in some areas where it's like


00:18:51.680 --> 00:18:53.740
collecting data from all these different things


00:18:53.740 --> 00:18:56.460
and then you know, to process it and move it along.


00:18:56.460 --> 00:19:00.140
And yeah, it's not always just send it


00:19:00.140 --> 00:19:04.420
from this Python function to that Python function


00:19:04.420 --> 00:19:05.300
to that Python function.


00:19:05.300 --> 00:19:08.240
There's a lot of janky stuff that wasn't really meant


00:19:08.240 --> 00:19:10.940
to be part of pipelines possibly.


00:19:10.940 --> 00:19:12.980
- Absolutely, yeah.


00:19:12.980 --> 00:19:16.580
- So with robots, do you have to actually talk


00:19:16.580 --> 00:19:21.940
to the robots, like any of the type of automated things?


00:19:21.940 --> 00:19:25.180
>>Yeah, for lab automation is what


00:19:25.180 --> 00:19:28.460
we call our team that has the robots,


00:19:28.460 --> 00:19:31.940
as we like to call them.


00:19:31.940 --> 00:19:36.820
As you can imagine, with a lot of these types of experiments,


00:19:36.820 --> 00:19:39.380
they can be made much more efficient


00:19:39.380 --> 00:19:44.660
if we can have robots doing the actual transfer of liquids


00:19:44.660 --> 00:19:47.900
and incubation and centrifugation,


00:19:47.900 --> 00:19:50.860
these scientific techniques that sometimes you


00:19:50.860 --> 00:19:53.120
need someone in the lab to do, but oftentimes you


00:19:53.120 --> 00:19:55.540
can automate them.


00:19:55.540 --> 00:19:59.700
And so the lab robotics aspect is an important part


00:19:59.700 --> 00:20:03.140
of how we can efficiently generate data.


00:20:03.140 --> 00:20:05.180
And a lot of the issues around that


00:20:05.180 --> 00:20:10.820
come with how to pass instructions to the instrument


00:20:10.820 --> 00:20:16.060
and how to get back data from the instrument when it's done.


00:20:16.060 --> 00:20:17.580
And then there's a whole other art


00:20:17.580 --> 00:20:20.420
of making the instruments actually


00:20:20.420 --> 00:20:23.020
orchestrate together, which is held


00:20:23.020 --> 00:20:25.820
in a different world of software.


00:20:25.820 --> 00:20:29.620
And I don't actually work on that part myself.


00:20:29.620 --> 00:20:31.960
>>That part of programming definitely seems a little bit


00:20:31.960 --> 00:20:36.460
magical, getting factories or little automations


00:20:36.460 --> 00:20:38.340
of different machines to work together.


00:20:38.340 --> 00:20:39.980
That's very cool.


00:20:39.980 --> 00:20:44.260
Yeah, there's a whole lot of proprietary software involved


00:20:44.260 --> 00:20:46.500
in actually running the instruments.


00:20:46.500 --> 00:20:49.620
But in terms of the problems in getting the data to them,


00:20:49.620 --> 00:20:53.300
I think it's one of those-- it could be a relatively common


00:20:53.300 --> 00:20:55.860
software problem of getting information


00:20:55.860 --> 00:20:58.780
from somewhere in the cloud.


00:20:58.780 --> 00:21:03.860
We have electronic lab notebooks and laboratory data systems


00:21:03.860 --> 00:21:05.220
that are in the cloud.


00:21:05.220 --> 00:21:09.220
And users will be submitting information


00:21:09.220 --> 00:21:13.580
about how they want their samples processed by the robots.


00:21:13.580 --> 00:21:16.300
And then there's the problem of getting that


00:21:16.300 --> 00:21:18.220
to the instruments themselves.


00:21:18.220 --> 00:21:21.680
And I think it actually sort of reminded me


00:21:21.680 --> 00:21:25.200
of the talks you guys had in episode, I think it was 327,


00:21:25.200 --> 00:21:27.140
the small automation projects.


00:21:27.140 --> 00:21:28.180
- Yeah, yeah.


00:21:28.180 --> 00:21:30.660
- We ended up with quite a few of those here


00:21:30.660 --> 00:21:33.340
where we have these relatively small tasks


00:21:33.340 --> 00:21:36.680
of take data from an API,


00:21:36.680 --> 00:21:39.720
put it somewhere where a robot can access it.


00:21:39.720 --> 00:21:42.680
Usually we use AWS S3.


00:21:42.680 --> 00:21:47.960
And these sort of very small data handling tasks


00:21:47.960 --> 00:21:51.120
end up being these nice little projects


00:21:51.120 --> 00:21:53.840
for Python to come into play.


00:21:53.840 --> 00:21:55.240
- Oh, that's awesome.


00:21:55.240 --> 00:21:57.960
I can see that that definitely happens, right?


00:21:57.960 --> 00:22:00.200
If a file shows up here,


00:22:00.200 --> 00:22:02.040
grab it, upload it to that bucket


00:22:02.040 --> 00:22:04.800
and name it whatever the active experiment is


00:22:04.800 --> 00:22:06.560
with the data or something like that, right?


00:22:06.560 --> 00:22:09.120
That's a very small program to write,


00:22:09.120 --> 00:22:12.280
but then that becomes a building block in this flow,


00:22:12.280 --> 00:22:14.840
putting these pieces and machines together.


00:22:14.840 --> 00:22:15.680
- Right, yeah.


00:22:15.680 --> 00:22:18.120
And then once it comes into the cloud,


00:22:18.120 --> 00:22:21.160
we do another set of data processing on it.


00:22:21.160 --> 00:22:24.200
We upload it to our current databases


00:22:24.200 --> 00:22:29.200
and all of that we orchestrate on AWS using,


00:22:29.200 --> 00:22:34.280
I guess they call it the serverless design patterns.


00:22:34.280 --> 00:22:38.440
So we don't have to handle anything on our own computers.


00:22:38.440 --> 00:22:39.340
- Yeah, that's really nice.


00:22:39.340 --> 00:22:41.480
And the serverless stuff probably helps you


00:22:41.480 --> 00:22:46.080
avoid running just tons of VMs in the cloud, right?


00:22:46.080 --> 00:22:47.360
Like it can all be on demand.


00:22:47.360 --> 00:22:51.560
Like the Lambda trigger is a file appears in this S3 bucket.


00:22:51.560 --> 00:22:54.760
So then it starts down the flow, right?


00:22:54.760 --> 00:22:55.680
- Absolutely, yeah.


00:22:55.680 --> 00:22:58.920
I really don't like maintaining a lot of infrastructure,


00:22:58.920 --> 00:23:01.000
although we do have a good amount of it


00:23:01.000 --> 00:23:02.520
that we do have to maintain.


00:23:02.520 --> 00:23:05.720
I find that these small Python functions


00:23:05.720 --> 00:23:10.040
are the perfect use case for those event-driven


00:23:10.040 --> 00:23:12.280
Lambda functions, which are running these


00:23:12.280 --> 00:23:14.280
very simple pieces of code.


00:23:14.280 --> 00:23:16.440
When an object appears in S3,


00:23:16.440 --> 00:23:20.520
they get a small event about when the object was uploaded,


00:23:20.520 --> 00:23:23.200
and then they do their thing,


00:23:23.200 --> 00:23:24.920
a little bit of data conversion,


00:23:24.920 --> 00:23:29.720
send it to an API, and now the data is in our data store.


00:23:29.720 --> 00:23:31.920
And those things just happen,


00:23:31.920 --> 00:23:33.460
and they're super consistent.


00:23:33.460 --> 00:23:36.840
They don't require anything on my end to maintain.


00:23:36.840 --> 00:23:39.120
It's a pretty beautiful pattern.


00:23:39.120 --> 00:23:39.960
- That's awesome.


00:23:39.960 --> 00:23:42.400
They don't need things like,


00:23:42.400 --> 00:23:45.500
oh, there's a new kernel for Linux


00:23:45.500 --> 00:23:46.760
that patches the vulnerability.


00:23:46.760 --> 00:23:49.800
So let's go and patch our functions, right?


00:23:49.800 --> 00:23:52.280
Just, it's all magic.


00:23:52.280 --> 00:23:53.840
It all happens on its own.


00:23:53.840 --> 00:23:57.120
- Right, and it does feel like magic a lot of the time.


00:23:57.120 --> 00:23:59.640
Yeah, setting them up can be a little bit of a challenge,


00:23:59.640 --> 00:24:02.520
but once they're there, they're very consistent.


00:24:02.520 --> 00:24:03.920
- Yeah, yeah, cool.


00:24:03.920 --> 00:24:05.960
One of the things you talked about doing,


00:24:05.960 --> 00:24:09.800
using was the AWS CDK or Cloud Development Kit.


00:24:09.800 --> 00:24:13.800
I think I've heard of this before,


00:24:13.800 --> 00:24:15.680
but it's like, I don't,


00:24:15.680 --> 00:24:18.120
I've definitely not used this personally.


00:24:18.120 --> 00:24:20.280
Tell us where this, what is this?


00:24:20.280 --> 00:24:21.200
How's it help you?


00:24:21.200 --> 00:24:24.200
- Right, so I, one of the,


00:24:24.200 --> 00:24:28.120
when I started dabbling with these Lambda functions,


00:24:28.120 --> 00:24:34.120
what I found pretty soon after I had four or five of these functions


00:24:34.120 --> 00:24:38.580
which I had uploaded on the AWS console,


00:24:38.580 --> 00:24:40.580
and if anyone's used that,


00:24:40.580 --> 00:24:44.960
know that it can be pretty tedious once you have a few things running,


00:24:44.960 --> 00:24:47.940
getting all your permissions and things set up.


00:24:47.940 --> 00:24:52.400
And I was looking for better ways to do this


00:24:52.400 --> 00:25:00.160
And it was at that point, it was early days for this AWS cloud development kit, AWS CDK.


00:25:00.160 --> 00:25:11.440
And what it is, is a way to write your infrastructure as code in essentially any common language, programming language.


00:25:11.440 --> 00:25:17.600
So you can write JavaScript, TypeScript, I think you can do Java, Go and Python, perhaps.


00:25:19.240 --> 00:25:24.740
And using it, you can define your cloud infrastructure


00:25:24.740 --> 00:25:28.840
in an object-oriented way with all the parameters they need.


00:25:28.840 --> 00:25:33.520
And you can deploy it to different AWS accounts,


00:25:33.520 --> 00:25:35.920
you can take it down, you can reconfigure it,


00:25:35.920 --> 00:25:40.060
you can look at how it's changed since your last commit,


00:25:40.060 --> 00:25:43.460
and you can store all that configuration in source control.


00:25:43.460 --> 00:25:47.360
And this has allowed us to scale up


00:25:47.360 --> 00:25:49.660
in terms of number of Lambda functions,


00:25:49.660 --> 00:25:53.240
I think we have maybe 60 or something now,


00:25:53.240 --> 00:25:56.280
which would be unmaintainable in the council.


00:25:56.280 --> 00:25:59.840
But they're essentially just completely maintained


00:25:59.840 --> 00:26:01.680
inside of source control these days


00:26:01.680 --> 00:26:04.740
using AWS CDK and Python.


00:26:04.740 --> 00:26:06.880
- Yeah, it seems super neat.


00:26:06.880 --> 00:26:10.120
I have not used it, but on the page,


00:26:10.120 --> 00:26:12.400
which I'll link to in the show notes,


00:26:12.400 --> 00:26:17.240
they have Werner Vogels, the CTO of Amazon,


00:26:17.240 --> 00:26:21.880
AWS and talks about some of the benefits


00:26:21.880 --> 00:26:23.720
and kind of how it all fits together.


00:26:23.720 --> 00:26:28.120
And like you said, you can store your cloud structure


00:26:28.120 --> 00:26:29.680
definition in source control.


00:26:29.680 --> 00:26:32.240
You can run unit tests against your infrastructure to say,


00:26:32.240 --> 00:26:34.200
if I apply all these commands to AWS,


00:26:34.200 --> 00:26:36.960
so I actually get what I was hoping to get out of it.


00:26:36.960 --> 00:26:40.240
And yeah, it seems like a really neat thing


00:26:40.240 --> 00:26:43.000
for this infrastructure as code bits.


00:26:43.000 --> 00:26:45.720
- Yeah, and I think it, I mean, it definitely really shines


00:26:45.720 --> 00:26:50.100
when you're developing larger pieces of infrastructure.


00:26:50.100 --> 00:26:52.840
But I would actually encourage people to check it out,


00:26:52.840 --> 00:26:57.020
even if they have a small automation type project.


00:26:57.020 --> 00:26:58.060
This is what I was thinking of


00:26:58.060 --> 00:27:00.820
when I was listening to episode 327 the other day.


00:27:00.820 --> 00:27:03.480
When you have these things you'd want to run


00:27:03.480 --> 00:27:06.980
on your computer with a cron job,


00:27:06.980 --> 00:27:10.940
you can actually run them for free on AWS Lambda.


00:27:10.940 --> 00:27:14.700
You get a bunch of free time on the free tier.


00:27:14.700 --> 00:27:17.820
and you try it out, you don't need to make sure


00:27:17.820 --> 00:27:21.440
your system D process or whatever is running.


00:27:21.440 --> 00:27:24.400
And it's a pretty cool way to get familiar


00:27:24.400 --> 00:27:28.940
with how to do some of these things on AWS.


00:27:28.940 --> 00:27:31.860
I'm not sure if this also exists for other cloud providers.


00:27:31.860 --> 00:27:35.060
We use AWS in particular, so that's what I know,


00:27:35.060 --> 00:27:39.140
but it may also exist for things like Azure and Google Cloud.


00:27:39.140 --> 00:27:40.100
- Sure.


00:27:40.100 --> 00:27:41.580
Yeah, maybe, I don't know if it does either,


00:27:41.580 --> 00:27:43.300
but it definitely seems useful


00:27:43.300 --> 00:27:45.800
for what you all are doing there.


00:27:45.800 --> 00:27:48.280
One of the things it could be useful for,


00:27:48.280 --> 00:27:49.720
and one of the challenges I suspect


00:27:49.720 --> 00:27:51.880
that you run into more than a lot of places,


00:27:51.880 --> 00:27:53.680
certainly more than like an e-commerce site


00:27:53.680 --> 00:27:57.160
or something like that, is reproducibility, right?


00:27:57.160 --> 00:28:01.560
If you're going to say, we're gonna come up with a treatment


00:28:01.560 --> 00:28:04.660
that literally gets injected into people,


00:28:04.660 --> 00:28:06.640
you've gotta go through FDA,


00:28:06.640 --> 00:28:10.560
you've gotta have possibly peer-reviewed stuff.


00:28:10.560 --> 00:28:15.560
there's a lot of reproducibility and data stewardship


00:28:15.560 --> 00:28:18.400
going on, I imagine, right?


00:28:18.400 --> 00:28:19.300
- Absolutely.


00:28:19.300 --> 00:28:21.640
That's definitely the case.


00:28:21.640 --> 00:28:24.360
We are very cognizant of the fact


00:28:24.360 --> 00:28:26.260
that we have to make our software


00:28:26.260 --> 00:28:28.520
as reproducible as possible.


00:28:28.520 --> 00:28:30.460
I think a lot of that lends itself


00:28:30.460 --> 00:28:33.960
to just using good development practices,


00:28:33.960 --> 00:28:37.280
containerizing everything that you're doing


00:28:37.280 --> 00:28:41.680
for data processing, pinning all your versions,


00:28:41.680 --> 00:28:45.000
appropriate source control, all of these things.


00:28:45.000 --> 00:28:48.120
And the infrastructure is definitely a piece of that


00:28:48.120 --> 00:28:52.160
because if we can't deploy the pipeline in the same way


00:28:52.160 --> 00:28:55.640
a year from now, we won't be able to get the same results


00:28:55.640 --> 00:28:58.580
from the data, and that's the problem.


00:28:58.580 --> 00:29:02.040
- That's a big challenge.


00:29:02.040 --> 00:29:02.900
It's tricky, right?


00:29:02.900 --> 00:29:06.380
Because things like containers and source control,


00:29:06.380 --> 00:29:09.020
that'll absolutely get you very far.


00:29:09.020 --> 00:29:13.380
But then you're also depending on these external things


00:29:13.380 --> 00:29:16.420
that have been very stable and very likely will be


00:29:16.420 --> 00:29:18.980
like Lambda, for example.


00:29:18.980 --> 00:29:22.100
But what if Amazon went out of business?


00:29:22.100 --> 00:29:25.260
Which is kind of laughable, right?


00:29:25.260 --> 00:29:28.260
It's only like doubled its revenue this year or something.


00:29:28.260 --> 00:29:33.180
But theoretically, it's possible that AWS decided


00:29:33.180 --> 00:29:34.940
to shut down or something like that.


00:29:35.980 --> 00:29:37.720
- Yeah, it's definitely true.


00:29:37.720 --> 00:29:39.480
- These are trade-off, right?


00:29:39.480 --> 00:29:41.080
But at the same time, it's so enabling


00:29:41.080 --> 00:29:43.560
for you to just scale out all this workload.


00:29:43.560 --> 00:29:48.940
- Yeah, I mean, in terms of how we create data pipelines,


00:29:48.940 --> 00:29:52.340
I think a lot of the ways we do it,


00:29:52.340 --> 00:29:56.260
we do have to be aware of creating them in a way


00:29:56.260 --> 00:29:59.960
that you can run them outside of the cloud.


00:29:59.960 --> 00:30:03.400
Sometimes we need to allow a third party


00:30:03.400 --> 00:30:06.800
to run our data analysis in a regulated way.


00:30:06.800 --> 00:30:10.800
And that requires us to have essentially


00:30:10.800 --> 00:30:13.100
running it internally, we run it in the cloud,


00:30:13.100 --> 00:30:15.300
which is efficient for scaling,


00:30:15.300 --> 00:30:18.640
but we also need to be able to take that same piece


00:30:18.640 --> 00:30:22.320
of software and run it in a way that may not be on AWS,


00:30:22.320 --> 00:30:23.880
it may not be in the cloud at all.


00:30:23.880 --> 00:30:27.500
And that creates some interesting software challenges.


00:30:27.500 --> 00:30:30.480
- Yeah, I'm sure because so many of the APIs


00:30:30.480 --> 00:30:32.040
are cloud native, right?


00:30:32.040 --> 00:30:35.560
you import Bodo, Bodo do this thing


00:30:35.560 --> 00:30:37.060
or something like that, right?


00:30:37.060 --> 00:30:40.120
How do you deal with that?


00:30:40.120 --> 00:30:42.720
- I think a lot of it comes down to


00:30:42.720 --> 00:30:47.220
structuring your workflows and your data pipelines


00:30:47.220 --> 00:30:51.440
in ways that are, they're not really using the cloud


00:30:51.440 --> 00:30:54.280
as much as they're using the cloud as a,


00:30:54.280 --> 00:30:56.920
they're using the cloud as both a file system


00:30:56.920 --> 00:31:00.520
and a way to gain compute,


00:31:00.520 --> 00:31:02.760
but they're not using any piece of the cloud


00:31:02.760 --> 00:31:05.960
to actually affect the data processing itself.


00:31:05.960 --> 00:31:09.800
So ideally, if you create the data pipeline


00:31:09.800 --> 00:31:13.060
in a way that is appropriate,


00:31:13.060 --> 00:31:18.000
you can both run it in the cloud and run it locally


00:31:18.000 --> 00:31:21.920
and achieve identical results because it's containerized.


00:31:21.920 --> 00:31:25.540
Primarily, that's the reason, I guess.


00:31:25.540 --> 00:31:30.440
But doing that, I think, is a challenge in itself.


00:31:30.440 --> 00:31:35.060
It's really like the process of getting a data pipeline built


00:31:35.060 --> 00:31:38.620
is a big ask in our field.


00:31:38.620 --> 00:31:41.340
I think a lot of companies spend a lot of time


00:31:41.340 --> 00:31:43.220
thinking about this.


00:31:43.220 --> 00:31:45.680
Yeah, I'm sure they do.


00:31:45.680 --> 00:31:48.460
Getting it right is a huge enabler, right?


00:31:48.460 --> 00:31:50.620
So let's talk about the process of maybe coming up


00:31:50.620 --> 00:31:52.780
with a new data pipeline.


00:31:52.780 --> 00:31:57.340
What does a software project look like for you all?


00:31:57.340 --> 00:32:03.060
Yeah, so it usually begins with a collaborative meeting


00:32:03.060 --> 00:32:04.820
with some experimental scientists


00:32:04.820 --> 00:32:08.260
where we discuss what's the experimental design going


00:32:08.260 --> 00:32:11.820
to be like, what are we going to be looking at in the data,


00:32:11.820 --> 00:32:14.460
and then the experimentalists will go


00:32:14.460 --> 00:32:19.820
and they'll generate some form of sequencing data.


00:32:19.820 --> 00:32:23.820
At that point, we generally take the data,


00:32:23.820 --> 00:32:31.260
open up some Jupyter notebooks or some small Python, sometimes even just bash scripts,


00:32:31.260 --> 00:32:34.980
to try to use some of those standard third-party tools.


00:32:34.980 --> 00:32:39.340
These are things like making sure all the sequences are aligned to each other so that


00:32:39.340 --> 00:32:44.700
you know when there's differences and making sure the quality is correct and things like


00:32:44.700 --> 00:32:45.700
that.


00:32:45.700 --> 00:32:50.460
These are pretty standard bioinformatics things.


00:32:50.460 --> 00:32:58.900
And for sequencing assays, there's usually a couple spots where there's some real experimental


00:32:58.900 --> 00:33:06.380
logic going into it, where often we'll have to write custom code in Python to say, "If


00:33:06.380 --> 00:33:09.380
there's this sequence here, it means we should keep the sequence.


00:33:09.380 --> 00:33:13.660
And if there's this sequence here, we should divide the sequence in half," or something


00:33:13.660 --> 00:33:14.740
like that.


00:33:14.740 --> 00:33:17.300
And so that code gets written in Python.


00:33:17.300 --> 00:33:21.700
Maybe it's in the Jupyter notebook or another script.


00:33:21.700 --> 00:33:26.900
And we sort of do this really slow testing depending on the size of the data.


00:33:26.900 --> 00:33:34.780
It might be locally on a laptop or in a small cloud-based HPC type cluster.


00:33:34.780 --> 00:33:36.280
So this is where we're doing.


00:33:36.280 --> 00:33:38.660
- You're not trying to process all the results.


00:33:38.660 --> 00:33:43.540
You just want to spot check and see if it's coming out right before you turn it loose,


00:33:43.540 --> 00:33:44.540
right?


00:33:44.540 --> 00:33:45.540
- Right.


00:33:45.540 --> 00:33:46.540
Or we're very patient.


00:33:46.540 --> 00:33:48.260
a little bit about it.


00:33:48.260 --> 00:33:52.460
Sometimes it's very difficult to take only a small fraction


00:33:52.460 --> 00:33:55.820
of the data, but we try when we can.


00:33:55.820 --> 00:33:58.380
And so I guess once we've settled on something


00:33:58.380 --> 00:34:01.180
that we think is pretty locked down,


00:34:01.180 --> 00:34:04.180
we'll take it out of the Jupyter notebooks.


00:34:04.180 --> 00:34:06.700
We don't try to use Paper Mill or anything like that.


00:34:06.700 --> 00:34:09.740
We try to get it out of there as soon as possible


00:34:09.740 --> 00:34:11.900
into some more complex scripts.


00:34:11.900 --> 00:34:14.140
They might be a shell script that


00:34:14.140 --> 00:34:17.180
runs a number of other scripts in order,


00:34:17.180 --> 00:34:21.280
or we might start using some sort of workflow manager.


00:34:21.280 --> 00:34:27.440
The workflow managers in bioinformatics are pretty common


00:34:27.440 --> 00:34:29.340
because everyone has the same problem


00:34:29.340 --> 00:34:32.580
of running all these third-party tools together


00:34:32.580 --> 00:34:33.980
and custom code.


00:34:33.980 --> 00:34:36.340
- Right, it's a lot of shared tools as well, probably.


00:34:36.340 --> 00:34:38.980
Right, they all use this library or that app.


00:34:38.980 --> 00:34:39.820
- Absolutely, yeah.


00:34:39.820 --> 00:34:41.060
There's definitely-- - There's LabView


00:34:41.060 --> 00:34:42.940
or whatever it is, right?


00:34:42.940 --> 00:34:46.100
there's a whole bunch of standard bioinformatics tools


00:34:46.100 --> 00:34:48.420
that we run on almost everything.


00:34:48.420 --> 00:34:51.860
And so some of the workflow managers are designed


00:34:51.860 --> 00:34:54.120
to specifically work very well with those tools


00:34:54.120 --> 00:34:57.820
and others are pretty agnostic


00:34:57.820 --> 00:34:59.700
of what you're doing with them.


00:34:59.700 --> 00:35:01.020
- Yeah.


00:35:01.020 --> 00:35:03.440
One of the things I find interesting


00:35:03.440 --> 00:35:05.220
and listening to you talk about this,


00:35:05.220 --> 00:35:09.980
it just reminded me is so often we see these problems


00:35:09.980 --> 00:35:11.400
that people are solving, right?


00:35:11.400 --> 00:35:15.720
like over here we're using CRISPR to do all this work.


00:35:15.720 --> 00:35:17.320
And then you talk about the tools you use.


00:35:17.320 --> 00:35:19.920
It's like, oh yeah, we're using like NumPy and Pandas


00:35:19.920 --> 00:35:22.200
and Jupyter and these kinds of things.


00:35:22.200 --> 00:35:25.260
And the thing that I find really interesting is


00:35:25.260 --> 00:35:28.400
for software development,


00:35:28.400 --> 00:35:30.360
there's so much of the stuff that is,


00:35:30.360 --> 00:35:33.040
it's just the same for everyone, right?


00:35:33.040 --> 00:35:34.960
They're doing the same thing.


00:35:34.960 --> 00:35:38.080
And then there's 10 or 20% that like, yeah,


00:35:38.080 --> 00:35:39.800
this field does this part different,


00:35:39.800 --> 00:35:42.440
but there's like 80% of, yeah, we kind of,


00:35:42.440 --> 00:35:44.880
we should use source control, we're using Python,


00:35:44.880 --> 00:35:47.240
we're using notebooks, we're using pandas


00:35:47.240 --> 00:35:48.760
and that kind of stuff.


00:35:48.760 --> 00:35:53.440
And it's the similarities are way more common


00:35:53.440 --> 00:35:56.880
than I think they appear from the outside.


00:35:56.880 --> 00:35:58.440
- That's, it's a great point.


00:35:58.440 --> 00:36:00.560
And I think we'd all be better off


00:36:00.560 --> 00:36:03.160
if we reminded ourselves of that more often


00:36:03.160 --> 00:36:06.860
that we're not, just because we're doing biotechnology


00:36:06.860 --> 00:36:11.700
and things with Python that were largely very similar


00:36:11.700 --> 00:36:15.700
to other software developers doing data science


00:36:15.700 --> 00:36:20.300
on business topics or finance or just standard web development.


00:36:20.300 --> 00:36:22.220
You could be in a hedge fund and you're like,


00:36:22.220 --> 00:36:24.820
this isn't that different than what I'm used to, actually.


00:36:24.820 --> 00:36:25.320
Yeah.


00:36:25.320 --> 00:36:25.820
Yeah.


00:36:25.820 --> 00:36:28.540
And if you think like that, you end up with, I think,


00:36:28.540 --> 00:36:32.260
better practices overall in the software.


00:36:32.260 --> 00:36:32.780
Yeah.


00:36:32.780 --> 00:36:33.780
Oh, I totally agree.


00:36:33.780 --> 00:36:38.780
Also, I suspect that this fact is what also makes


00:36:38.780 --> 00:36:42.860
the data science tools and all the tooling


00:36:42.860 --> 00:36:46.380
around Python libraries and whatnot so good


00:36:46.380 --> 00:36:47.340
because it's not just like,


00:36:47.340 --> 00:36:50.100
oh, the biologists have made this part of it really good.


00:36:50.100 --> 00:36:54.340
It's like most of the people are all really refining


00:36:54.340 --> 00:36:55.940
like the core parts.


00:36:55.940 --> 00:36:59.720
- Right, yeah, I think that's definitely the case.


00:36:59.720 --> 00:37:01.620
And some of the biology specific tools


00:37:01.620 --> 00:37:05.380
are a little wonky when you start using them.


00:37:05.380 --> 00:37:09.260
I think, I mean, things like pandas are really amazing.


00:37:09.260 --> 00:37:12.140
- You can tell the amount of attention


00:37:12.140 --> 00:37:13.460
or something is different.


00:37:13.460 --> 00:37:15.340
Cool.


00:37:15.340 --> 00:37:18.140
What is moving to production look like for you?


00:37:18.140 --> 00:37:20.260
So you talked about sometimes it's,


00:37:20.260 --> 00:37:22.380
you start the exploration and stuff in notebooks,


00:37:22.380 --> 00:37:24.940
which is exactly what they're built for.


00:37:24.940 --> 00:37:28.220
And then moving to maybe a little more composition


00:37:28.220 --> 00:37:29.380
of scripts and whatnot.


00:37:29.380 --> 00:37:31.340
And eventually somehow you end up with,


00:37:31.340 --> 00:37:35.860
you know, Lambda, cloud databases, things like that.


00:37:35.860 --> 00:37:36.940
What's that flow?


00:37:36.940 --> 00:37:40.740
- Yeah, so the process of, I guess we say,


00:37:40.740 --> 00:37:43.260
productionizing a pipeline is,


00:37:43.260 --> 00:37:46.100
we've had pretty well set now.


00:37:46.100 --> 00:37:50.260
And generally how it works is we say,


00:37:50.260 --> 00:37:54.700
this pipeline is about done.


00:37:54.700 --> 00:37:59.700
And we'll hand it off to myself or one of my colleagues


00:38:00.380 --> 00:38:05.300
to start the process of getting it fully cloud capable


00:38:05.300 --> 00:38:06.860
and scalable.


00:38:06.860 --> 00:38:10.620
And what that means for us is to take the software


00:38:10.620 --> 00:38:14.540
in whatever form we've gotten it from our colleagues


00:38:14.540 --> 00:38:17.420
and put it into a workflow manager.


00:38:17.420 --> 00:38:20.820
And I think every company has their own version


00:38:20.820 --> 00:38:23.640
of workflow manager that they choose.


00:38:23.640 --> 00:38:27.500
We're using Luigi, which is fully Python based.


00:38:27.500 --> 00:38:31.340
that was originally developed at Spotify


00:38:31.340 --> 00:38:34.140
to do this sort of task.


00:38:34.140 --> 00:38:39.140
It's a, it uses like a GNU make type target file,


00:38:39.140 --> 00:38:43.560
DAG creation.


00:38:43.560 --> 00:38:46.420
I don't know all the technical terms


00:38:46.420 --> 00:38:48.540
to describe how the tasks are built,


00:38:48.540 --> 00:38:52.580
but you essentially, you have a task at the end


00:38:52.580 --> 00:38:56.340
and you say it requires the output of this other task


00:38:56.340 --> 00:39:00.640
and then that task requires some more.


00:39:00.640 --> 00:39:04.900
And as they build up, you create a graph


00:39:04.900 --> 00:39:08.340
of what tasks need to be done to get to our output.


00:39:08.340 --> 00:39:10.740
- Right, a directed acyclic graph.


00:39:10.740 --> 00:39:12.800
And then the workflow can decide like,


00:39:12.800 --> 00:39:14.140
oh, these two things are independent,


00:39:14.140 --> 00:39:16.420
so let's scale them out separately.


00:39:16.420 --> 00:39:18.540
But now this one has to wait for these two to finish


00:39:18.540 --> 00:39:19.500
and then get its results.


00:39:19.500 --> 00:39:22.560
And that coordination can be really tricky.


00:39:22.560 --> 00:39:23.400
- Exactly.


00:39:23.400 --> 00:39:26.180
And so there's a number of common work managers


00:39:26.180 --> 00:39:28.580
in bioinformatics, I think the two most common


00:39:28.580 --> 00:39:31.180
are SnakeMake and NextFlow.


00:39:31.180 --> 00:39:36.860
Luigi has also been really good for us.


00:39:36.860 --> 00:39:40.060
We like it primarily because it is fully Python based


00:39:40.060 --> 00:39:42.980
and it uses standard Python syntax,


00:39:42.980 --> 00:39:46.260
which allows us to really, if we need to,


00:39:46.260 --> 00:39:49.240
get under the hood and add some customization,


00:39:49.240 --> 00:39:51.020
extend it where we need to,


00:39:51.020 --> 00:39:53.420
or fix things that we don't like about it.


00:39:53.420 --> 00:39:56.980
And I think that was a really important part of our decision


00:39:56.980 --> 00:40:00.900
in choosing Luigi over some of these other workflow managers.


00:40:00.900 --> 00:40:02.260
- Yeah, for sure.


00:40:02.260 --> 00:40:05.540
I had a nice conversation with the Apache Airflow folks


00:40:05.540 --> 00:40:06.900
not too long ago.


00:40:06.900 --> 00:40:10.220
And one of the things that really struck me about this


00:40:10.220 --> 00:40:13.900
is the ability for people to work


00:40:13.900 --> 00:40:15.740
on little parts of the processing.


00:40:15.740 --> 00:40:19.420
A little bit like that little Python automation tools


00:40:19.420 --> 00:40:22.740
or little Python projects that you described earlier


00:40:22.740 --> 00:40:27.060
in episode 327 in that instead of trying to figure out


00:40:27.060 --> 00:40:29.180
all this orchestration, you just have to figure out,


00:40:29.180 --> 00:40:31.400
well, this little task is gonna do a thing.


00:40:31.400 --> 00:40:34.740
And that, like I said, maybe it means see the file


00:40:34.740 --> 00:40:37.460
and then copy it over there.


00:40:37.460 --> 00:40:40.700
And if your job was see a file here, copy it over there,


00:40:40.700 --> 00:40:42.700
like that's a really simple job.


00:40:42.700 --> 00:40:44.140
You can totally nail that.


00:40:44.140 --> 00:40:45.300
You know what I mean?


00:40:45.300 --> 00:40:46.140
- Yeah.


00:40:46.140 --> 00:40:48.900
- Whereas if your job is to orchestrate this graph


00:40:48.900 --> 00:40:50.380
and make sure that it runs on time


00:40:50.380 --> 00:40:51.660
and here's the failure case,


00:40:51.660 --> 00:40:53.660
all of a sudden that becomes super, super hard.


00:40:53.660 --> 00:40:55.660
So these seem really empowering,


00:40:55.660 --> 00:40:58.860
almost like the promise of microservices is like,


00:40:58.860 --> 00:41:01.660
you get to focus on one little part and do that.


00:41:01.660 --> 00:41:05.360
Yeah, it definitely helps.


00:41:05.360 --> 00:41:09.860
And it helps with that idea of having these small tasks.


00:41:09.860 --> 00:41:13.860
It really helps with how you can develop it


00:41:13.860 --> 00:41:16.860
and reuse the components.


00:41:16.860 --> 00:41:20.260
For each task, like we might, as we said earlier,


00:41:20.260 --> 00:41:24.900
that there are these third party tools that end up being used in almost all of our pipelines


00:41:24.900 --> 00:41:31.480
and using something like Luigi or any workflow manager, you can reuse the tasks in different


00:41:31.480 --> 00:41:33.500
contexts as need be.


00:41:33.500 --> 00:41:38.860
And you can have your perfectly optimized way of using that task everywhere.


00:41:38.860 --> 00:41:40.780
And that reuse is really nice.


00:41:40.780 --> 00:41:43.460
And it's something I think a lot of software developers appreciate.


00:41:43.460 --> 00:41:45.340
Yeah, for sure.


00:41:45.340 --> 00:41:46.460
- So if you look at some of the folks


00:41:46.460 --> 00:41:49.980
that are using Luigi, so Spotify,


00:41:49.980 --> 00:41:52.960
like I believe you said, as you said, created it,


00:41:52.960 --> 00:41:58.820
but also Foursquare, Stripe, Asana, SeatGeek,


00:41:58.820 --> 00:42:02.140
you know, a lot of companies that people probably heard of,


00:42:02.140 --> 00:42:04.780
like, oh, these places are doing awesome stuff,


00:42:04.780 --> 00:42:05.740
let's be like them.


00:42:05.740 --> 00:42:09.860
- Yeah, and I think a lot of places use it


00:42:09.860 --> 00:42:14.340
for like Hadoop and things like that.


00:42:14.340 --> 00:42:17.020
And one of the nice things, as you mentioned about


00:42:17.020 --> 00:42:19.340
like how Airflow has the same model,


00:42:19.340 --> 00:42:23.100
where you can create these contributions,


00:42:23.100 --> 00:42:27.700
which are different connectors for Luigi or for Airflow,


00:42:27.700 --> 00:42:29.380
where you can connect them to either different


00:42:29.380 --> 00:42:33.500
cloud providers or different data stores, things like that.


00:42:33.500 --> 00:42:38.500
And that allows you to use Luigi or any workflow manager


00:42:38.500 --> 00:42:40.340
in numerous different contexts,


00:42:40.340 --> 00:42:42.500
whether it's locally on your own computer,


00:42:42.500 --> 00:42:50.400
running things in Docker containers, or whether it's deploying out to AWS and scaling massively


00:42:50.400 --> 00:42:52.760
horizontal.


00:42:52.760 --> 00:42:56.920
These workflow managers really support that, and that's why they're a necessary component


00:42:56.920 --> 00:42:59.960
in how we productionize our data pipelines.


00:42:59.960 --> 00:43:00.960
Yeah.


00:43:00.960 --> 00:43:06.720
Again, they just seem so empowering for allowing people to focus on just each step independently,


00:43:06.720 --> 00:43:08.980
which is excellent.


00:43:08.980 --> 00:43:10.400
Did you consider other ones?


00:43:10.400 --> 00:43:14.960
Did you consider Airflow or Dagster or any of these other ones?


00:43:14.960 --> 00:43:18.760
Or did you find this fit and you're like, "We're going with this"?


00:43:18.760 --> 00:43:20.800
We did look at some other ones.


00:43:20.800 --> 00:43:28.960
We were using Nextflow for a little bit, which is a bioinformatic-flavored workflow manager.


00:43:28.960 --> 00:43:33.720
It's very focused on bioinformatics as its primary use case, although you could use it


00:43:33.720 --> 00:43:37.960
for anything.


00:43:37.960 --> 00:43:41.920
is similar to Groovy and it's based in Groovy.


00:43:41.920 --> 00:43:44.720
And that was one of the detractors for us


00:43:44.720 --> 00:43:46.960
is that it was a little hard to get under the hood


00:43:46.960 --> 00:43:48.920
and use that because of it.


00:43:48.920 --> 00:43:54.080
I did briefly look at Dagster after hearing a few episodes,


00:43:54.080 --> 00:43:57.400
I think, it may have been a different podcast, but.


00:43:57.400 --> 00:44:00.800
- Yeah, I did have Tobias Macion to give us a overview


00:44:00.800 --> 00:44:02.400
of the whole data engineering landscape.


00:44:02.400 --> 00:44:04.520
So possibly, I know he spoke about it then,


00:44:04.520 --> 00:44:06.440
but I'm not sure when you heard about it.


00:44:06.440 --> 00:44:09.120
- Yeah, yeah, so I heard about it on a podcast,


00:44:09.120 --> 00:44:11.120
probably this one as well.


00:44:11.120 --> 00:44:14.360
And I did look into it, but it didn't have it at that time.


00:44:14.360 --> 00:44:16.960
It was pretty early and it didn't have any connectors


00:44:16.960 --> 00:44:21.000
to AWS in the ways that we like to use Luigi.


00:44:21.000 --> 00:44:22.080
- Connectors, right?


00:44:22.080 --> 00:44:23.360
That's such an important thing


00:44:23.360 --> 00:44:25.480
'cause otherwise you've got to learn the API


00:44:25.480 --> 00:44:28.160
of every single thing you're talking to.


00:44:28.160 --> 00:44:32.800
- Yeah, I mean, these days, knowing how Luigi works,


00:44:32.800 --> 00:44:34.560
it actually wouldn't have been that big of a task


00:44:34.560 --> 00:44:36.040
to look under the hood.


00:44:36.040 --> 00:44:46.280
But yeah, so we did choose Luigi and particularly we like how it handles deployment to AWS.


00:44:46.280 --> 00:44:57.800
And we use it on the service called AWS batch, which is, I guess it might be similar to like a Kubernetes pod,


00:44:57.800 --> 00:45:01.880
although I haven't done anything with K8s or anything like that.


00:45:01.880 --> 00:45:07.400
So I'm not speaking from experience, but it essentially scales up


00:45:07.400 --> 00:45:14.460
EC2 instances, these elastic compute instances on the cloud


00:45:14.460 --> 00:45:20.240
as you need them, and it gives out jobs to the virtual computers


00:45:20.240 --> 00:45:22.580
as necessary.


00:45:22.580 --> 00:45:27.220
So it spins them up, allocates jobs in a Docker container,


00:45:27.220 --> 00:45:31.760
they run, when there's no more jobs on the instance, it shuts off.


00:45:31.760 --> 00:45:36.040
- Okay, so you come up with like an AMI,


00:45:36.040 --> 00:45:39.160
an Amazon machine image that's preconfigured,


00:45:39.160 --> 00:45:42.320
set up ready to run, and then you say,


00:45:42.320 --> 00:45:44.480
I'm gonna give you a bunch of data,


00:45:44.480 --> 00:45:46.320
each one of these data gets passed the machine


00:45:46.320 --> 00:45:49.800
and it runs and then maybe even shuts down when it's done?


00:45:49.800 --> 00:45:54.680
- Yeah, there is an AMI, we keep the AMI pretty simple


00:45:54.680 --> 00:45:57.060
because it's sort of the base for all of them.


00:45:57.060 --> 00:46:00.200
And then the way batch works is you have


00:46:00.200 --> 00:46:02.340
your top level AMI,


00:46:02.340 --> 00:46:05.420
that's called the compute environment, I believe.


00:46:05.420 --> 00:46:09.820
And then inside of it, you run the actual job


00:46:09.820 --> 00:46:13.140
and the job runs inside of a Docker container.


00:46:13.140 --> 00:46:14.380
So-- - Oh, I see.


00:46:14.380 --> 00:46:16.340
So the Docker container is pre-configured


00:46:16.340 --> 00:46:18.540
with like all the Python dependencies


00:46:18.540 --> 00:46:20.780
and the settings that it needs and whatnot.


00:46:20.780 --> 00:46:24.940
- Right, so we have each task in Luigi,


00:46:24.940 --> 00:46:29.660
each little piece of work has its own Docker container.


00:46:29.660 --> 00:46:33.540
And then we push those out into the cloud


00:46:33.540 --> 00:46:36.820
and they get allocated out onto these machines.


00:46:36.820 --> 00:46:41.140
They run their task, data comes in from S3,


00:46:41.140 --> 00:46:45.220
goes back out to S3, nothing is left on the hard drives,


00:46:45.220 --> 00:46:46.620
and then they disappear.


00:46:46.620 --> 00:46:50.340
And they're these little ephemeral compute instances.


00:46:50.340 --> 00:46:54.100
And that's all managed by a workflow manager


00:46:54.100 --> 00:46:57.700
such as Luigi or Airflow or Nextflow.


00:46:57.700 --> 00:46:59.780
- Wow, that's pretty awesome.


00:46:59.780 --> 00:47:04.320
One of the things that I remember reading and thinking,


00:47:04.320 --> 00:47:08.420
wow, that's a pretty crazy use of the cloud


00:47:08.420 --> 00:47:12.060
was this Ars Technica article from,


00:47:12.060 --> 00:47:14.500
look at that year, 2011.


00:47:14.500 --> 00:47:15.340
- Oh, wow.


00:47:15.340 --> 00:47:17.420
- So if you think back to 2011,


00:47:17.420 --> 00:47:20.100
like the cloud was really new


00:47:20.100 --> 00:47:22.820
and the idea of spending a ton of money on it


00:47:22.820 --> 00:47:24.380
and getting a bunch of compute out of it


00:47:24.380 --> 00:47:27.280
was still somewhat foreign to people.


00:47:27.280 --> 00:47:29.080
So there's this article I'll link to called


00:47:29.080 --> 00:47:34.080
the $1,279 per hour,


00:47:34.080 --> 00:47:39.300
30,000 core cluster built on Amazon EC2 cloud,


00:47:39.300 --> 00:47:42.840
which is this company, this pharmaceutical company


00:47:42.840 --> 00:47:45.940
that needed to do a lot of computing.


00:47:45.940 --> 00:47:50.700
And they said, instead of buying a supercomputer basically,


00:47:50.700 --> 00:47:53.100
we're gonna come up and just fire off


00:47:53.100 --> 00:47:54.300
an insane amount of cores.


00:47:54.300 --> 00:47:57.740
And I think if I remember reading this correctly,


00:47:57.740 --> 00:48:01.380
that they weren't allowed to make that many cores


00:48:01.380 --> 00:48:03.020
in a single data center.


00:48:03.020 --> 00:48:06.260
So they had to do this across--


00:48:06.260 --> 00:48:09.220
also had to coordinate in multi-data center type


00:48:09.220 --> 00:48:12.220
of processing as well, because it's


00:48:12.220 --> 00:48:15.220
just the scale of everything.


00:48:15.220 --> 00:48:18.980
This seems like the type of work that you all might be doing.


00:48:18.980 --> 00:48:22.260
>>Yeah, it does look very familiar.


00:48:22.260 --> 00:48:23.260
We do--


00:48:23.260 --> 00:48:24.260
[INTERPOSING VOICES]


00:48:24.260 --> 00:48:25.940
Can you tell us anything about this?


00:48:25.940 --> 00:48:29.500
Yeah, we do occasionally have a certain type


00:48:29.500 --> 00:48:36.420
of molecular modeling job that we can scale very wide.


00:48:36.420 --> 00:48:41.380
And I think this sort of 30,000 number looks pretty familiar.


00:48:41.380 --> 00:48:47.700
I think our largest jobs today have been about 10,000 CPUs


00:48:47.700 --> 00:48:51.460
wide and running for a few days, so maybe


00:48:51.460 --> 00:48:55.500
like four or five days. I think the number was like four or five


00:48:55.500 --> 00:49:01.620
days on the 10,000 cores. Yeah, yeah, it's a it's, it's a lot.


00:49:01.620 --> 00:49:08.380
And I saw I think it was like over a million CPU hours on AWS


00:49:08.380 --> 00:49:13.780
batch. And that was just something that we could really


00:49:13.780 --> 00:49:17.740
heavily parallelize and we needed the data fast and yeah,


00:49:19.220 --> 00:49:20.860
- It worked.


00:49:20.860 --> 00:49:23.460
You pull it all back and aggregate it all together


00:49:23.460 --> 00:49:26.980
at the end and it was a really useful dataset.


00:49:26.980 --> 00:49:30.500
And it's pretty amazing what you can do


00:49:30.500 --> 00:49:34.180
on some of these cloud providers by going really wide.


00:49:34.180 --> 00:49:36.340
- Yeah, it's crazy.


00:49:36.340 --> 00:49:37.780
You know, I mean, there's some places


00:49:37.780 --> 00:49:41.620
where it makes sense to like build true supercomputers


00:49:41.620 --> 00:49:45.660
like Oak Ridge has this thing called Summit,


00:49:45.660 --> 00:49:49.620
which is like this insane supercomputer that they have.


00:49:49.620 --> 00:49:50.860
But a lot of times,


00:49:50.860 --> 00:49:56.380
there's the latency of getting something like this set up.


00:49:56.380 --> 00:49:58.820
There's the overhead of, guess what?


00:49:58.820 --> 00:50:01.220
Now you're an admin for like an insane,


00:50:01.220 --> 00:50:04.620
there's only three in the world supercomputer type system.


00:50:04.620 --> 00:50:06.900
Right, it's gotta be empowering to be able to just go,


00:50:06.900 --> 00:50:10.380
hit go, and then let all this happen


00:50:10.380 --> 00:50:12.900
and not worry about all those details, right?


00:50:13.860 --> 00:50:16.460
- Yeah, and there's definitely still some stress involved


00:50:16.460 --> 00:50:18.140
in starting one of these jobs.


00:50:18.140 --> 00:50:21.380
If you just, you know, it's not cheap.


00:50:21.380 --> 00:50:22.740
Anyway, you slice it.


00:50:22.740 --> 00:50:24.980
We do try to, you know, do everything we can


00:50:24.980 --> 00:50:28.560
to make it as efficient in cost as possible, but.


00:50:28.560 --> 00:50:32.780
- There's two aspects to it that really jump out to me.


00:50:32.780 --> 00:50:36.620
One is the, oh, was that the wrong version of the code?


00:50:36.620 --> 00:50:37.660
The one that still had the bug?


00:50:37.660 --> 00:50:39.180
We got to throw away all the data?


00:50:39.180 --> 00:50:42.500
Whoops, we just ran for five days and, you know,


00:50:42.500 --> 00:50:44.740
thousands of dollars got burned up


00:50:44.740 --> 00:50:46.860
and there's a bit of a problem there.


00:50:46.860 --> 00:50:49.620
So whoops, and now it's five days later


00:50:49.620 --> 00:50:51.620
till you get the answer as well, right?


00:50:51.620 --> 00:50:55.900
That's one.


00:50:55.900 --> 00:50:58.020
And then I'm losing track of my thought on my other one,


00:50:58.020 --> 00:51:01.380
but yeah, anyway, it's just gotta be stressful


00:51:01.380 --> 00:51:05.900
to be like to set that up and then press go, right?


00:51:05.900 --> 00:51:07.340
- Yeah, it definitely is.


00:51:07.340 --> 00:51:10.420
I think one of the benefits is a lot of our computational


00:51:10.420 --> 00:51:16.740
team does have a experimental background and doing experiments in the lab, these sort of


00:51:16.740 --> 00:51:22.180
numbers like tens of thousands of dollars for an experiment are not really that uncommon.


00:51:22.180 --> 00:51:26.260
And for those kind of things, you get really careful and you check all the boxes and double


00:51:26.260 --> 00:51:27.260
check everything.


00:51:27.260 --> 00:51:30.100
And so I think a lot of us have had that experience.


00:51:30.100 --> 00:51:35.500
And so even when we're dealing with software, we'll be very careful and we'll do the tests


00:51:35.500 --> 00:51:38.460
and quality control before we really let her rip.


00:51:38.460 --> 00:51:45.580
Yeah, I worked on some projects when I was in grad school that were on a silicon graphics,


00:51:45.580 --> 00:51:48.580
big mainframe type thing.


00:51:48.580 --> 00:51:55.260
And obviously much lower importance than solving diseases and stuff is just solving math problems.


00:51:55.260 --> 00:52:00.180
But I remember coming in to work on the project one day and none of our workstations could


00:52:00.180 --> 00:52:06.060
log in to the Silicon Graphics machine and what is wrong with this thing?


00:52:06.060 --> 00:52:07.060
And it was so loud.


00:52:07.060 --> 00:52:08.060
It was in the other room.


00:52:08.060 --> 00:52:12.180
hear that roaring away in there, it clearly was loud.


00:52:12.180 --> 00:52:14.180
And what happened was it wasn't me,


00:52:14.180 --> 00:52:19.180
it was someone else in the group had written some code


00:52:19.180 --> 00:52:21.240
and these things would run all night,


00:52:21.240 --> 00:52:23.260
we'd come in in the morning and check them.


00:52:23.260 --> 00:52:26.820
And what had happened was they had a bug in their code,


00:52:26.820 --> 00:52:28.820
which they knew they were trying to diagnose it.


00:52:28.820 --> 00:52:31.040
So they were printing out a bunch of log stuff


00:52:31.040 --> 00:52:32.300
or something like that.


00:52:32.300 --> 00:52:36.540
Well, they did that in a tight loop on a high end computer


00:52:36.540 --> 00:52:39.180
for a night and it filled up the hard drive


00:52:39.180 --> 00:52:40.340
till it had zero bytes left.


00:52:40.340 --> 00:52:42.460
And apparently the Silicon graphics machine


00:52:42.460 --> 00:52:45.860
couldn't operate anymore was literally zero bytes.


00:52:45.860 --> 00:52:47.620
And so it just stopped working.


00:52:47.620 --> 00:52:48.620
They couldn't get it to turn on.


00:52:48.620 --> 00:52:51.180
It was like, it took days to get it back, I believe.


00:52:51.180 --> 00:52:53.060
- Oh, oops.


00:52:53.060 --> 00:52:54.580
- But it's like that kind of stuff, right?


00:52:54.580 --> 00:52:56.660
I mean, this, you're not gonna break EC2,


00:52:56.660 --> 00:53:00.620
but you don't know until the next day that,


00:53:00.620 --> 00:53:01.940
oh, look, you filled up the computer


00:53:01.940 --> 00:53:03.300
and it doesn't work anymore, right?


00:53:03.300 --> 00:53:05.900
When you're doing that much computing,


00:53:05.900 --> 00:53:08.640
you could run out of different resources,


00:53:08.640 --> 00:53:10.760
you could run into all kinds of problems.


00:53:10.760 --> 00:53:11.840
- Absolutely.


00:53:11.840 --> 00:53:16.680
And we are without our war stories of doing this,


00:53:16.680 --> 00:53:19.620
but I think we've definitely learned a lot of lessons


00:53:19.620 --> 00:53:24.240
along the way of how to monitor your jobs effectively


00:53:24.240 --> 00:53:25.920
and double check things.


00:53:25.920 --> 00:53:30.000
But sometimes, yeah, you run a big job


00:53:30.000 --> 00:53:31.440
and it doesn't quite turn out right,


00:53:31.440 --> 00:53:34.280
but it's the cost of doing business, I guess.


00:53:34.280 --> 00:53:37.620
- Yeah, I mean, it's very computational to explore stuff


00:53:37.620 --> 00:53:39.560
like this kind of stuff,


00:53:39.560 --> 00:53:41.440
but that's also what enables it, right?


00:53:41.440 --> 00:53:44.360
Without this computing power, it would just not be a thing.


00:53:44.360 --> 00:53:47.480
- Absolutely, like a lot of the data


00:53:47.480 --> 00:53:49.280
just takes a lot of time to process


00:53:49.280 --> 00:53:51.120
and there's just not really any way around it.


00:53:51.120 --> 00:53:52.360
And even when you're iterating,


00:53:52.360 --> 00:53:55.080
you have to go through all the hoops


00:53:55.080 --> 00:53:57.400
to look at the data at the end.


00:53:57.400 --> 00:54:00.840
- Yeah, so you talked about APIs,


00:54:00.840 --> 00:54:02.800
you talked about Datastore,


00:54:02.800 --> 00:54:04.800
What are you using for a database?


00:54:04.800 --> 00:54:08.440
Is this like a hosted RDS AWS thing


00:54:08.440 --> 00:54:11.000
or what is the story with that?


00:54:11.000 --> 00:54:14.600
- Yeah, so we have a few different places to store data.


00:54:14.600 --> 00:54:18.380
Our larger scale internal data,


00:54:18.380 --> 00:54:23.080
we store in Django based web app


00:54:23.080 --> 00:54:28.080
and we use the Django ORM for SQL based database,


00:54:28.080 --> 00:54:31.760
a MySQL database on AWS.


00:54:31.760 --> 00:54:35.920
and that has worked surprisingly effectively actually.


00:54:35.920 --> 00:54:39.440
I've heard some people say that the Django ORM


00:54:39.440 --> 00:54:42.540
is really slow and you scale out and things,


00:54:42.540 --> 00:54:46.400
but if you design it correctly,


00:54:46.400 --> 00:54:48.360
I think it'll surprise you.


00:54:48.360 --> 00:54:50.080
- I think that's so true.


00:54:50.080 --> 00:54:52.360
I hear so many things about,


00:54:52.360 --> 00:54:56.040
oh, ORMs are slow or this thing is slow in this way.


00:54:56.040 --> 00:55:00.280
And wow, if you have the queries structured well,


00:55:00.280 --> 00:55:01.960
If you do the joins ahead of time,


00:55:01.960 --> 00:55:04.540
if you have indexes and you've put the work


00:55:04.540 --> 00:55:07.940
into finding all these things, it's mind blowing.


00:55:07.940 --> 00:55:11.160
When I go to sites, I won't call any out,


00:55:11.160 --> 00:55:12.720
I don't know if they've been updated or whatever,


00:55:12.720 --> 00:55:13.940
but you go to a site and you're like,


00:55:13.940 --> 00:55:16.260
this site is taking four or five seconds to load.


00:55:16.260 --> 00:55:18.040
What could it possibly be doing?


00:55:18.040 --> 00:55:20.240
I mean, I know it has some data,


00:55:20.240 --> 00:55:24.560
but it doesn't have unimaginable amounts of data, right?


00:55:24.560 --> 00:55:27.880
Surely somebody could just put an index in here


00:55:27.880 --> 00:55:29.760
or worst case a cache in something


00:55:29.760 --> 00:55:32.560
and it would just transform it, right?


00:55:32.560 --> 00:55:35.800
So yeah, I'm glad to hear you're having good experiences.


00:55:35.800 --> 00:55:39.000
- Yeah, it's been, we definitely fairly regularly


00:55:39.000 --> 00:55:41.800
run into slow queries.


00:55:41.800 --> 00:55:44.120
They're usually not too bad to solve.


00:55:44.120 --> 00:55:48.180
I'm sure at some point we'll get to something really wonky


00:55:48.180 --> 00:55:51.480
that will be challenging, but I think for the most part,


00:55:51.480 --> 00:55:55.960
yeah, we've been able to solve it through better query design


00:55:55.960 --> 00:55:58.360
and better indexing.


00:55:58.360 --> 00:56:01.600
- Yeah, do you ever do things where you opt out


00:56:01.600 --> 00:56:05.160
of the sort of class-based query syntax


00:56:05.160 --> 00:56:08.280
and go straight to SQL queries, you know,


00:56:08.280 --> 00:56:11.720
here and there to make sure that that part works better?


00:56:11.720 --> 00:56:16.720
- We have tried it for some particular


00:56:16.720 --> 00:56:20.420
sequence-based searches that we do.


00:56:20.420 --> 00:56:25.000
And I actually found that most of the time,


00:56:25.000 --> 00:56:26.440
like you can write it in the ORM,


00:56:26.440 --> 00:56:29.120
it's just a little more complicated.


00:56:29.120 --> 00:56:30.680
But I do expect that at some point


00:56:30.680 --> 00:56:33.520
we will be writing raw SQL queries


00:56:33.520 --> 00:56:36.200
because out of necessity.


00:56:36.200 --> 00:56:37.760
- Yeah, but it's not the majority.


00:56:37.760 --> 00:56:41.200
Mainly you're using the ORM and then it's okay.


00:56:41.200 --> 00:56:42.780
- Yeah, and I think a lot of benefits


00:56:42.780 --> 00:56:45.200
from the appropriate data model


00:56:45.200 --> 00:56:48.240
will help the queries along the way.


00:56:48.240 --> 00:56:49.640
- Yeah, absolutely.


00:56:49.640 --> 00:56:52.920
The thing I found the slowest about ORMs and ODM


00:56:52.920 --> 00:56:55.720
if you're doing document databases


00:56:55.720 --> 00:56:58.720
is the deserialization actually, right?


00:56:58.720 --> 00:57:01.000
It's not the query time, but it's like,


00:57:01.000 --> 00:57:03.840
I gotta generate a hundred thousand Python objects


00:57:03.840 --> 00:57:06.360
and that just happens to be not that fast.


00:57:06.360 --> 00:57:10.600
- You're talking about my Monday morning, Michael.


00:57:10.600 --> 00:57:12.800
(laughing)


00:57:12.800 --> 00:57:15.100
- And in those cases, I think that that's the place


00:57:15.100 --> 00:57:18.440
where it makes sense to maybe do some kind of


00:57:18.440 --> 00:57:20.680
like a projection or something.


00:57:20.680 --> 00:57:22.360
I don't know how to do it in Django or M,


00:57:22.360 --> 00:57:25.300
but in say Mongo engine, you can say,


00:57:25.300 --> 00:57:29.600
I know what I'm going to get back is an iterable set


00:57:29.600 --> 00:57:31.700
of these objects that match to the data,


00:57:31.700 --> 00:57:35.300
but only actually add-- just fill out these two fields.


00:57:35.300 --> 00:57:36.820
Most of the data, just throw it away.


00:57:36.820 --> 00:57:38.420
Don't try to parse it and convert it.


00:57:38.420 --> 00:57:41.140
Just like, I just want these two fields.


00:57:41.140 --> 00:57:44.060
And that usually makes it dramatically faster.


00:57:44.060 --> 00:57:47.260
>>Yeah, we've run into a number of bottlenecks


00:57:47.260 --> 00:57:49.700
at the serialization layer.


00:57:49.700 --> 00:57:53.460
And we have been experimenting with a variety


00:57:53.460 --> 00:57:56.340
of different ways to solve those issues.


00:57:56.340 --> 00:58:00.700
And yeah, sometimes it means putting fewer Python objects


00:58:00.700 --> 00:58:03.820
between you and the data and that often speeds it up,


00:58:03.820 --> 00:58:06.700
even if it makes it a little bit harder to interpret


00:58:06.700 --> 00:58:09.420
in your development environment.


00:58:09.420 --> 00:58:10.380
- Yeah, absolutely.


00:58:10.380 --> 00:58:11.420
Or just say, you know what?


00:58:11.420 --> 00:58:12.740
I just need dictionaries this time.


00:58:12.740 --> 00:58:14.620
Like I know it's gonna be less fun,


00:58:14.620 --> 00:58:16.860
but that's what it takes.


00:58:16.860 --> 00:58:18.760
- That was the fix on Monday morning.


00:58:18.760 --> 00:58:22.520
We do try to extensively use data classes


00:58:22.520 --> 00:58:25.700
for a lot of our interoperability.


00:58:25.700 --> 00:58:29.880
When data comes in and out of a pipeline,


00:58:29.880 --> 00:58:31.880
we like to have it in a data class


00:58:31.880 --> 00:58:35.080
and a centrally stored repository.


00:58:35.080 --> 00:58:38.240
And then our Django web app also has access to that.


00:58:38.240 --> 00:58:41.720
So it knows what the structure of the data coming in is,


00:58:41.720 --> 00:58:45.200
and it knows what to serialize it to when it's coming out.


00:58:45.200 --> 00:58:47.320
And those, the Python data classes


00:58:47.320 --> 00:58:50.440
has been a really useful tool for that.


00:58:50.440 --> 00:58:54.040
but it's, I think we were talking about that


00:58:54.040 --> 00:58:56.160
on another podcast a few weeks ago,


00:58:56.160 --> 00:58:57.360
maybe it was the Python Bytes one,


00:58:57.360 --> 00:59:00.480
that the data classes can be slow


00:59:00.480 --> 00:59:03.760
and sometimes it's better to just have a dictionary,


00:59:03.760 --> 00:59:07.880
even if it is a very highly structured dictionary.


00:59:07.880 --> 00:59:09.960
- Yeah, I think the problem is maintainability


00:59:09.960 --> 00:59:12.920
and whatnot, but if it's five times slower,


00:59:12.920 --> 00:59:14.560
you know what, this time it matters.


00:59:14.560 --> 00:59:16.600
So we're gonna just bite the bullet


00:59:16.600 --> 00:59:18.320
and have to deal with it.


00:59:18.320 --> 00:59:22.100
So we had time for just a little bit more digging into it.


00:59:22.100 --> 00:59:25.380
So you talked about the Django RM, Django REST framework,


00:59:25.380 --> 00:59:27.140
which is all great.


00:59:27.140 --> 00:59:30.700
What's the server deployment story?


00:59:30.700 --> 00:59:31.940
Like, how do you run that thing?


00:59:31.940 --> 00:59:33.780
Is it with a G unicorn?


00:59:33.780 --> 00:59:35.260
Is it micro-Whiskey?


00:59:35.260 --> 00:59:38.860
You know, what's your setup on that side of things?


00:59:38.860 --> 00:59:42.420
- Ours is a little custom.


00:59:42.420 --> 00:59:44.700
I guess in some ways it's pretty standard.


00:59:44.700 --> 00:59:49.700
I think we're blanking on exactly how it's set up now,


00:59:49.700 --> 00:59:53.940
but there's an Nginx proxy.


00:59:53.940 --> 01:00:00.460
I am blanking on, it might be g-unicorn.


01:00:00.460 --> 01:00:04.620
Yeah, but the--


01:00:04.620 --> 01:00:06.900
- I feel like g-unicorn and Django go together frequently.


01:00:06.900 --> 01:00:09.900
I'm not sure why they got paired up specifically,


01:00:09.900 --> 01:00:12.060
but yeah, it's a good one.


01:00:12.060 --> 01:00:17.060
And we end up deploying it out to AWS Elastic Beanstalk,


01:00:17.060 --> 01:00:22.620
which is a source of some conversation in our team


01:00:22.620 --> 01:00:25.420
because there's some things we really like about it


01:00:25.420 --> 01:00:28.060
and there's some things that are really annoying


01:00:28.060 --> 01:00:30.860
in terms of the deployment is much more complicated


01:00:30.860 --> 01:00:32.300
than we would like it to be.


01:00:32.300 --> 01:00:34.800
But we have everything wrapped up


01:00:34.800 --> 01:00:39.800
in a pretty gnarly CDK stack


01:00:39.800 --> 01:00:41.940
that does a lot of this work.


01:00:41.940 --> 01:00:44.860
It was messy, but you've solved it with a CDK.


01:00:44.860 --> 01:00:47.580
Now it's just you push the button and it's okay.


01:00:47.580 --> 01:00:48.980
- It's exactly like that.


01:00:48.980 --> 01:00:52.900
We have a very automated deployment process.


01:00:52.900 --> 01:00:55.840
I wouldn't like to refactor it,


01:00:55.840 --> 01:00:58.980
but it's there and it works.


01:00:58.980 --> 01:01:01.220
So that works for us, but I think, yeah,


01:01:01.220 --> 01:01:04.820
it's a pretty standard Django deployment on the cloud


01:01:04.820 --> 01:01:08.220
and it works well.


01:01:08.220 --> 01:01:09.160
- Yeah, cool.


01:01:10.380 --> 01:01:12.060
- All right, well, I think that's probably about it


01:01:12.060 --> 01:01:14.940
for time to talk about the specifics


01:01:14.940 --> 01:01:15.760
of what you all are doing,


01:01:15.760 --> 01:01:20.140
but there's the last two questions as always.


01:01:20.140 --> 01:01:21.580
So let's start with the editor.


01:01:21.580 --> 01:01:23.220
If you're gonna write some Python code,


01:01:23.220 --> 01:01:25.180
what editor do you use?


01:01:25.180 --> 01:01:26.460
- VS Code.


01:01:26.460 --> 01:01:29.380
A lot of the remote development environment on that.


01:01:29.380 --> 01:01:33.800
- Oh yeah, you use the remote aspect of it?


01:01:33.800 --> 01:01:37.060
- Yeah, we're doing a lot of work on EC2 instances


01:01:37.060 --> 01:01:38.860
as our day-to-day work.


01:01:39.900 --> 01:01:44.700
And VS Code, the way it works with instances in the cloud


01:01:44.700 --> 01:01:46.340
is really amazing.


01:01:46.340 --> 01:01:49.600
So I would encourage anyone to check out that extension.


01:01:49.600 --> 01:01:54.860
- Yeah, you get access to like the file system


01:01:54.860 --> 01:01:56.860
on the remote machine and basically


01:01:56.860 --> 01:01:59.700
it's just your view into that server,


01:01:59.700 --> 01:02:01.740
but it's more or less standard VS Code, right?


01:02:01.740 --> 01:02:03.900
But when you hit run, it just runs up there.


01:02:03.900 --> 01:02:06.240
- It feels exactly like you're on your own computer.


01:02:06.240 --> 01:02:07.980
Sometimes I actually get confused


01:02:07.980 --> 01:02:09.540
whether I'm on a remote or not.


01:02:09.540 --> 01:02:12.700
- It doesn't work 'cause I'm in Virginia, I see.


01:02:12.700 --> 01:02:13.540
- Yeah. - All right.


01:02:13.540 --> 01:02:14.900
And then notable PyPI package?


01:02:14.900 --> 01:02:17.620
- I'll have to shout out some of the ones


01:02:17.620 --> 01:02:18.460
we talked about.


01:02:18.460 --> 01:02:21.940
I would encourage people to look at AWS CDK


01:02:21.940 --> 01:02:23.580
if they're on AWS.


01:02:23.580 --> 01:02:27.100
I think it has some really interesting things there.


01:02:27.100 --> 01:02:30.860
And then also Luigi as a workflow manager,


01:02:30.860 --> 01:02:33.980
if people are doing any of these types of data pipelines


01:02:33.980 --> 01:02:36.620
that have tasks that get reused,


01:02:36.620 --> 01:02:38.180
these sort of work will manage, they're really cool.


01:02:38.180 --> 01:02:40.360
and Luigi is a pretty accessible one


01:02:40.360 --> 01:02:42.660
for anyone that's familiar with Python.


01:02:42.660 --> 01:02:45.440
- Yeah, all right, fantastic, yeah.


01:02:45.440 --> 01:02:48.540
I'm just learning to embrace these workflow managers,


01:02:48.540 --> 01:02:50.140
but they do seem really amazing.


01:02:50.140 --> 01:02:53.240
All right, so for all the biologists


01:02:53.240 --> 01:02:55.000
and scientists out there listening,


01:02:55.000 --> 01:02:57.680
thinking you've got this really cool setup


01:02:57.680 --> 01:03:00.640
and all this cool computational infrastructure,


01:03:00.640 --> 01:03:01.480
you know, what do you tell them?


01:03:01.480 --> 01:03:02.880
How do they get started?


01:03:02.880 --> 01:03:05.680
Maybe biology or wherever.


01:03:06.640 --> 01:03:09.320
- Yeah, I think biology is a good place to start,


01:03:09.320 --> 01:03:11.120
but we're also happy to have people


01:03:11.120 --> 01:03:12.480
come from a software background


01:03:12.480 --> 01:03:15.000
that are really interested in learning the biology.


01:03:15.000 --> 01:03:17.920
And I guess as a final plug,


01:03:17.920 --> 01:03:19.640
we do have a few open positions,


01:03:19.640 --> 01:03:22.920
so if you're interested, check out our careers page


01:03:22.920 --> 01:03:25.600
and give us an application.


01:03:25.600 --> 01:03:28.560
- Are you guys a remote place?


01:03:28.560 --> 01:03:31.360
Remote friendly, or what's the story these days?


01:03:31.360 --> 01:03:32.560
- Yep, we're remote friendly.


01:03:32.560 --> 01:03:34.640
I'm actually living in Philadelphia


01:03:34.640 --> 01:03:36.240
and our company is based in Cambridge.


01:03:36.240 --> 01:03:37.080
So yeah.


01:03:37.080 --> 01:03:38.400
- Oh, interesting.


01:03:38.400 --> 01:03:41.100
I mean, it's a short trip to the cloud,


01:03:41.100 --> 01:03:42.560
no matter where you come from, basically.


01:03:42.560 --> 01:03:44.120
- Absolutely.


01:03:44.120 --> 01:03:44.960
- Right on.


01:03:44.960 --> 01:03:46.360
Oh, David, thank you for being here


01:03:46.360 --> 01:03:49.520
and giving us this look inside all the gene editing


01:03:49.520 --> 01:03:51.680
Python stuff you're doing.


01:03:51.680 --> 01:03:52.520
- Thank you, Michael.


01:03:52.520 --> 01:03:53.340
It was a pleasure.


01:03:53.340 --> 01:03:54.180
- Yeah, you bet.


01:03:54.180 --> 01:03:55.000
Bye.


01:03:55.000 --> 01:03:55.840
- Bye.


01:03:55.840 --> 01:04:05.840
[BLANK_AUDIO]

