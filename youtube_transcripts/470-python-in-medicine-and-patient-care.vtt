WEBVTT

00:00:00.001 --> 00:00:03.760
So, Mac, welcome to Talk Python To Me.

00:00:03.760 --> 00:00:04.760
Awesome to have you here.

00:00:04.760 --> 00:00:07.760
Hey, thank you, Michael, for the introduction.

00:00:07.760 --> 00:00:10.360
I'm happy to be here.

00:00:10.360 --> 00:00:11.360
Excited.

00:00:11.360 --> 00:00:17.200
Yeah, I'm pretty excited to be talking about medicine and all the stuff that you guys are

00:00:17.200 --> 00:00:19.960
doing with Python.

00:00:19.960 --> 00:00:24.560
I really like these kinds of shows because I think it's important to highlight that Python

00:00:24.560 --> 00:00:29.280
is not just for web developers and pure data science machine learning people, but it's

00:00:29.280 --> 00:00:33.440
used by this huge spectrum of people doing all sorts of interesting stuff and solving

00:00:33.440 --> 00:00:34.440
real problems with it.

00:00:34.440 --> 00:00:37.240
It sounds like you fall pretty solidly in that category.

00:00:37.240 --> 00:00:38.240
Yeah, absolutely.

00:00:38.240 --> 00:00:46.880
It was like Python has been sort of this discovery as I've gone through my career as a physician.

00:00:46.880 --> 00:00:52.680
And it's interesting how to begin with, when computer science, initially when I was training

00:00:52.680 --> 00:00:59.040
and growing up, it was hard to imagine medicine and computer science being hand in hand together.

00:00:59.040 --> 00:01:03.840
But now I think things have progressed and there's a lot of technology that's now in

00:01:03.840 --> 00:01:07.560
there in medicine that allows you to do all these fascinating things.

00:01:07.560 --> 00:01:15.840
And of course, as I've discovered Python, it brings in kind of the toolkit and the ability

00:01:15.840 --> 00:01:22.200
to be able to achieve and solve problems in a way that I think it's not been envisioned

00:01:22.200 --> 00:01:23.200
before.

00:01:23.200 --> 00:01:24.200
So it's a very exciting time.

00:01:24.200 --> 00:01:26.320
Yeah, it is a very exciting time.

00:01:26.320 --> 00:01:28.240
And I think it's just getting better and better.

00:01:28.240 --> 00:01:31.720
Before we get too far into this, tell people a quick bit about yourself.

00:01:31.720 --> 00:01:32.720
Quick introduction.

00:01:32.720 --> 00:01:33.720
Yeah, absolutely.

00:01:33.720 --> 00:01:35.400
So I'm Somath Roy.

00:01:35.400 --> 00:01:39.440
I am a molecular pathologist.

00:01:39.440 --> 00:01:48.800
It's a type of physician who deals with looking at the genome of either a patient or a patient's

00:01:48.800 --> 00:01:49.800
tissue.

00:01:49.800 --> 00:01:58.440
And we essentially look at all of these things in a way to be able to help manage a patient's

00:01:58.440 --> 00:01:59.440
treatment.

00:01:59.440 --> 00:02:06.320
In my current position, I am an associate professor and the director of molecular pathology

00:02:06.320 --> 00:02:09.840
at Cincinnati Children's Hospital.

00:02:09.840 --> 00:02:14.680
My lab is a clinical lab that is under the division of pathology.

00:02:14.680 --> 00:02:23.560
And we do a lot of work that pertains to kids in terms of helping them diagnose and manage

00:02:23.560 --> 00:02:30.520
pediatric cancer, as well as infectious disease that happen in this age group.

00:02:30.520 --> 00:02:40.240
Molecular pathology, I essentially trained back in India as a physician with my MD.

00:02:40.240 --> 00:02:42.240
Then I came here, started in Pittsburgh.

00:02:42.240 --> 00:02:46.760
I did my training in pathology and lab medicine.

00:02:46.760 --> 00:02:49.000
I specialized in molecular pathology.

00:02:49.000 --> 00:02:51.080
Then I was there in Pittsburgh.

00:02:51.080 --> 00:02:55.360
I worked for some time and then opened Cincinnati Children's.

00:02:55.360 --> 00:02:56.360
Excellent.

00:02:56.360 --> 00:03:01.840
Do you work directly with patients or do you get samples sent to you from other doctors

00:03:01.840 --> 00:03:04.760
and then you process them and analyze them?

00:03:04.760 --> 00:03:06.400
Yeah, that's a good question.

00:03:06.400 --> 00:03:10.000
So I do not work with patients directly.

00:03:10.000 --> 00:03:16.800
It's a subspecialty in medicine where my lab works with the samples that have been collected

00:03:16.800 --> 00:03:23.200
in the patient either from the OR or a procedure or from the radiology suite.

00:03:23.200 --> 00:03:27.520
And then we work on that tissue or the blood sample or bone marrow sample that comes to

00:03:27.520 --> 00:03:28.520
us.

00:03:28.520 --> 00:03:34.560
And yes, then all the testing that we perform is off from that specimen.

00:03:34.560 --> 00:03:40.360
And then once we generate the clinical reports back, they go back to the patient's chart

00:03:40.360 --> 00:03:45.320
and to the patients, to the clinicians who are treating and managing them.

00:03:45.320 --> 00:03:52.240
And then that way it helps how they're able to then get a diagnosis and then give the

00:03:52.240 --> 00:03:55.480
appropriate treatment and the management to the patient.

00:03:55.480 --> 00:03:56.680
Yeah, excellent.

00:03:56.680 --> 00:04:01.640
So yeah, you must see a lot of different stuff flying through the lab you have to analyze.

00:04:01.640 --> 00:04:10.400
So how did you go from, I'm studying medicine to I'm writing Python code and running automation?

00:04:10.400 --> 00:04:13.760
And what was that process like?

00:04:13.760 --> 00:04:17.840
Well, that was an interesting journey for me.

00:04:17.840 --> 00:04:25.560
So before medicine and biology came into my life, I started off, it was second grade,

00:04:25.560 --> 00:04:34.400
I believe, when my dad, he got me a computer at that time, which is a 64 kilobyte small

00:04:34.400 --> 00:04:35.400
machine.

00:04:35.400 --> 00:04:43.320
So I think it was Toshiba MSX computers where you could write like GW basic code and some

00:04:43.320 --> 00:04:49.440
basic predefined hex code and you can run small applications on that.

00:04:49.440 --> 00:04:50.440
That was my starting point.

00:04:50.440 --> 00:04:52.720
It was super exciting for me.

00:04:52.720 --> 00:05:00.120
And I think from there on, the journey went into, as I went through high school and then

00:05:00.120 --> 00:05:08.040
college, medicine was, I would say, biology was something that intrigued me.

00:05:08.040 --> 00:05:15.920
And at the same time, I also got interested in genetics, looking at DNA sequences.

00:05:15.920 --> 00:05:27.440
And I had a natural liking for the fact that I could study about the cell, about the genome,

00:05:27.440 --> 00:05:28.800
the DNA and RNA.

00:05:28.800 --> 00:05:34.080
But also I realized that there was a lot of math and computation that you can use to slice

00:05:34.080 --> 00:05:35.080
and dice data.

00:05:35.080 --> 00:05:39.560
And at that time, the place that I grew in India was a very small place.

00:05:39.560 --> 00:05:43.920
So we didn't have access to resources like internet.

00:05:43.920 --> 00:05:48.280
So my exposure to internet was when I actually went to med school for the first time.

00:05:48.280 --> 00:05:51.480
Oh yeah, you can actually connect to other computers.

00:05:51.480 --> 00:05:54.280
So that's when I started my medicine.

00:05:54.280 --> 00:06:00.280
So obviously I did my training in medicine in medical school back in India.

00:06:00.280 --> 00:06:03.360
That's when I started to connect and talk to a lot of people.

00:06:03.360 --> 00:06:10.520
And some of my friends who actually were already writing apps at that time using Java applets

00:06:10.520 --> 00:06:11.520
and browsers.

00:06:11.520 --> 00:06:19.440
And so I started to make some connection in terms of images and learning how some of those

00:06:19.440 --> 00:06:20.800
things can be used in medicine.

00:06:20.800 --> 00:06:28.760
And so during my radiology rotation, that was my first real life-- that was my realization

00:06:28.760 --> 00:06:33.920
that actually in medicine, you can use computers a lot to handle a lot of these images, x-rays,

00:06:33.920 --> 00:06:34.920
CT scans.

00:06:34.920 --> 00:06:41.680
And I think as it went on, when I came to the US, that's where it really started off.

00:06:41.680 --> 00:06:50.080
During my residency in pathology here, I actually connected with my mentors, Dr. Anil Parwani

00:06:50.080 --> 00:06:53.080
and Dr. Leonard Pentamortz.

00:06:53.080 --> 00:06:56.080
They are well-known pathology informaticists.

00:06:56.080 --> 00:07:03.600
They've spent a lot of their time sort of dwelling in the world of pathology, medicine,

00:07:03.600 --> 00:07:05.800
and computer science.

00:07:05.800 --> 00:07:09.800
And so that is when I could actually realize that, yes, you can do a lot of innovative

00:07:09.800 --> 00:07:18.080
stuff by developing apps, algorithms, analyzing either image data or molecular data.

00:07:18.080 --> 00:07:25.120
And so that is when I started to put into designing an app, which was-- it's a very

00:07:25.120 --> 00:07:29.440
simple web app that was a project I was working with one of my mentors.

00:07:29.440 --> 00:07:33.760
And so his idea was that we had a lot of these pathology images, and we wanted to create

00:07:33.760 --> 00:07:39.600
a little in-browser app that would display these images as thumbnails, and then clicking

00:07:39.600 --> 00:07:43.120
the art that could enlarge the image, show it on display.

00:07:43.120 --> 00:07:48.840
And so I used-- at that time, it was .NET framework to be ASP.NET.

00:07:48.840 --> 00:07:53.080
And so I created a little app using Visual Basic.

00:07:53.080 --> 00:07:58.840
Slowly, I then migrated to using C# in the same environment.

00:07:58.840 --> 00:08:05.600
And that time, I started my advanced fellowship training in molecular pathology.

00:08:05.600 --> 00:08:09.960
That's when I started there.

00:08:09.960 --> 00:08:13.320
That's when I realized there is a lot of genomic sequencing data, where essentially you're

00:08:13.320 --> 00:08:16.320
dealing with a lot of strings and numbers.

00:08:16.320 --> 00:08:20.440
And you have to make a lot of sense in terms of this large volume of data that comes in.

00:08:20.440 --> 00:08:25.320
If we're working with-- so the kind of data that you're working with for, say, this genetic

00:08:25.320 --> 00:08:26.320
stuff?

00:08:26.320 --> 00:08:27.320
Yes.

00:08:27.320 --> 00:08:35.800
So for us, when you're studying the genomics, how much data is in, say, one strand of DNA?

00:08:35.800 --> 00:08:37.480
How much of that do you actually care about?

00:08:37.480 --> 00:08:41.560
Give us a sense of how much data we're talking.

00:08:41.560 --> 00:08:42.560
Right.

00:08:42.560 --> 00:08:45.560
So it really depends on what is being done.

00:08:45.560 --> 00:08:52.120
And so when we look at-- so when we talk about genomics, it is really designed on how the

00:08:52.120 --> 00:08:53.120
experiment is done.

00:08:53.120 --> 00:08:58.880
So for example, if you just simply look at the entire human genome, we are talking about

00:08:58.880 --> 00:09:00.880
3 billion alphabets.

00:09:00.880 --> 00:09:09.200
Essentially, it's the combination of four alphabets, A, T, G, and C. So these are the

00:09:09.200 --> 00:09:11.960
four nucleotides of the DNA sequence.

00:09:11.960 --> 00:09:16.720
And the RNA has one additional one, which replaces A. But the idea is that it's a mix

00:09:16.720 --> 00:09:18.760
and match of these sequences.

00:09:18.760 --> 00:09:25.480
And so if you think about the entire human genome as a single thread of A, T, G, and

00:09:25.480 --> 00:09:29.840
Cs in various combinations, you're looking at 3 billion alphabets.

00:09:29.840 --> 00:09:36.640
And so what happens is when we do these sequencing experiments where you would take the DNA molecule

00:09:36.640 --> 00:09:44.000
from a bunch of cells within a tissue, and then either we read all the 3 billion base

00:09:44.000 --> 00:09:50.080
pairs-- and typically, the way the sequencing is done is you read all of these sequences

00:09:50.080 --> 00:09:53.760
and from many molecules.

00:09:53.760 --> 00:10:01.160
And so you'll have multiple copies of that when you're translating from a molecular--

00:10:01.160 --> 00:10:08.280
like a chemical molecular structure to a DNA sequence on, say, a black file in a file system.

00:10:08.280 --> 00:10:14.200
So if you look at that large scale of data, like the entire genome, we are talking of

00:10:14.200 --> 00:10:17.960
hundreds of gigabytes, maybe even terabyte worth of data.

00:10:17.960 --> 00:10:22.640
Then there are other more practical approaches when we look at the genome.

00:10:22.640 --> 00:10:26.680
And especially this is something that we use for day-to-day patient care, which is referred

00:10:26.680 --> 00:10:28.680
to as targeted sequencing.

00:10:28.680 --> 00:10:34.800
What that means is instead of the 3 billion base pairs, we focus on those regions of the

00:10:34.800 --> 00:10:42.040
human genome that are of most pertinent use, or that we, at least as the current field

00:10:42.040 --> 00:10:44.520
of genomics, that we understand what to do with.

00:10:44.520 --> 00:10:51.400
And so there are certain genes that, at least in the space I work with, cancer genomics,

00:10:51.400 --> 00:10:59.360
that are, I would say, close to about maybe 1,000 to 2,000 genes which are known to be

00:10:59.360 --> 00:11:00.360
cancer-associated.

00:11:00.360 --> 00:11:08.080
And of that, roughly about 500 to 700 genes are where we know that they have been studied

00:11:08.080 --> 00:11:12.880
and demonstrated that there are certain types of abnormalities in those genes in terms of

00:11:12.880 --> 00:11:20.760
the sequence changes, that they have certain meaning in context of tumor in order to make

00:11:20.760 --> 00:11:26.880
a diagnosis or to understand if the tumor is aggressive or benign, or if there are certain

00:11:26.880 --> 00:11:29.840
treatments that could be applied to those tumors.

00:11:29.840 --> 00:11:36.680
And that's specifically linked to the kind of sequence change you see in that region

00:11:36.680 --> 00:11:37.680
of the genome.

00:11:37.680 --> 00:11:43.880
And we are talking about, practically speaking, when we talk about the targeted testing that

00:11:43.880 --> 00:11:47.720
we do, it's a very small fraction of the large genome.

00:11:47.720 --> 00:11:51.720
Typically, there's a term known as exome sequencing.

00:11:51.720 --> 00:11:58.560
And exome sequencing refers to sequencing all those regions of the human genome where

00:11:58.560 --> 00:12:02.880
it at least encodes for one or the other annotated gene.

00:12:02.880 --> 00:12:06.360
That is typically about 1% to 2% of the entire gene.

00:12:06.360 --> 00:12:12.240
And so if we further narrow it down to about, say, 500, 600 genes that one would typically

00:12:12.240 --> 00:12:20.640
sequence for clinical cancer molecular testing, I would say that's probably about a tenth,

00:12:20.640 --> 00:12:23.240
or maybe slightly less than that, of the genome.

00:12:23.240 --> 00:12:26.440
But it's a very high yield from a clinical standpoint.

00:12:26.440 --> 00:12:32.680
The most alteration you will find that would help with the clinical treatment is high.

00:12:32.680 --> 00:12:40.000
So if you're going to talk about that data set, it's complex in a different way, because

00:12:40.000 --> 00:12:49.360
just looking at the raw sequence data would be somewhere in, I would say, 1 to 20 gigs

00:12:49.360 --> 00:12:52.480
from a single sequence file.

00:12:52.480 --> 00:12:54.480
But it entirely depends on how deep we go.

00:12:54.480 --> 00:12:59.600
So for example, when we talk about sequencing, as I mentioned before, when we sequence a

00:12:59.600 --> 00:13:04.120
molecule, we can sequence it either at certain depths.

00:13:04.120 --> 00:13:09.840
That means what level of redundancy you want to be able to read that molecule.

00:13:09.840 --> 00:13:13.480
Sometimes we read the molecules 20 to 30 times.

00:13:13.480 --> 00:13:15.600
So that's referred to as 30x.

00:13:15.600 --> 00:13:18.080
Or sometimes we'll read that 500 times.

00:13:18.080 --> 00:13:21.560
So that would be 500x.

00:13:21.560 --> 00:13:25.160
Because you want to make sure you don't misread the...

00:13:25.160 --> 00:13:26.160
Yes.

00:13:26.160 --> 00:13:27.160
So, right.

00:13:27.160 --> 00:13:32.840
So what happens is the greater the depth of sequence, so typically for such large panels

00:13:32.840 --> 00:13:40.240
that we sequence in a clinical setting, we usually target about 1500x to 2000x.

00:13:40.240 --> 00:13:41.840
That means we're reading that 2000 times.

00:13:41.840 --> 00:13:48.320
So the more the depth it is, the possibility of identifying a certain variation or genomic

00:13:48.320 --> 00:13:51.320
alteration that is present at a very low level.

00:13:51.320 --> 00:13:56.920
For example, say, you have a tumor cell and within that, only 2% of the cells have this

00:13:56.920 --> 00:13:57.920
mutation.

00:13:57.920 --> 00:13:58.920
Others don't.

00:13:58.920 --> 00:14:04.360
And so when you're looking for or hunting for these needles in a haystack, you really

00:14:04.360 --> 00:14:07.840
want to maximize the amount of depth you have to be able to pick those things up.

00:14:07.840 --> 00:14:10.240
So it really depends on how deep we go.

00:14:10.240 --> 00:14:11.880
The more deep we go, the more data it is.

00:14:11.880 --> 00:14:15.840
And so it can scale up to almost several hundred gigabytes.

00:14:15.840 --> 00:14:16.840
Sure.

00:14:16.840 --> 00:14:23.600
Yeah, I've always wondered about how you can go and read somebody's genetics and then

00:14:23.600 --> 00:14:28.480
not make a mistake when you're reading it, using chemicals to read.

00:14:28.480 --> 00:14:32.520
So it's really ridiculous how much data is there.

00:14:32.520 --> 00:14:36.920
Off by one, a C for a G or whatever is a bad thing, right?

00:14:36.920 --> 00:14:37.920
Right.

00:14:37.920 --> 00:14:44.200
But it is, you know, I think as the technology has matured, there's always, there's nothing

00:14:44.200 --> 00:14:50.200
100% in terms of the error profile for the enzyme that has been used to work, the technology

00:14:50.200 --> 00:14:54.080
that is reading the actual fluorescence, converting that to signal.

00:14:54.080 --> 00:15:00.160
There's always statistical values and probabilities that are associated with what is the probability

00:15:00.160 --> 00:15:02.800
that it is wrong or incorrect or correct.

00:15:02.800 --> 00:15:10.040
But within that frame and where the current technology is, it's pretty accurate for, if

00:15:10.040 --> 00:15:13.680
not all, many of the regions of the genome.

00:15:13.680 --> 00:15:16.400
And so it's mind-boggling how it works.

00:15:16.400 --> 00:15:19.040
Yeah, it really is quite amazing.

00:15:19.040 --> 00:15:21.840
It's one of the modern marvels of science for sure.

00:15:21.840 --> 00:15:23.560
It is, it is.

00:15:23.560 --> 00:15:24.560
Yeah.

00:15:24.560 --> 00:15:28.840
So I think you're a little bit unusual, a little bit weird in the sense that you got

00:15:28.840 --> 00:15:35.800
into as your first sort of programming thing to bring to apply to your science and medicine

00:15:35.800 --> 00:15:45.600
side of things was C# rather than, or VB.NET rather than something like Python or R or

00:15:45.600 --> 00:15:46.600
something.

00:15:46.600 --> 00:15:50.240
So maybe talk a bit about that experience, contrast it with Python.

00:15:50.240 --> 00:15:53.440
Like why do you, why do you end up moving to Python?

00:15:53.440 --> 00:15:54.440
Yeah.

00:15:54.440 --> 00:16:04.520
So, you know, I think the reason I started using VB.NET C# was I would say most, it was

00:16:04.520 --> 00:16:10.080
probably influenced a lot by at the time when I was doing my med school in India, what was

00:16:10.080 --> 00:16:11.080
available at that time.

00:16:11.080 --> 00:16:14.680
It was not something I would just go to the internet and start getting a lot of resources

00:16:14.680 --> 00:16:16.420
as one would do now.

00:16:16.420 --> 00:16:20.520
So it was pretty much like, this is the book I have available and that's about to learn

00:16:20.520 --> 00:16:21.520
Python.

00:16:21.520 --> 00:16:22.520
That's the only thing.

00:16:22.520 --> 00:16:23.520
So you start.

00:16:23.520 --> 00:16:24.520
Yeah.

00:16:24.520 --> 00:16:31.600
And then, but the thing is when I started applying C# and it was mostly C# and a little

00:16:31.600 --> 00:16:37.320
bit of C++, I started to get into like with some of the non-genetic stuff initially while

00:16:37.320 --> 00:16:38.880
the project was working on.

00:16:38.880 --> 00:16:43.840
It was not too bad because I was able to accomplish most of the tasks.

00:16:43.840 --> 00:16:50.460
But then once I got into genomics and I came, so the way, you know, professionals who get

00:16:50.460 --> 00:16:56.320
into genomics and molecular pathology, there are a couple of different routes.

00:16:56.320 --> 00:17:02.040
So either the physician, people who are physician trained and they kind of have a formal background

00:17:02.040 --> 00:17:08.200
in medicine and they kind of do a specialized training and then they become molecular pathologist

00:17:08.200 --> 00:17:10.200
after getting board certified.

00:17:10.200 --> 00:17:14.040
There's the other route, which is more of a research background where people have spent

00:17:14.040 --> 00:17:17.680
a lot of their time in really deep research.

00:17:17.680 --> 00:17:22.880
They've learned a lot of genomics hands on, either from a computational background or

00:17:22.880 --> 00:17:26.400
from a more laboratory, like a wet laboratory background.

00:17:26.400 --> 00:17:31.200
And so they've spent, you know, they've obviously done their PhDs and postdoc training and then

00:17:31.200 --> 00:17:35.880
sort of coming to the molecular pathology field.

00:17:35.880 --> 00:17:41.880
People starting there tend to have more of a formal computational training.

00:17:41.880 --> 00:17:45.280
So they're getting, you know, they usually get, obviously when you start with a research

00:17:45.280 --> 00:17:50.160
lab, R, Python are sort of like the most common tools that are used for any kind of data analysis

00:17:50.160 --> 00:17:53.240
and data visualization.

00:17:53.240 --> 00:18:00.840
Coming from more of a foreign medicine background, typically when we get training in clinical

00:18:00.840 --> 00:18:06.520
informatics or pathology informatics, often it is very, you know, kind of, I would not

00:18:06.520 --> 00:18:10.880
say corporate based, but very formal application development space.

00:18:10.880 --> 00:18:17.520
So it's a lot of, you know, Windows based, .NET, C#, C++, that kind of thing.

00:18:17.520 --> 00:18:18.520
So

00:18:18.520 --> 00:18:22.000
Yeah, Java or .NET is a perfect choice.

00:18:22.000 --> 00:18:23.000
Yeah.

00:18:23.000 --> 00:18:24.000
Okay.

00:18:24.000 --> 00:18:29.280
In bioinformatics, at least in genomics bioinformatics, kind of the ecosystem of tools available,

00:18:29.280 --> 00:18:32.400
it's a mishmash of everything.

00:18:32.400 --> 00:18:36.480
For anything which is very computationally intensive, like when you're trying to align

00:18:36.480 --> 00:18:39.680
sequences to the human genome, those are very intensive tasks.

00:18:39.680 --> 00:18:47.560
And typically it's a lot of, you know, C, C++, Java, that's involved in some of these

00:18:47.560 --> 00:18:51.000
very mainstream tools that are available.

00:18:51.000 --> 00:18:54.520
More recently, I think we are seeing Rust coming into the picture as well.

00:18:54.520 --> 00:18:56.320
There's some Golang applications.

00:18:56.320 --> 00:19:02.360
And then of course, Python and R are the predominant, I think, tools, the program language that

00:19:02.360 --> 00:19:05.080
are used to solve a lot of these problems.

00:19:05.080 --> 00:19:11.160
So when I sort of started my molecular pathology fellowship and I got into, now I had to do

00:19:11.160 --> 00:19:17.240
this project that involved, you know, manipulating all the sequence data to a point where we

00:19:17.240 --> 00:19:21.360
would be able to develop an application that would help sort of, you know, it's a web based

00:19:21.360 --> 00:19:28.560
application that would help, you know, for other pathologists and faculty to read that

00:19:28.560 --> 00:19:32.880
sequencing data and, you know, digest in a very way that's easy for them to look at it

00:19:32.880 --> 00:19:36.760
rather than going to the Linux, you know, terminal and opening up like, you know, raw

00:19:36.760 --> 00:19:38.200
files and things like that.

00:19:38.200 --> 00:19:44.000
So I used, that was my first project was to use C# in that context.

00:19:44.000 --> 00:19:46.960
But I quickly realized that there was a lot of these algorithms that were natively either

00:19:46.960 --> 00:19:51.880
written in R or Python, and then having to, you know, incorporate those functionalities

00:19:51.880 --> 00:19:53.920
was not as easily possible.

00:19:53.920 --> 00:19:56.120
So I had to rewrite a lot of those things in C# primarily.

00:19:56.120 --> 00:20:00.880
You know, it was a good learning curve, but I think from a main derivative perspective

00:20:00.880 --> 00:20:03.320
was getting really difficult.

00:20:03.320 --> 00:20:07.480
And so that's when the realization was that I think the combination of Linux and Python

00:20:07.480 --> 00:20:11.800
was, you know, I had to move towards it.

00:20:11.800 --> 00:20:12.800
Yeah.

00:20:12.800 --> 00:20:15.960
C#, probably from the timeframe that you're thinking about, didn't really have a great

00:20:15.960 --> 00:20:22.280
package manager story, not to the same degree that Python does, although they do pretty

00:20:22.280 --> 00:20:24.280
good now over in the China land.

00:20:24.280 --> 00:20:25.280
Right.

00:20:25.280 --> 00:20:26.280
Yeah.

00:20:26.280 --> 00:20:27.280
All right.

00:20:27.280 --> 00:20:30.840
So Chris, in the audience says, is there a reason to use Python specifically?

00:20:30.840 --> 00:20:34.320
Like, are there some special sauce packages that make it attractive?

00:20:34.320 --> 00:20:36.080
It sounds like that's kind of what you were getting at.

00:20:36.080 --> 00:20:43.400
Like you found more solutions to these algorithms than, you know, available in Python than in

00:20:43.400 --> 00:20:44.400
C#.

00:20:44.400 --> 00:20:45.400
Yeah.

00:20:45.400 --> 00:20:46.400
Whatever languages.

00:20:46.400 --> 00:20:47.400
Yeah.

00:20:47.400 --> 00:20:48.400
Right.

00:20:48.400 --> 00:20:49.400
So I think, I mean, I think the simple answer is yes.

00:20:49.400 --> 00:20:54.960
I think the community and the amount of work that has been done in this particular space

00:20:54.960 --> 00:20:59.080
with genomics, I mean, when you are really searching for applications, it kind of falls

00:20:59.080 --> 00:21:03.760
into these three categories of, you know, anything which is a high performance compiling,

00:21:03.760 --> 00:21:09.440
you know, program that is usually in the Rust, you know, C++, C, a lot of, you know, those

00:21:09.440 --> 00:21:12.640
languages, a little bit of Rust and Java.

00:21:12.640 --> 00:21:17.720
And then the other bin is essentially kind of, you know, split up into Python and R.

00:21:17.720 --> 00:21:24.800
I think for me, Python was, and I think I'm sure others have shared the same way, where

00:21:24.800 --> 00:21:26.280
it's almost like, wow, this is amazing.

00:21:26.280 --> 00:21:30.880
Like coming from C#, it was a little bit of a change because there's no more, like, you

00:21:30.880 --> 00:21:35.920
know, curly braces and think about the whole things.

00:21:35.920 --> 00:21:36.920
Did you always use semicolons?

00:21:36.920 --> 00:21:37.920
Kind of.

00:21:37.920 --> 00:21:43.920
Like even now, sometimes when I write like a little bit of JavaScript, I'm like, oh yeah,

00:21:43.920 --> 00:21:44.920
okay, semicolons here.

00:21:44.920 --> 00:21:45.920
But not too bad.

00:21:45.920 --> 00:21:54.760
I think what I got onto was like the simplicity of the language and how powerful it was when

00:21:54.760 --> 00:21:58.960
like, if I'm thinking about, you know, it was interesting when I had to do something

00:21:58.960 --> 00:22:07.600
like there was an algorithm that I had to parse out certain, you know, strings in a

00:22:07.600 --> 00:22:15.480
way where it required some known workflows that we use to do like variant annotations

00:22:15.480 --> 00:22:19.400
when we are cross-referencing databases and putting them together.

00:22:19.400 --> 00:22:23.440
You know, when you look for in terms of like C# packages, I mean, there's really nothing

00:22:23.440 --> 00:22:25.240
there for it natively to do it.

00:22:25.240 --> 00:22:27.320
So you have to write a lot of those things.

00:22:27.320 --> 00:22:32.240
In Python, it's the amount of time that is spent in developing those things is much faster.

00:22:32.240 --> 00:22:37.680
Like the development time itself is quick because you either get an idea of somebody

00:22:37.680 --> 00:22:41.280
who's already done the work or there's a more formal package that you can use.

00:22:41.280 --> 00:22:46.880
So I think initially when I started off, my Python was a very interesting collection of

00:22:46.880 --> 00:22:47.880
packages.

00:22:47.880 --> 00:22:54.360
It was like a tool suite essentially written to, you know, to have all these functions

00:22:54.360 --> 00:22:57.280
available for very common day-to-day tasks.

00:22:57.280 --> 00:23:02.440
You know, I want to query certain region of the, you know, BAM file or I want to parse

00:23:02.440 --> 00:23:07.000
out certain things in the FASTQ file to look at, you know, some of the sequences or doing,

00:23:07.000 --> 00:23:12.920
you know, you know, counting number of sequences in a given file and, you know, getting read

00:23:12.920 --> 00:23:15.920
counts, things like that was, it's all out of the box.

00:23:15.920 --> 00:23:18.920
And so that was sort of like the first thing that, "Oh wow, this is amazing."

00:23:18.920 --> 00:23:21.920
And you can just say, "Somebody's already done the work."

00:23:21.920 --> 00:23:24.200
And you can just put it on top of it.

00:23:24.200 --> 00:23:25.200
So it was very cool.

00:23:25.200 --> 00:23:28.640
Instead of creating these, I'll just like use those.

00:23:28.640 --> 00:23:29.640
Perfect.

00:23:29.640 --> 00:23:30.640
Right.

00:23:30.640 --> 00:23:32.520
So that was one.

00:23:32.520 --> 00:23:36.560
And the other motivation to use Python was, you know, say for example, why not R?

00:23:36.560 --> 00:23:37.560
You know, why Python?

00:23:37.560 --> 00:23:42.400
Because R offers a very rich ecosystem in, you know, at least in genomics and visualization.

00:23:42.400 --> 00:23:49.720
So I think the second thing was in terms of the idea that I was working on was having

00:23:49.720 --> 00:23:55.120
to develop a web application and all of these bioinformatics, you know, toolings and algorithms

00:23:55.120 --> 00:23:57.000
running sort of in the back.

00:23:57.000 --> 00:24:00.960
And so at that time it was like, okay, well, you know, Python, I've not heard much about

00:24:00.960 --> 00:24:01.960
in terms of web application.

00:24:01.960 --> 00:24:07.280
Mostly it was, you know, again, this big, like, you know, C#, .NET, that was why I started

00:24:07.280 --> 00:24:09.080
off, you know, with that.

00:24:09.080 --> 00:24:12.840
But then at that time, you know, there was Django and then Flask was sort of coming in.

00:24:12.840 --> 00:24:16.120
It was a very minimalistic, you know, sort of application.

00:24:16.120 --> 00:24:17.120
So I started focusing on that.

00:24:17.120 --> 00:24:23.160
It was very easy with Flask to, you know, get up and running with very simple, you know,

00:24:23.160 --> 00:24:24.400
applications to do that.

00:24:24.400 --> 00:24:29.480
I didn't try much into Django just because it was too bloated for me.

00:24:29.480 --> 00:24:31.120
But you know, Flask was great.

00:24:31.120 --> 00:24:35.400
And then what I realized was you can create a simple web application, but then at the

00:24:35.400 --> 00:24:40.640
same time you can use all your, you know, myPythons and all the wonderful myMathematics

00:24:40.640 --> 00:24:42.360
packages in the backend.

00:24:42.360 --> 00:24:45.520
So it's like a single language that lets you do both.

00:24:45.520 --> 00:24:46.520
And so this is great.

00:24:46.520 --> 00:24:51.520
It was just, I don't have to go anywhere to learn, you know, a third or a fourth or a

00:24:51.520 --> 00:24:54.240
fifth different program language and this just gets job done.

00:24:54.240 --> 00:24:55.240
Yeah.

00:24:55.240 --> 00:24:58.920
Keep it in mind that your actually main, your main job is medicine, not programming, right?

00:24:58.920 --> 00:25:03.920
It's not like you're a CS person who's just all after, out to learn all the languages,

00:25:03.920 --> 00:25:04.920
right?

00:25:04.920 --> 00:25:05.920
Yeah.

00:25:05.920 --> 00:25:06.920
So that definitely is.

00:25:06.920 --> 00:25:12.400
And again, that's a, that's a huge, you know, I would say I'm, again, as I said, I'm in

00:25:12.400 --> 00:25:17.120
a, I'm sort of in an unusual position where I'm, you know, a physician, but I also do

00:25:17.120 --> 00:25:18.800
a lot of these application developments.

00:25:18.800 --> 00:25:24.320
So that certainly is an important point in terms of how much time I have to be able to

00:25:24.320 --> 00:25:25.320
develop these prototypes.

00:25:25.320 --> 00:25:29.560
And then obviously, you know, typically the way it works is at least right now here, you

00:25:29.560 --> 00:25:36.640
know, where I am currently working, I have an excellent and amazing team of developers

00:25:36.640 --> 00:25:40.240
and bioinformations who really do a lot of the development work on the front end, back

00:25:40.240 --> 00:25:41.240
end.

00:25:41.240 --> 00:25:46.720
And so for me to be able to take additional time out of my, you know, the clinical and

00:25:46.720 --> 00:25:48.440
the patient care work is limited.

00:25:48.440 --> 00:25:53.720
So if I can get whatever prototype I'm thinking of or developing the application fast, then,

00:25:53.720 --> 00:25:55.640
you know, that's, that's what I'm going for.

00:25:55.640 --> 00:25:56.640
Right.

00:25:56.640 --> 00:26:01.040
Then you can hand it off to the team and let them polish it up and product, make it production

00:26:01.040 --> 00:26:02.040
ready basically.

00:26:02.040 --> 00:26:03.040
Yeah.

00:26:04.040 --> 00:26:10.880
I was wondering how much time of your, your job do you get to spend on these kinds of

00:26:10.880 --> 00:26:15.640
things, you know, finding new packages, optimizing or improving the ways that you're working

00:26:15.640 --> 00:26:21.760
on stuff versus just sort of handing it off to the folks you work with and, and keeping,

00:26:21.760 --> 00:26:24.040
you know, focus more on the medicine side.

00:26:24.040 --> 00:26:25.040
Yeah.

00:26:25.040 --> 00:26:28.840
So it you know, that, that I think it's a good question.

00:26:28.840 --> 00:26:34.560
I think it's it's evolved over time as I've been sort of, you know, when I was in training

00:26:34.560 --> 00:26:40.400
and then being a faculty and then in a fact in this new position you know, one of the

00:26:40.400 --> 00:26:45.120
things I did was as part of my certification was to, you know, to get board certified in

00:26:45.120 --> 00:26:46.760
clinical informatics.

00:26:46.760 --> 00:26:51.960
That's a discipline by itself that involves a lot of, you know, it's a very broad field

00:26:51.960 --> 00:26:54.840
in terms of informatics and healthcare.

00:26:54.840 --> 00:26:57.760
And then one of the buckets there is, you know, software development.

00:26:57.760 --> 00:27:03.040
And so I was you know, I was quite interested sort of in that field.

00:27:03.040 --> 00:27:08.920
And so most of my time in terms of being able to devote to, you know, finding new packages

00:27:08.920 --> 00:27:15.320
or trying to, you know, write up an application that could solve a problem or coming up with

00:27:15.320 --> 00:27:20.640
prototypes was, it was done in a way that sort of aligned with the work I was doing.

00:27:20.640 --> 00:27:25.400
And so it would be days when I'm on clinical service where I'm mostly, you know, working

00:27:25.400 --> 00:27:28.440
on sort of with, you know, with patient care related matters.

00:27:28.440 --> 00:27:31.560
So those weeks would be, you know, obviously very busy.

00:27:31.560 --> 00:27:35.560
I would have, you know, I would wake up at like extremely early in the morning, spend

00:27:35.560 --> 00:27:39.880
the first two hours, four to six a.m. just, you know, working on this.

00:27:39.880 --> 00:27:42.000
And then I get back to like, you know, the clinical work.

00:27:42.000 --> 00:27:44.160
And then there would be weeks when I'm off clinical service.

00:27:44.160 --> 00:27:48.400
So I am not responsible for any patient care related work.

00:27:48.400 --> 00:27:54.040
And those weeks would be where I would spend time in terms of, you know, doing these, you

00:27:54.040 --> 00:27:58.360
know, investigating into sort of some of these packages and, you know, coming up with new

00:27:58.360 --> 00:28:02.200
ideas, exploring what is all, you know, what is available in terms of certain problems

00:28:02.200 --> 00:28:03.200
that I was solving.

00:28:03.200 --> 00:28:08.360
And, you know, that time sort of, you know, my quote protected time professionally was

00:28:08.360 --> 00:28:09.360
spent in that.

00:28:09.360 --> 00:28:13.600
And so that would be, you know, maybe a week spent into like, hey, we are trying to look

00:28:13.600 --> 00:28:18.640
into this variant amputation tool and then we want to, you know, write wrappers around

00:28:18.640 --> 00:28:24.520
it so it becomes easy for, you know, our labs operation to be able to use that.

00:28:24.520 --> 00:28:26.560
And so, so kind of that, that's how it works.

00:28:26.560 --> 00:28:31.320
So some of those either early mornings or, you know, the weeks I'm off clinical services

00:28:31.320 --> 00:28:34.120
and how, how that works.

00:28:34.120 --> 00:28:35.120
Yeah.

00:28:35.120 --> 00:28:36.120
Excellent.

00:28:36.120 --> 00:28:37.200
Is it changing fast?

00:28:37.200 --> 00:28:40.920
So I'll give you an analogy that you could tell me about your space.

00:28:40.920 --> 00:28:48.680
So on one hand, in Python web world, you mentioned Flask and Django, you know, Flask and Django,

00:28:48.680 --> 00:28:53.160
while they are evolving are kind of, they're kind of the way they have been and they're,

00:28:53.160 --> 00:28:54.160
they're pretty stable.

00:28:54.160 --> 00:28:59.440
And if you learn Flask five years ago, you're still good to use Flask today.

00:28:59.440 --> 00:29:07.880
Or is it more like FastAPI, pedantic, message spec, just there's something new all the time

00:29:07.880 --> 00:29:12.320
that you got to keep learning to bring in, are there a ton of new packages just coming

00:29:12.320 --> 00:29:16.600
online or is there a set of really solid ones?

00:29:16.600 --> 00:29:21.520
So I think it's both yes and no.

00:29:21.520 --> 00:29:24.640
And so it depends on what, you know, what area we're working on.

00:29:24.640 --> 00:29:30.640
So so right now in, in the clinical lab that I'm directing here, you know, when I came

00:29:30.640 --> 00:29:33.600
here in 2020, it was, you know, when we started off from scratch.

00:29:33.600 --> 00:29:40.200
So essentially the idea was to be able to bring up a pediatric cancer sequencing infrastructure

00:29:40.200 --> 00:29:41.200
that was not available.

00:29:41.200 --> 00:29:47.800
And so it was ground up from, you know, the lab to personal to space to everything.

00:29:47.800 --> 00:29:52.040
And so we kind of have this sort of, you know, two big bubbles in, in that operation from

00:29:52.040 --> 00:29:53.040
an informatics perspective.

00:29:53.040 --> 00:30:00.040
One of them is the, you know, we, we essentially are in the process of developing our custom

00:30:00.040 --> 00:30:04.000
lab information system that's essentially a web app.

00:30:04.000 --> 00:30:07.220
And so we have that space and the other space is bioinformatics.

00:30:07.220 --> 00:30:12.520
And so bioinformatics is a lot of, a lot of the custom scripting or the applications we

00:30:12.520 --> 00:30:14.480
develop is Python based.

00:30:14.480 --> 00:30:20.760
Some of them we do with the Golang, you know, when we need a little bit of performance aspect.

00:30:20.760 --> 00:30:23.080
And then the other aspect is the web app.

00:30:23.080 --> 00:30:28.360
So from a web app perspective, when we, when I started here, we actually started, we use

00:30:28.360 --> 00:30:30.480
FastAPI and Python.

00:30:30.480 --> 00:30:33.680
So that's kind of, you know, that was, so, you know, the idea was that, well, you know,

00:30:33.680 --> 00:30:37.720
since you're starting from scratch and I came to know about FastAPI at that point of time,

00:30:37.720 --> 00:30:42.040
the whole thing was about, you know, a single way that was, you know, I was pretty much

00:30:42.040 --> 00:30:43.960
sold on, on, on that aspect.

00:30:43.960 --> 00:30:46.640
And then, you know, I think the whole tool set made a lot of sense.

00:30:46.640 --> 00:30:51.480
I'm like, okay, well this is, this is perfect time to be able to, I think when I started

00:30:51.480 --> 00:30:55.900
FastAPI was, you know, 0.5 or 0.6.

00:30:55.900 --> 00:30:59.260
And so now obviously you can see a lot of change happening there.

00:30:59.260 --> 00:31:01.640
So yeah, that, that definitely is a lot of, you know, fast pace.

00:31:01.640 --> 00:31:08.240
And so we kind of do catching up in a sense where it has to be done in a, in a, in a careful

00:31:08.240 --> 00:31:09.240
way.

00:31:09.240 --> 00:31:15.240
The reason is because from, you know, as compared to more traditional research lab testing,

00:31:15.240 --> 00:31:19.840
where at the end really, you know, there's a lot of discovery, there's a lot of excitement

00:31:19.840 --> 00:31:26.240
at the end, it all translates into being sort of, you know, the data is presented at a conference

00:31:26.240 --> 00:31:29.520
or you publish that as a manuscript and that's the end point.

00:31:29.520 --> 00:31:36.280
So if you move off from version one to version three of algorithm, you know, you have to

00:31:36.280 --> 00:31:40.160
obviously make sure that your research, everything is reproducible, but beyond that is not a

00:31:40.160 --> 00:31:41.160
problem.

00:31:41.160 --> 00:31:45.800
But when we're talking about the same thing in context of a clinical care for a patient,

00:31:45.800 --> 00:31:47.920
the room for error is very, very little.

00:31:47.920 --> 00:31:49.440
You can't make mistakes.

00:31:49.440 --> 00:31:56.000
And so the entire space of clinical testing is very regulated in that sense, because there's

00:31:56.000 --> 00:32:00.160
a lot of requirement that, you know, you have to perform that any change that's happened

00:32:00.160 --> 00:32:01.160
in your pipeline.

00:32:01.160 --> 00:32:03.680
So you're using, you know, some version of an application.

00:32:03.680 --> 00:32:05.840
Now you operate to a newer version.

00:32:05.840 --> 00:32:10.240
You have to demonstrate that the analytical performance in terms of sensitivity and specificity

00:32:10.240 --> 00:32:12.560
for that pipeline didn't change.

00:32:12.560 --> 00:32:16.920
And so a lot of work is needed when you go do like a version upgrade.

00:32:16.920 --> 00:32:22.680
So we keep those things very controlled and careful versus some other things which are

00:32:22.680 --> 00:32:23.680
more in the R&D space.

00:32:23.680 --> 00:32:28.600
There's a little bit more room to play around with tools.

00:32:28.600 --> 00:32:29.600
Right.

00:32:29.600 --> 00:32:30.600
Yeah.

00:32:30.600 --> 00:32:33.960
Chris was asking an audience a great question about basically, is it more exploratory and

00:32:33.960 --> 00:32:36.840
you just move really fast and don't really worry about tests and stuff like that.

00:32:36.840 --> 00:32:41.040
It sounds like this is more of a production type thing.

00:32:41.040 --> 00:32:44.920
Like if you're going to run it over and over and if it gives a different answer at some

00:32:44.920 --> 00:32:48.880
point for testing for a disease or something that's really bad.

00:32:48.880 --> 00:32:50.760
You need it to be right all the time.

00:32:50.760 --> 00:32:51.760
And so.

00:32:51.760 --> 00:32:52.760
Yes.

00:32:52.760 --> 00:32:58.400
So the rule is when we do new test developments or we bring a new algorithm, obviously that

00:32:58.400 --> 00:33:04.480
part of which we refer to, there's a formal term that we use in lab medicines called familiarization

00:33:04.480 --> 00:33:06.880
and optimization or ONF phase.

00:33:06.880 --> 00:33:11.360
That's where, you know, there's a lot of flexibility, new tools, new version, trying out different

00:33:11.360 --> 00:33:12.360
things.

00:33:12.360 --> 00:33:14.360
And then it goes from that into the validation phase.

00:33:14.360 --> 00:33:18.240
And then once we deploy the application, once the deployment is there, it's a production

00:33:18.240 --> 00:33:19.240
application.

00:33:19.240 --> 00:33:24.080
We don't touch it unless something really has to be tinkered with or there's a bug that

00:33:24.080 --> 00:33:25.640
we have to fix.

00:33:25.640 --> 00:33:27.000
Who's in charge of running those apps?

00:33:27.000 --> 00:33:33.440
Is that people on your team and your lab or is that the hospital or how?

00:33:33.440 --> 00:33:34.520
Yeah.

00:33:34.520 --> 00:33:39.600
So the way it is set up here is, so when I started off, I was the end of one.

00:33:39.600 --> 00:33:42.600
So I started off with the FastAPI application.

00:33:42.600 --> 00:33:49.000
I had to build up the, we had a bioinformatics pipeline that I had initially authored.

00:33:49.000 --> 00:33:54.840
But then when we went through the validation phase, I luckily had two people on staff who

00:33:54.840 --> 00:33:58.660
kind of were handling the bioinformatics on the front end.

00:33:58.660 --> 00:34:01.520
And then eventually we had a third person who joined the team.

00:34:01.520 --> 00:34:08.080
So then they were kind of helping me out with a lot of the actual groundwork of writing

00:34:08.080 --> 00:34:13.560
the code, getting tests done, going through the validation data, summarizing that for

00:34:13.560 --> 00:34:14.560
me.

00:34:14.560 --> 00:34:18.600
Being a lab director, it is my responsibility ultimately to sign off on all those things

00:34:18.600 --> 00:34:23.160
and say, "Hey, okay, this is the validation and this is what is being demonstrated that

00:34:23.160 --> 00:34:28.000
your package or your pipeline or whatever you're working on demonstrates this level

00:34:28.000 --> 00:34:29.000
of sensibility."

00:34:29.000 --> 00:34:32.680
Then yes, I being a lab director say that, "Yes, this is working."

00:34:32.680 --> 00:34:36.960
And once that happens, so we then deploy those applications in production.

00:34:36.960 --> 00:34:41.840
We use GitHub and the usual dev, test, prod, pipeline.

00:34:41.840 --> 00:34:44.360
So that's kind of how it works.

00:34:44.360 --> 00:34:45.360
Cool.

00:34:45.360 --> 00:34:50.480
Do you have your own hardware or do you have stuff like on DigitalOcean or AWS?

00:34:50.480 --> 00:34:57.160
So with healthcare data, there is generally a little bit of angst with data sitting on

00:34:57.160 --> 00:35:00.160
cloud outside the support institution.

00:35:00.160 --> 00:35:07.720
I would say the institution that I work on is very, that way it's quite very forward

00:35:07.720 --> 00:35:11.420
thinking and being able to use modern technology.

00:35:11.420 --> 00:35:19.200
So what we started off and since it was everything being built up from scratch, we are taking

00:35:19.200 --> 00:35:22.640
the decision to keep things on-prem for beginning.

00:35:22.640 --> 00:35:28.280
But we also kept in mind that at some point of time, if the institution decides that,

00:35:28.280 --> 00:35:34.160
"Oh, we're going to switch our infrastructure to using AWS or Azure or whatever the platform

00:35:34.160 --> 00:35:37.000
is going to be," we want it to be ready.

00:35:37.000 --> 00:35:45.280
And so the way we had it set up, and this is due to our amazing IS team here at our

00:35:45.280 --> 00:35:47.120
institution.

00:35:47.120 --> 00:35:53.600
So we had our own hardware that we got in terms of the actual servers.

00:35:53.600 --> 00:36:01.080
And we collaborated with the IS team to be able to help us build our Kubernetes infrastructure.

00:36:01.080 --> 00:36:09.520
So we have a test and a prod Kubernetes cluster, and then all our apps and the bioinformatics

00:36:09.520 --> 00:36:10.520
pipeline.

00:36:10.520 --> 00:36:14.600
Well, the apps for now and the bioinformatics pipeline that we're looking forward in the

00:36:14.600 --> 00:36:17.600
near future to get deployed on these things.

00:36:17.600 --> 00:36:24.200
As a matter of fact, what we've done is our dev team, we do a lot of the development on

00:36:24.200 --> 00:36:25.760
Kubernetes as well.

00:36:25.760 --> 00:36:28.960
And then we keep moving all these things as containerized applications.

00:36:28.960 --> 00:36:30.720
That's excellent.

00:36:30.720 --> 00:36:36.800
So really embracing containers and Docker and Kubernetes, that should make it super

00:36:36.800 --> 00:36:39.200
easy to move to wherever you want to go, right?

00:36:39.200 --> 00:36:43.840
Anything that can run Kubernetes, you just push to that and you're good to go.

00:36:43.840 --> 00:36:44.840
Right, right.

00:36:44.840 --> 00:36:51.560
And it's a little bit difficult to start with, but I think once we are in that stream,

00:36:51.560 --> 00:36:55.160
it is much less effort to move things around.

00:36:55.160 --> 00:37:01.800
Yeah, last year I rewrote all of our servers and APIs and condensed six to eight servers

00:37:01.800 --> 00:37:04.200
all into one Docker cluster.

00:37:04.200 --> 00:37:05.660
And it was a great decision.

00:37:05.660 --> 00:37:09.840
But to me, it was also a little intimidating to say, well, here's one more thing I layer,

00:37:09.840 --> 00:37:11.720
I have to manage and understand.

00:37:11.720 --> 00:37:14.760
And if something goes wrong there, then everything else still breaks.

00:37:14.760 --> 00:37:17.960
So having it set up is really nice once you get used to it.

00:37:17.960 --> 00:37:18.960
Yes, right.

00:37:18.960 --> 00:37:23.040
All right, let's talk a bit about, well, I have a question for you.

00:37:23.040 --> 00:37:28.720
I want to talk about some of these packages that you've been saying are a lot of the reasons

00:37:28.720 --> 00:37:30.320
you chose Python and use a lot.

00:37:30.320 --> 00:37:31.320
It's great.

00:37:31.320 --> 00:37:36.800
But before we get there, I got the biopython.org website pulled up.

00:37:36.800 --> 00:37:42.440
And the very first line is, "Biopython is a set of freely available tools."

00:37:42.440 --> 00:37:44.960
You know, open source, freely available.

00:37:44.960 --> 00:37:46.880
How much does that matter to you guys?

00:37:46.880 --> 00:37:53.000
On one hand, you have a ton of money being in the medical space.

00:37:53.000 --> 00:37:54.480
It's really high stakes.

00:37:54.480 --> 00:38:02.200
So paying for commercial software or commercial libraries is probably not the biggest worry.

00:38:02.200 --> 00:38:05.360
On the other hand, open source is really nice.

00:38:05.360 --> 00:38:07.440
Being able to look inside is really nice.

00:38:07.440 --> 00:38:11.440
Free means you don't have to deal with getting permission.

00:38:11.440 --> 00:38:12.440
How does that fit into your world?

00:38:12.440 --> 00:38:15.240
I know how it fits into small startups and things like that.

00:38:15.240 --> 00:38:21.520
But for a hospital, for example, what does free and open source mean to you guys?

00:38:21.520 --> 00:38:30.040
I think it does have a lot of impact in terms of how we end up working and setting up these

00:38:30.040 --> 00:38:31.040
things.

00:38:31.040 --> 00:38:38.840
And obviously, whatever I'm speaking is representing what it means from an operational standpoint.

00:38:38.840 --> 00:38:45.400
When we talk about molecular pathology, generally being able to bring up a clinical service

00:38:45.400 --> 00:38:49.200
like that is a huge investment.

00:38:49.200 --> 00:38:51.960
And so a lot of the investment is...

00:38:51.960 --> 00:38:56.440
And this is generally applicable to any institution where something like this has been set up

00:38:56.440 --> 00:39:01.880
for patient care or clinical use.

00:39:01.880 --> 00:39:10.520
The investment is primarily in a lot of the instrumentation and the reagents that we use

00:39:10.520 --> 00:39:15.120
are generally quite expensive, which is sort of the...

00:39:15.120 --> 00:39:22.200
I would say when we talk about what is the cost of a test when it's offered, that cost

00:39:22.200 --> 00:39:28.720
factors in a lot of these operational costs that we need to buy these expensive sequencing

00:39:28.720 --> 00:39:33.440
instruments, the reagents that are used as consumables as we do the test over and over

00:39:33.440 --> 00:39:37.120
again every week, every month.

00:39:37.120 --> 00:39:44.600
So from that standpoint, traditionally, the way things have been designed is, I would

00:39:44.600 --> 00:39:50.200
say 10 years back when we would work with our finance team to say, "Okay, the cost of

00:39:50.200 --> 00:39:54.600
the test is going to be so and so based on all of these different inputs."

00:39:54.600 --> 00:40:02.120
And so 10 years back, computation, bioinformatics, all of these were not factored in at all.

00:40:02.120 --> 00:40:12.280
But now as we are in that era where using GPUs on a regular basis to be able to do simple...

00:40:12.280 --> 00:40:17.080
I would not say simple, but routine work to get from the raw sequence data to be able

00:40:17.080 --> 00:40:19.960
to identify genomic variants, that's getting common.

00:40:19.960 --> 00:40:23.880
Using FPGAs, using large clusters to be able to perform these tasks.

00:40:23.880 --> 00:40:29.640
And so now we are starting to see those costs getting in as part of the ultimate cost that

00:40:29.640 --> 00:40:31.480
goes to the patient for a test.

00:40:31.480 --> 00:40:33.720
And so we try to minimize those things.

00:40:33.720 --> 00:40:37.000
One of the way to be able to minimize those things is to be able to choose between free

00:40:37.000 --> 00:40:39.840
open source versus something which is a commercial product.

00:40:39.840 --> 00:40:44.920
And it's always a balance between the reliability and the service that you're able to get back

00:40:44.920 --> 00:40:46.800
saying, "Hey, something breaks down.

00:40:46.800 --> 00:40:52.880
We know there's an SLA, there's a certain assurance that this thing is going to be able

00:40:52.880 --> 00:40:59.760
to have help," versus open source free would be where we feel very confident in the code

00:40:59.760 --> 00:41:00.760
base.

00:41:00.760 --> 00:41:08.440
Sometimes what happens is when we use some of these open source tools, we end up almost

00:41:08.440 --> 00:41:12.840
invariably having some wrapper around it to change things or being able to have some insight

00:41:12.840 --> 00:41:14.200
into the source code.

00:41:14.200 --> 00:41:18.000
So it depends on that balance, what we choose.

00:41:18.000 --> 00:41:26.720
How often do you fork it and use your self-maintained version versus just run what is publicly on

00:41:26.720 --> 00:41:30.920
PyPI and then maybe wrap it to orchestrate it a bit?

00:41:30.920 --> 00:41:37.040
So I would say for the web application part of it, we don't really do a lot of forking.

00:41:37.040 --> 00:41:38.360
We kind of go with what it is.

00:41:38.360 --> 00:41:43.080
The only thing what we do is, since we have the luxury of using a combination of GitHub

00:41:43.080 --> 00:41:48.960
and containers, and knowing the fact that the regulatory requirements require that you

00:41:48.960 --> 00:41:53.600
tightly version control all these things with history and all those things, we tend to,

00:41:53.600 --> 00:41:57.520
when we are developing these things, when we are validating it, before we do that, we

00:41:57.520 --> 00:42:00.800
try to stick to a fairly stable version.

00:42:00.800 --> 00:42:05.040
So for example, things like beta or release candidates, we try to stay away from that,

00:42:05.040 --> 00:42:10.760
even if they have some desirable features, but unless we see a full production version

00:42:10.760 --> 00:42:12.380
of that, we don't tend to switch to it.

00:42:12.380 --> 00:42:18.440
So we keep things like that without maintaining or without forking or making modifications.

00:42:18.440 --> 00:42:22.680
When we get into more of the bioinformatics stuff, where we are actually trying to use

00:42:22.680 --> 00:42:28.480
an algorithm to solve a particular piece of part of the pipeline that is doing some data

00:42:28.480 --> 00:42:35.000
transformation, it depends on how much we want to change or modify.

00:42:35.000 --> 00:42:37.520
That's when we sometimes fork it.

00:42:37.520 --> 00:42:41.440
Sometimes we fork where we know that, and this is kind of the unfortunate reality in

00:42:41.440 --> 00:42:45.680
many of the scenarios where you have great open source tool, but after some time, due

00:42:45.680 --> 00:42:50.840
to whatever financial or business or other reasons that they stop maintaining.

00:42:50.840 --> 00:42:53.880
And so essentially we kind of get into this freeze mode.

00:42:53.880 --> 00:42:56.240
We tend to fork that, so at least we have that available.

00:42:56.240 --> 00:43:02.120
And then if we make any changes that we kind of keep it to that fork.

00:43:02.120 --> 00:43:08.720
But generally I would say it's probably in the 80-20 where 20% is where we fork it, make

00:43:08.720 --> 00:43:09.980
some change.

00:43:09.980 --> 00:43:14.320
Most of the times we try not to do that.

00:43:14.320 --> 00:43:16.800
But yes, open source free tools have a big impact.

00:43:16.800 --> 00:43:21.280
A lot of the tools that we use as part of our bioinformatics pipeline, as a matter of

00:43:21.280 --> 00:43:25.880
fact, which is kind of used in the community of molecular pathology to build these bioinformatics

00:43:25.880 --> 00:43:30.120
pipeline, they tend to use a lot of open source tools.

00:43:30.120 --> 00:43:35.680
And the reason for that is, for example, it's not written in Python, but there's an algorithm

00:43:35.680 --> 00:43:36.680
called BWA.

00:43:36.680 --> 00:43:40.280
It's written by Professor Heng Lee.

00:43:40.280 --> 00:43:45.120
That's one of the algorithms that is almost like a de facto, I would say, when it comes

00:43:45.120 --> 00:43:47.340
to doing sequence alignment.

00:43:47.340 --> 00:43:48.820
That's a part of the pipeline.

00:43:48.820 --> 00:43:54.960
And so it's a tried and tested application for more than a decade now.

00:43:54.960 --> 00:43:55.960
So really there's not a...

00:43:55.960 --> 00:43:59.600
And this is a fairly stable algorithm or application.

00:43:59.600 --> 00:44:00.600
We don't tend to...

00:44:00.600 --> 00:44:03.100
It's well maintained from an open source perspective.

00:44:03.100 --> 00:44:04.600
So those obviously are highly...

00:44:04.600 --> 00:44:06.280
We highly rely on those.

00:44:06.280 --> 00:44:12.320
But there's this whole ecosystem of softwares that come under this rubric term of variant

00:44:12.320 --> 00:44:16.560
calling, where we're trying to identify these different variants.

00:44:16.560 --> 00:44:18.320
There's a whole bunch of those.

00:44:18.320 --> 00:44:21.000
And some are fairly well maintained.

00:44:21.000 --> 00:44:22.960
They are open source.

00:44:22.960 --> 00:44:29.200
Sometimes depending on the context you're using, you need a license if it is used in

00:44:29.200 --> 00:44:31.240
a commercial setting.

00:44:31.240 --> 00:44:34.080
You don't need a license if it is in an academic setting.

00:44:34.080 --> 00:44:41.240
For example, when we do clinical testing in institutions such as where I am right now,

00:44:41.240 --> 00:44:42.240
that's an academic institution.

00:44:42.240 --> 00:44:45.360
So typically it's not for profit.

00:44:45.360 --> 00:44:51.200
And so obviously we don't need licenses for that use.

00:44:51.200 --> 00:44:55.320
But once this goes into a pure commercial space, where if the lab is doing all of this

00:44:55.320 --> 00:44:58.200
testing for profit, then there's a license requirement.

00:44:58.200 --> 00:45:04.480
So we see a combination of these things showing up in the...

00:45:04.480 --> 00:45:08.760
It's actually becoming more common now with open source tools that...

00:45:08.760 --> 00:45:12.280
At least in the genomic bioinformatics space.

00:45:12.280 --> 00:45:13.280
Yeah.

00:45:13.280 --> 00:45:14.280
Oh, excellent.

00:45:14.280 --> 00:45:19.800
I think another benefit probably for you guys, I know it's a benefit for a lot of organizations,

00:45:19.800 --> 00:45:25.880
is if you use the open source tools and you need to hire somebody new, there's a good

00:45:25.880 --> 00:45:29.640
chance that they have experience already with those tools.

00:45:29.640 --> 00:45:35.320
Whereas if you use something private, expensive, you might have to teach them from scratch

00:45:35.320 --> 00:45:37.320
what the thing is, right?

00:45:37.320 --> 00:45:39.000
Yes, that is correct.

00:45:39.000 --> 00:45:44.240
As a matter of fact, it's fortunate that a lot of the people who've done a lot of good

00:45:44.240 --> 00:45:51.320
work and have contributed to the genomics bioinformatics space have...

00:45:51.320 --> 00:45:57.880
The general tendency is whenever we are setting up any sort of pipelines for DNA sequencing,

00:45:57.880 --> 00:46:05.400
RNA sequencing, or more from a research perspective, methylation sequencing, single cell RNA-seq,

00:46:05.400 --> 00:46:11.400
UMI based error corrected variant calling, there's a lot of...

00:46:11.400 --> 00:46:13.240
There's a very thriving open source space.

00:46:13.240 --> 00:46:17.920
And so that really helps with people who come in.

00:46:17.920 --> 00:46:21.400
Even if they're not familiar with these tools, it's easy to get familiar with because there's

00:46:21.400 --> 00:46:25.200
a lot of community backing that up.

00:46:25.200 --> 00:46:31.880
Or as you said, when we hire people who already are coming from a different lab or they've

00:46:31.880 --> 00:46:36.320
had some experience, but they come and say, "Oh yeah, we know how to do alignment or I'm

00:46:36.320 --> 00:46:39.200
aware of these applications that use that."

00:46:39.200 --> 00:46:43.640
It is much, much easier from a learning curve perspective rather than having to now open

00:46:43.640 --> 00:46:49.040
up a manual and this is the proprietary thing that only works here.

00:46:49.040 --> 00:46:50.040
Yes.

00:46:50.040 --> 00:46:51.040
Exactly.

00:46:52.040 --> 00:46:53.040
Cool.

00:46:53.040 --> 00:46:54.040
All right.

00:46:54.040 --> 00:46:58.280
Well, we coordinated a bit on a list of packages that you've used in your lab or find really

00:46:58.280 --> 00:46:59.600
helpful for your work.

00:46:59.600 --> 00:47:02.480
And maybe we could touch on those just a little bit.

00:47:02.480 --> 00:47:03.480
Yeah.

00:47:04.480 --> 00:47:10.440
So CNVKit, genome-wide copy number from high throughput sequencing.

00:47:10.440 --> 00:47:12.280
I don't know what that means, but tell us about it.

00:47:12.280 --> 00:47:13.280
Yeah.

00:47:13.280 --> 00:47:20.080
So copy, so CNV or copy number variation, this is a type of genomic alteration where

00:47:20.080 --> 00:47:28.120
what happens is in a simplistic way, at least when we talk about cancer, the cancer cells

00:47:28.120 --> 00:47:33.320
sometimes for it to be able to survive, it tries to use different ways of doing that

00:47:33.320 --> 00:47:34.320
biologically.

00:47:34.320 --> 00:47:40.320
One of the way to do that is certain genes that help a cell to grow in the absence of

00:47:40.320 --> 00:47:43.920
nutrients or with very little nutrition is certain genes.

00:47:43.920 --> 00:47:48.480
If it has more copies of those genes than normal, then it will go, okay.

00:47:48.480 --> 00:47:50.440
It's like you have more money than expected.

00:47:50.440 --> 00:47:52.080
You can do a lot of things.

00:47:52.080 --> 00:47:57.280
So typically what happens is in a normal human genome, any cell that we pick up, it will

00:47:57.280 --> 00:47:58.880
only have two copies of the gene.

00:47:58.880 --> 00:48:01.320
One is coming from your mom, one is coming from your dad.

00:48:01.320 --> 00:48:07.800
In cancer, what happens is in certain scenarios, if a gene that helps with growth of the cell

00:48:07.800 --> 00:48:13.160
or it helps the cell to survive even without signal or nutrition, if it has more copies

00:48:13.160 --> 00:48:16.400
of that, it'll make six, eight, 20, 50 copies.

00:48:16.400 --> 00:48:21.800
It can survive versus there are certain scenarios where if there is a gene that is supposed

00:48:21.800 --> 00:48:24.640
to regulate the cells, it doesn't go haywire.

00:48:24.640 --> 00:48:28.120
If the cancer is able to delete one of the cells, one of the genes out, then you only

00:48:28.120 --> 00:48:29.120
have one gene left.

00:48:29.120 --> 00:48:32.040
You knock out a thing and then that protective mechanism is gone.

00:48:32.040 --> 00:48:34.340
So then the cancer cell can easily survive.

00:48:34.340 --> 00:48:40.360
So what happens is with CNV or copy number variations, the idea is that we use the high

00:48:40.360 --> 00:48:45.720
throughput sequencing data to be able to infer how many copies of these genes do we have.

00:48:45.720 --> 00:48:48.200
Is it more than two, is it less than two?

00:48:48.200 --> 00:48:56.000
And so this particular package, it's a very, very well-established, well-maintained package

00:48:56.000 --> 00:49:00.900
in the community that essentially does this thing, is you give it the sequencing data

00:49:00.900 --> 00:49:05.680
and define the regions of the genome that you're interested in.

00:49:05.680 --> 00:49:12.440
You can also provide names for the regions, like this region is gene B-RAF or this is

00:49:12.440 --> 00:49:15.340
EGFR or whatever you're interested in.

00:49:15.340 --> 00:49:20.160
And then what I do is I will do all the analysis to be able to tell you that, okay, well, when

00:49:20.160 --> 00:49:26.080
we are comparing this particular tumor against this reference set of 20 normal samples, where

00:49:26.080 --> 00:49:30.320
we know that you should only have two copies of the gene, in this particular tumor, we

00:49:30.320 --> 00:49:32.160
are seeing there are 50 copies of the gene.

00:49:32.160 --> 00:49:39.960
So it gives you kind of an output data that numerical can tell you that what it does is

00:49:39.960 --> 00:49:46.840
it does a log-proof-based transformation of the tracing that, okay, after all this computation,

00:49:46.840 --> 00:49:52.920
when I compare to the normal, this is 50 times more, or this is 20 times more the expected

00:49:52.920 --> 00:49:58.220
copy, or it is half of the amount of copy we need in terms of deletions.

00:49:58.220 --> 00:50:00.120
So that's what really it does.

00:50:00.120 --> 00:50:03.200
And it's written in Python.

00:50:03.200 --> 00:50:08.320
It uses a lot of, you know, Python, it has Python dependencies that use, that have been

00:50:08.320 --> 00:50:13.920
written in sort of, you know, in either C or like, you know, Python C bindings.

00:50:13.920 --> 00:50:17.320
But at the end, it gives you that data.

00:50:17.320 --> 00:50:24.440
And it has an internal visualization tool, but I was not very happy with how it was written.

00:50:24.440 --> 00:50:28.440
So I ended up writing a wrapper, which is called CNA plotter.

00:50:28.440 --> 00:50:29.440
It's open source.

00:50:29.440 --> 00:50:37.920
It essentially uses the end data for, from CNB kit, and then it gives you a nice visualization

00:50:37.920 --> 00:50:38.920
of the copy numbers.

00:50:38.920 --> 00:50:42.320
I think if you go down, if you scroll down, there's an example of this.

00:50:42.320 --> 00:50:43.600
Yeah, you have this on GitHub.

00:50:43.600 --> 00:50:47.280
So people can, if people want to use this, it's right there, right?

00:50:47.280 --> 00:50:48.280
Yep, it's right there.

00:50:48.280 --> 00:50:49.280
Yeah.

00:50:49.280 --> 00:50:52.280
So I think at the very bottom of the images, there's screenshots there.

00:50:52.280 --> 00:50:53.280
Oh, yeah.

00:50:53.280 --> 00:50:54.280
Yep, right here.

00:50:54.280 --> 00:50:55.280
Yeah.

00:50:55.280 --> 00:51:01.000
So for example, the first image over here, you can see this, you know, it's a thin band

00:51:01.000 --> 00:51:02.400
of all these multicolored things.

00:51:02.400 --> 00:51:04.800
And each one of them is a single human chromosome.

00:51:04.800 --> 00:51:08.160
So chromosome one, two, three, four, so on and so forth.

00:51:08.160 --> 00:51:14.840
And if you look at the image, it is at, you know, the Y scale essentially is log two,

00:51:14.840 --> 00:51:19.440
which is zero and going up, it is one, two, three, and then it's a negative scale on the

00:51:19.440 --> 00:51:20.580
lower side.

00:51:20.580 --> 00:51:25.520
So anything going above zero means you have more copies than two, while below is less,

00:51:25.520 --> 00:51:27.360
you know, less than two copies.

00:51:27.360 --> 00:51:32.160
And so if you see here in this example, the plot here, you see the very end which says

00:51:32.160 --> 00:51:38.240
chromosome X is a single, you know, the band over here is lower at negative one.

00:51:38.240 --> 00:51:42.080
That means this is a male patient with a single X chromosome.

00:51:42.080 --> 00:51:45.200
As compared to females who have two, you know, two X chromosomes.

00:51:45.200 --> 00:51:51.180
And so when we look at this plot below here, this is actually a plot from a, you know,

00:51:51.180 --> 00:51:54.500
a cell line, a tumor cell line that is abnormal.

00:51:54.500 --> 00:51:57.620
And here we see there are two genes which are amplified.

00:51:57.620 --> 00:52:01.660
One of them is a gene known as TERT.

00:52:01.660 --> 00:52:03.220
And the other gene is MDM2.

00:52:03.220 --> 00:52:08.620
So these two genes are again, one of those examples where it gives the tumor survival

00:52:08.620 --> 00:52:09.860
advantage over other.

00:52:09.860 --> 00:52:13.340
And so you can see here, there are multiple copies of these genes as compared to, you

00:52:13.340 --> 00:52:14.860
know, the baseline over here.

00:52:14.860 --> 00:52:15.860
I see.

00:52:15.860 --> 00:52:20.540
So that might predict something like the, how survivable the cancer is.

00:52:20.540 --> 00:52:21.540
Right.

00:52:21.540 --> 00:52:25.940
So if it is, is it going to be localized, say where it happened, or it's going to like

00:52:25.940 --> 00:52:31.540
spread to other parts of the body or be difficult to treat or be resistant to treatment.

00:52:31.540 --> 00:52:34.740
So if this is you, you want higher numbers, not lower numbers.

00:52:34.740 --> 00:52:35.740
It all depends.

00:52:35.740 --> 00:52:40.620
I mean, certain things are good genes, for example, you know, if there is a, there are

00:52:40.620 --> 00:52:45.180
certain checkpoint genes, if those, those numbers, you know, if they have lower numbers,

00:52:45.180 --> 00:52:48.980
you want to have two copies of them, because if that protective mechanism is gone, you

00:52:48.980 --> 00:52:53.220
know, the tumor becomes very aggressive.

00:52:53.220 --> 00:52:54.740
So it is all into context.

00:52:54.740 --> 00:52:58.540
So if you're looking at the good genes, you want to have two copies of the good gene.

00:52:58.540 --> 00:53:01.740
If you're looking at some of the bad genes, you don't want to have more than two copies

00:53:01.740 --> 00:53:02.740
of the bad genes.

00:53:02.740 --> 00:53:03.740
One or zero is better.

00:53:03.740 --> 00:53:04.740
I got it.

00:53:05.740 --> 00:53:06.740
Okay.

00:53:07.740 --> 00:53:08.740
HGVS.

00:53:08.740 --> 00:53:09.740
Yes.

00:53:09.740 --> 00:53:10.740
So HGVS is a wonderful package.

00:53:10.740 --> 00:53:16.860
That was initially, I think it was started by a person named Reese Hart.

00:53:16.860 --> 00:53:20.500
He's I think he still maintains it, but there's a lot of like, you know, it's a very well

00:53:20.500 --> 00:53:24.260
publicly maintained open source package.

00:53:24.260 --> 00:53:30.020
It's a lot of, you know, community involvement in that as well.

00:53:30.020 --> 00:53:36.940
So what HGVS is, it's a nomenclature system for, you know, giving a name to all these

00:53:36.940 --> 00:53:37.940
variations.

00:53:37.940 --> 00:53:42.180
So we're going to talk about, I'm not sure if Michael, if you've heard about the term

00:53:42.180 --> 00:53:43.180
mutation.

00:53:43.180 --> 00:53:47.340
So mutation is a very commonly used term that refers to some kind of abnormality in the

00:53:47.340 --> 00:53:50.180
genome.

00:53:50.180 --> 00:53:55.620
In this case, so what happens is there are these standards that are, that, you know,

00:53:55.620 --> 00:54:00.220
most clinical labs follow when they're putting all of this information in the patient report

00:54:00.220 --> 00:54:05.260
saying, okay, you know, this particular tumor has, you know, mutation in B-Ref, mutation

00:54:05.260 --> 00:54:07.260
in EGFR, some other gene.

00:54:07.260 --> 00:54:12.540
And there is a certain way that those mutations are described in terms of what sequence alterations

00:54:12.540 --> 00:54:17.980
happening say at the mRNA level and what sequence alterations are happening at the protein level.

00:54:17.980 --> 00:54:22.860
So now in your protein, you know, you're missing these amino acids or you have excess of these

00:54:22.860 --> 00:54:25.860
amino acids or something got switched from here to there.

00:54:25.860 --> 00:54:31.500
So there's a formal way of defining that and the guidelines of the group that defines that

00:54:31.500 --> 00:54:35.620
is referred to as HGVS, Human Genome Variation Society.

00:54:35.620 --> 00:54:40.540
And so it's a very complicated process where you have to do all these translations from

00:54:40.540 --> 00:54:46.860
the genomic scale where the numbering system starts from one to like, and you know, whatever

00:54:46.860 --> 00:54:50.860
the length of your chromosome is in terms of ATGCs and each chromosome has a different

00:54:50.860 --> 00:54:51.860
number.

00:54:51.860 --> 00:54:56.500
And if you have a certain alteration that is happening, say in chromosome seven at this

00:54:56.500 --> 00:55:00.780
particular position, then you have to translate that to the mRNA of that gene and then the

00:55:00.780 --> 00:55:01.780
protein of that gene.

00:55:01.780 --> 00:55:05.860
So it's a lot of math, a lot of strings involved in that process.

00:55:05.860 --> 00:55:11.580
And so essentially this HGVS Python package provides all of those functionality as a wrap.

00:55:11.580 --> 00:55:19.060
You can create your translation, you can essentially project the variant from the genomic to the,

00:55:19.060 --> 00:55:22.220
you know, the mRNA to a protein level or vice versa.

00:55:22.220 --> 00:55:24.300
You can validate things.

00:55:24.300 --> 00:55:30.380
So we ended up, I actually wrote a paper about this when we, you know, we did a validation

00:55:30.380 --> 00:55:33.020
of how well this particular package works.

00:55:33.020 --> 00:55:37.620
And so now, you know, in the lab that I'm currently in, we implement this thing for

00:55:37.620 --> 00:55:38.620
generating those nomenclatures.

00:55:38.620 --> 00:55:44.300
So what happens is when we put a report out for the, in the patient's chart and then our,

00:55:44.300 --> 00:55:49.660
you know, say our oncology, oncologist was treating the patient, they want to know, okay,

00:55:49.660 --> 00:55:52.780
what is, you know, what did you identify in this tumor genome?

00:55:52.780 --> 00:55:58.100
They will read that nomenclature saying, oh, okay, this particular change in this BF gene,

00:55:58.100 --> 00:55:59.100
this is significant.

00:55:59.100 --> 00:56:03.380
We know that there are therapies that are out there that we can use to treat this patient

00:56:03.380 --> 00:56:04.380
tumor.

00:56:04.380 --> 00:56:06.380
So that's what this nomenclature system is about.

00:56:06.380 --> 00:56:09.820
So it's a very complicated automated system.

00:56:09.820 --> 00:56:10.820
- Yeah.

00:56:10.820 --> 00:56:15.300
And it normalizes it if there's multiple ways to represent it and things like that.

00:56:15.300 --> 00:56:16.740
Very nice.

00:56:16.740 --> 00:56:18.860
All right.

00:56:18.860 --> 00:56:21.460
This one I'm familiar with, OpenPyXL.

00:56:21.460 --> 00:56:26.940
I guess you probably have a lot of data that either goes, comes from or goes, gets shared

00:56:26.940 --> 00:56:28.820
out into Excel, right?

00:56:28.820 --> 00:56:29.820
- Yes.

00:56:29.820 --> 00:56:35.500
So what we do is we sort of are right now in our lab, we're kind of in this sort of,

00:56:35.500 --> 00:56:43.860
you know, kind of an interim phase where we sometimes use Excel to look at some data.

00:56:43.860 --> 00:56:51.660
So traditionally speaking before, you know, typically any lab that goes from, you know,

00:56:51.660 --> 00:56:55.940
zero to the point where you have a web application that automates everything, the intermediate

00:56:55.940 --> 00:56:57.700
phase is using a lot of Excel.

00:56:57.700 --> 00:57:03.940
So it's very common in many labs to use Excel for a lot of different things, you know, for

00:57:03.940 --> 00:57:05.500
QC, for charts, for tracking.

00:57:05.500 --> 00:57:13.180
So we use this OpenPyXL for a few things.

00:57:13.180 --> 00:57:17.220
One of them is when we have a lot of, you know, the sequencing data that we have to

00:57:17.220 --> 00:57:23.380
summarize and then generate a QC to be able to present that, to essentially create an

00:57:23.380 --> 00:57:28.140
Excel document on the fly from the backend to provide that, you know, whatever data they

00:57:28.140 --> 00:57:33.540
want to look at in terms of statistics or, you know, list of variants or some form of,

00:57:33.540 --> 00:57:36.740
you know, calculation they want to do further, that's where we use this package.

00:57:36.740 --> 00:57:42.140
Typically we use it as part of our biofinance pipeline when we have to generate those things,

00:57:42.140 --> 00:57:44.540
but it's a very handy tool.

00:57:44.540 --> 00:57:47.700
We actually use something similar and I'm forgetting the name of the package that is

00:57:47.700 --> 00:57:55.940
used to generate a document, like we use some Word documents for creating reports, but we

00:57:55.940 --> 00:57:59.460
also use Python there to be able to summarize a lot of these data points and then create

00:57:59.460 --> 00:58:04.420
a Word document that, you know, it starts with a template of a Word document and then

00:58:04.420 --> 00:58:06.740
use Python to fill up all these, you know.

00:58:06.740 --> 00:58:07.740
Right.

00:58:07.740 --> 00:58:08.740
Here's where the graph goes.

00:58:08.740 --> 00:58:10.020
Here's where the summary goes.

00:58:10.020 --> 00:58:12.940
Here's where the detected, whatever it goes.

00:58:12.940 --> 00:58:13.940
Yeah.

00:58:13.940 --> 00:58:14.940
Right.

00:58:14.940 --> 00:58:15.940
Yeah.

00:58:15.940 --> 00:58:16.940
Cool.

00:58:16.940 --> 00:58:17.940
So, yeah, I think there's a lot of things that overlap.

00:58:17.940 --> 00:58:24.740
Are you familiar with this thing where scientists rename human genes to stop Excel from misreading

00:58:24.740 --> 00:58:25.740
them?

00:58:25.740 --> 00:58:26.740
Oh, yes.

00:58:26.740 --> 00:58:27.740
Yes, absolutely.

00:58:27.740 --> 00:58:28.740
Oh my gosh, this is crazy.

00:58:28.740 --> 00:58:29.740
Yes.

00:58:29.740 --> 00:58:30.740
Yes, it happens.

00:58:30.740 --> 00:58:39.860
When we import a lot of this data coming from somewhere, we'll see entries like September

00:58:39.860 --> 00:58:43.260
14th or March 19th.

00:58:43.260 --> 00:58:48.940
Yeah, this is a big problem going in and out of Excel.

00:58:48.940 --> 00:58:53.700
And so as much as you can do in Python or any proper programming language rather than

00:58:53.700 --> 00:59:00.860
using Excel, but there was one that was M-A-R-C-H-1 or March 1.

00:59:00.860 --> 00:59:01.860
Yes.

00:59:01.860 --> 00:59:02.860
Or S-E-P-T-1.

00:59:02.860 --> 00:59:03.860
It's very funny.

00:59:03.860 --> 00:59:11.260
Some of the gene names are funny, but then Excel, you know, gets it to the next level

00:59:11.260 --> 00:59:13.260
when it changes the names.

00:59:13.260 --> 00:59:14.260
What a day, dude.

00:59:14.260 --> 00:59:15.260
This doesn't make any sense.

00:59:15.260 --> 00:59:16.260
Yeah.

00:59:16.260 --> 00:59:17.260
Yeah, it doesn't make any sense.

00:59:17.260 --> 00:59:18.260
Yeah.

00:59:18.260 --> 00:59:19.260
All right.

00:59:19.260 --> 00:59:20.260
On to the next one.

00:59:20.260 --> 00:59:21.260
Hera.

00:59:21.260 --> 00:59:22.260
Yes.

00:59:22.260 --> 00:59:23.260
Hera, this is very interesting.

00:59:23.260 --> 00:59:32.620
So this is where I think, you know, where in our instance, we are going away from standard

00:59:32.620 --> 00:59:37.380
web applications, standard Biontronics pipeline to really touching DevOps using Python.

00:59:37.380 --> 00:59:43.460
And so one of the things that typically we get to the point when we scale up our Biontronics

00:59:43.460 --> 00:59:48.020
pipeline, where we have multiple samples and multiple runs and everything needs to be orchestrated

00:59:48.020 --> 00:59:52.580
in a way where you have, you know, while you're running your pipeline, you have a lot of visibility

00:59:52.580 --> 00:59:54.620
into how it works.

00:59:54.620 --> 01:00:01.180
And so this is one of our projects we are working on to move our current Biontronics

01:00:01.180 --> 01:00:06.420
pipeline the way it works, you know, kind of on a single server to be able to use the

01:00:06.420 --> 01:00:11.900
Kubernetes cluster to actually deploy the long running pipelines onto that.

01:00:11.900 --> 01:00:16.980
And so there are many options, you know, there are more standard sort of, you know, brittle

01:00:16.980 --> 01:00:24.940
based kind of, you know, protocols that you can use to run on your cloud or HPC environments.

01:00:24.940 --> 01:00:30.940
There is a very popular tool called Nextflow that is used to be able to, you know, kind

01:00:30.940 --> 01:00:33.140
of create your data analysis pipeline.

01:00:33.140 --> 01:00:38.100
Nextflow, you can sort of define that and then use any backend to deploy it.

01:00:38.100 --> 01:00:42.260
One of the things that we kind of, when I was exploring the space, one of the things

01:00:42.260 --> 01:00:50.100
I came across was, you know, the whole sort of ecosystem that Argo maintains with, you

01:00:50.100 --> 01:00:53.260
know, Argo workflow and Argo CI/CD and all those things.

01:00:53.260 --> 01:00:58.420
So workflow was interesting because Argo provides that way where you can sort of, you know,

01:00:58.420 --> 01:01:02.540
write your pipelines in a YAML format and then have it, you know, deployed on the Kubernetes

01:01:02.540 --> 01:01:03.540
cluster.

01:01:03.540 --> 01:01:06.380
It really is very native to the Kubernetes cluster.

01:01:06.380 --> 01:01:14.980
It sounds a little bit like Ansible, but for specifically for bio type of projects, right?

01:01:14.980 --> 01:01:15.980
Yeah.

01:01:15.980 --> 01:01:20.340
So Argo, so interesting thing is Argo, when, you know, when this Argo workflows was set

01:01:20.340 --> 01:01:24.300
up really for a lot of CI/CD automations in mind.

01:01:24.300 --> 01:01:29.300
So it is, yes, you can run data pipelines in general, but never, it was never, at least

01:01:29.300 --> 01:01:34.500
in its description, it never describes use case of bioinformatics or, you know, biology

01:01:34.500 --> 01:01:35.500
pipeline analysis.

01:01:35.500 --> 01:01:40.580
And similarly, you know, it was like, okay, it's a generic tool.

01:01:40.580 --> 01:01:42.440
You can use it for whatever you want.

01:01:42.440 --> 01:01:48.500
So I tried it out with using, you know, like a YAML file and it was a simple four-step

01:01:48.500 --> 01:01:49.500
pipeline.

01:01:49.500 --> 01:01:50.500
It was wonderful.

01:01:50.500 --> 01:01:51.500
It was magical.

01:01:51.500 --> 01:01:57.740
And the good thing was with Argo, like the Argo workflow, when you install that on your

01:01:57.740 --> 01:02:03.200
Kubernetes cluster, it comes with a native web interface.

01:02:03.200 --> 01:02:10.140
So it's, you know, I'm sure if you've heard about the workflow option with Airflow.

01:02:10.140 --> 01:02:14.780
So Airflow is a package that also, you know, there's a nice Python SDK for that, where

01:02:14.780 --> 01:02:16.980
you have, you know, you deploy it on a Kubernetes cluster.

01:02:16.980 --> 01:02:21.620
You have all these amazing visualizations to show what step you're on, or if there's

01:02:21.620 --> 01:02:23.580
some error there, it'll do that.

01:02:23.580 --> 01:02:24.900
Argo does the same thing.

01:02:24.900 --> 01:02:30.260
So it has, obviously, the built-in capability to interact with it as an API, but then also

01:02:30.260 --> 01:02:34.300
there's a web interface that it'll deploy and it can have visibility into every step

01:02:34.300 --> 01:02:35.300
of the process.

01:02:35.300 --> 01:02:37.380
It can summarize, it can see the entire tree.

01:02:37.380 --> 01:02:40.340
So that was very interesting for us because we could get all that thing done in a single

01:02:40.340 --> 01:02:42.820
thing, in a single go.

01:02:42.820 --> 01:02:47.900
But then our challenge was, well, our desire was that if you could integrate that with

01:02:47.900 --> 01:02:52.500
our LIMP system that we were working on using FastAPI, so that it was, hey, if there's any

01:02:52.500 --> 01:02:53.500
Python SDK.

01:02:53.500 --> 01:02:55.380
And so that's where Hedda comes in.

01:02:55.380 --> 01:03:01.540
So Hedda essentially is a SDK, a wrapper that's essentially talking to Argo, but you can define

01:03:01.540 --> 01:03:06.980
your pipeline steps as, you know, DAGs in Python.

01:03:06.980 --> 01:03:12.420
And so that makes the process super simple, where you're now natively, essentially, we

01:03:12.420 --> 01:03:16.540
can integrate that as a backend to our web application.

01:03:16.540 --> 01:03:21.060
And so then it's almost like, you know, it's Python again, from start to finish, you're

01:03:21.060 --> 01:03:22.060
not getting out of that.

01:03:22.060 --> 01:03:25.780
And it's, again, it's a very well-maintained application.

01:03:25.780 --> 01:03:30.260
So we are currently doing a validation to be able to make sure that, or demonstrate

01:03:30.260 --> 01:03:36.980
that, you know, it's equally performant when we compare to a more sort of native shell-based

01:03:36.980 --> 01:03:39.980
execution on the pipeline.

01:03:39.980 --> 01:03:40.980
Okay.

01:03:40.980 --> 01:03:41.980
Yeah, this is new to me.

01:03:41.980 --> 01:03:44.540
Of course, I know Airflow, but not Hedda.

01:03:44.540 --> 01:03:45.540
Cool.

01:03:45.540 --> 01:03:46.540
All right.

01:03:46.540 --> 01:03:50.100
Pi in sim, did I grab the right one here?

01:03:50.100 --> 01:03:54.380
No, I think it's similar.

01:03:54.380 --> 01:04:00.500
Let me see if I can send you the link.

01:04:00.500 --> 01:04:08.300
Yeah, throw it in the private chat here and I'll pull it up.

01:04:08.300 --> 01:04:09.300
Yeah.

01:04:09.300 --> 01:04:10.300
Okay.

01:04:10.300 --> 01:04:12.300
There we go.

01:04:12.300 --> 01:04:13.300
In sim.

01:04:13.300 --> 01:04:14.300
Yeah.

01:04:14.300 --> 01:04:15.300
Okay.

01:04:15.300 --> 01:04:16.300
Got it.

01:04:16.300 --> 01:04:17.300
Yeah.

01:04:17.300 --> 01:04:28.180
So this is a very interesting space in next generation sequencing assay or for high throughput

01:04:28.180 --> 01:04:29.180
sequencing assays.

01:04:29.180 --> 01:04:33.180
So what happens is, as I mentioned, that one of the things that is required for a clinical

01:04:33.180 --> 01:04:38.180
lab is to be able to perform a validation on multiple samples of tumors that have certain

01:04:38.180 --> 01:04:39.180
mutations.

01:04:39.180 --> 01:04:46.020
And then you can demonstrate that, yes, the assay works because you have tested 100 samples

01:04:46.020 --> 01:04:50.340
that have 300 different mutations or genetic alterations.

01:04:50.340 --> 01:04:54.940
And then you can demonstrate that, yes, your pipeline or your assay was able to pick it

01:04:54.940 --> 01:04:55.940
up.

01:04:55.940 --> 01:05:01.580
So you can say that your assay is X percentage sensitive, X percentage specific, and your

01:05:01.580 --> 01:05:03.340
recall rate and things like that.

01:05:03.340 --> 01:05:10.620
So what happens is when you're trying to get those samples that have these very difficult

01:05:10.620 --> 01:05:16.620
or challenging variants to detect because they're just complex in how they occur biologically

01:05:16.620 --> 01:05:18.940
in the cell, it's very difficult.

01:05:18.940 --> 01:05:20.700
Some of these are very rare.

01:05:20.700 --> 01:05:23.380
They may be only two samples in the entire world.

01:05:23.380 --> 01:05:28.700
Or it's just not possible practically to get those samples unless you wait for 10 years

01:05:28.700 --> 01:05:29.900
to validate that.

01:05:29.900 --> 01:05:36.900
So the idea is that if it is possible to be able to use algorithms which can manipulate

01:05:36.900 --> 01:05:38.460
the existing sequence.

01:05:38.460 --> 01:05:44.300
So for example, we have a sequence data from an existing real tumor sample.

01:05:44.300 --> 01:05:49.540
But we can manipulate that in a way where we introduce these mutations in silicope.

01:05:49.540 --> 01:05:55.820
So we can introduce SNBs or insertion deletion mutations and then use that same file to then

01:05:55.820 --> 01:05:58.980
feed into our pipeline, bioinformatics pipeline and say, okay, run through the entire data

01:05:58.980 --> 01:05:59.980
pipeline.

01:05:59.980 --> 01:06:04.060
And then let's see if we are able to identify those variants that we inserted.

01:06:04.060 --> 01:06:08.080
And so that's where the silicope mutagenesis comes in.

01:06:08.080 --> 01:06:09.080
It's a very hot topic.

01:06:09.080 --> 01:06:16.580
It's a very relevant topic of interest to really fill this large gap in terms of availability

01:06:16.580 --> 01:06:22.940
of rare variants and their samples and how we can really improve some of these rare but

01:06:22.940 --> 01:06:27.180
very clinically significant edge cases where we don't want to miss those variants and actually

01:06:27.180 --> 01:06:29.220
see those in real tumor samples.

01:06:29.220 --> 01:06:35.540
And so this is a Python package that was developed at the University of Chicago as part of their

01:06:35.540 --> 01:06:36.780
clinical lab.

01:06:36.780 --> 01:06:43.940
And so what really it does is it will take in a list of different mutations.

01:06:43.940 --> 01:06:48.620
For example, in this plot, I think they give examples of insertion deletion, insertions

01:06:48.620 --> 01:06:51.620
where you have extra sequence or deletion where you have certain sequence which are

01:06:51.620 --> 01:06:57.300
missing or SNVs or single nucleotide variants where you have one nucleotide that got switched

01:06:57.300 --> 01:06:58.300
with another one.

01:06:58.300 --> 01:07:04.540
And so these are typically that we practically see in like real samples or real tumor samples,

01:07:04.540 --> 01:07:09.580
but this is a way to mimic that in a sample that does not have it.

01:07:09.580 --> 01:07:15.260
And so this Python package is able to take that list from you say, okay, I have a list

01:07:15.260 --> 01:07:20.900
of these 20 important mutations that I know from the public databases have been reported,

01:07:20.900 --> 01:07:27.140
but I want them to be inserted into my dataset that was created from say a set of three or

01:07:27.140 --> 01:07:32.700
four real tumors and then use that to challenge the pipeline to say that, hey, can you still

01:07:32.700 --> 01:07:33.700
pick it up?

01:07:33.700 --> 01:07:34.700
And so that's what this does.

01:07:34.700 --> 01:07:35.700
I see.

01:07:35.700 --> 01:07:40.580
Simulate these rare changes and then test or exercise your setup.

01:07:40.580 --> 01:07:41.580
Cool.

01:07:41.580 --> 01:07:42.580
Right.

01:07:42.580 --> 01:07:44.900
We've got a few more to cover, but I think we're getting a little bit short on time.

01:07:44.900 --> 01:07:50.380
So let me just close this out with a final question for you, because I know this is the

01:07:50.380 --> 01:07:53.240
topic du jour.

01:07:53.240 --> 01:07:57.620
What does AI and LLMs look like for you guys?

01:07:57.620 --> 01:07:59.660
Does it matter?

01:07:59.660 --> 01:08:00.660
Is it really powerful?

01:08:00.660 --> 01:08:03.780
Is it super important?

01:08:03.780 --> 01:08:05.500
Genetics is kind of text data in a sense.

01:08:05.500 --> 01:08:09.020
And so yes, sort of in the space of how it could apply.

01:08:09.020 --> 01:08:10.020
Right.

01:08:10.020 --> 01:08:16.620
It is a text data and it's a lot of, you know, there's a, when you talk about like

01:08:16.620 --> 01:08:20.700
a search space, a lot of the search space is very text based.

01:08:20.700 --> 01:08:24.540
You know, there is some numerical base, but there's a lot of text based search as well.

01:08:24.540 --> 01:08:30.060
And I think across the entire spectrum from where we start with very raw sequencing data

01:08:30.060 --> 01:08:37.020
to the point that we are trying to, you know, ask the question that, okay, I found this

01:08:37.020 --> 01:08:39.860
rare or novel mutation in this particular gene.

01:08:39.860 --> 01:08:40.860
What does it mean?

01:08:40.860 --> 01:08:43.060
You know, what human has been described?

01:08:43.060 --> 01:08:46.100
What disease does it relate to?

01:08:46.100 --> 01:08:50.740
One of the things that we do as molecular pathologists, and this is sort of where a

01:08:50.740 --> 01:08:54.460
lot of the medical work comes in, is where we really go through a lot of the medical

01:08:54.460 --> 01:08:59.660
literature, what we have learned before, new publications, papers out there that, you know,

01:08:59.660 --> 01:09:03.580
that have a lot of data in terms of, you know, studies that I've done on this particular

01:09:03.580 --> 01:09:07.580
gene and they've described like, okay, these alterations actually activate the gene or

01:09:07.580 --> 01:09:11.900
is bad for the tumor or, you know, makes it treatment resistant.

01:09:11.900 --> 01:09:14.980
So you can see the natural, there's a lot of text as it happens.

01:09:14.980 --> 01:09:19.300
And so in that space, we are seeing in the, I would say in the past, you know, three to

01:09:19.300 --> 01:09:25.140
four years, there's been a lot of application of AI tools that have come out, you know,

01:09:25.140 --> 01:09:28.860
particularly in the space of variant calling, where we have this genomic sequence data and

01:09:28.860 --> 01:09:31.620
we're trying to identify variants.

01:09:31.620 --> 01:09:36.980
You know, one of the examples that's been talked about a lot is the deep variant caller.

01:09:36.980 --> 01:09:41.780
It's called deep variant from the team at Google who developed that.

01:09:41.780 --> 01:09:45.340
That uses a lot of the AI techniques to be able to pick those things up.

01:09:45.340 --> 01:09:51.140
There are some genomic databases that we use for in silico prediction.

01:09:51.140 --> 01:09:53.740
For example, if you have a variant, we have no idea about it.

01:09:53.740 --> 01:10:01.380
It uses, there's a database called dbscsnv that uses random forest techniques.

01:10:01.380 --> 01:10:06.340
And I think it uses another algorithm to predict if a certain site where there is a mutation

01:10:06.340 --> 01:10:11.180
can enhance abnormal mechanism called splicing versus not.

01:10:11.180 --> 01:10:16.260
Similarly, there's a lot of tools that are coming in and the LLMs I think are, I would

01:10:16.260 --> 01:10:19.420
say not mainstream, but I think there's a lot of interesting research that is coming

01:10:19.420 --> 01:10:25.700
around there, where people are trying to use LLMs for doing these more broader text search

01:10:25.700 --> 01:10:30.740
saying that, hey, you know, I have these, you know, I don't know, thousand articles,

01:10:30.740 --> 01:10:37.940
and I want to find these particular combination of words that, you know, it's a combination

01:10:37.940 --> 01:10:42.220
of a disease and a mutation and what do I get back out of that?

01:10:42.220 --> 01:10:48.900
I personally tried, you know, ChatGPT with different, you know, like phrases and questions

01:10:48.900 --> 01:10:49.900
about it.

01:10:49.900 --> 01:10:56.100
What I've seen so far is, and this is purely my personal experience, I think a lot of it

01:10:56.100 --> 01:11:02.140
reads very real, but when you start to look into the references as to what it references,

01:11:02.140 --> 01:11:03.140
then you quickly figure out.

01:11:03.140 --> 01:11:04.140
This is not the real deal.

01:11:04.140 --> 01:11:14.140
And so I think, I think it's, you know, I'm not a very pessimistic person.

01:11:14.140 --> 01:11:15.700
I'm saying, oh, no, this is all garbage.

01:11:15.700 --> 01:11:17.980
But I think there is opportunity there.

01:11:17.980 --> 01:11:20.380
It's just how do you train it?

01:11:20.380 --> 01:11:25.020
Maybe there's a space or an opportunity and it probably already has been, people are pursuing

01:11:25.020 --> 01:11:31.500
this as training a smaller model, but really deeply in genetics or is trying, not trying

01:11:31.500 --> 01:11:34.020
to use a model that tries to understand everything.

01:11:34.020 --> 01:11:35.020
Right, right.

01:11:35.020 --> 01:11:40.020
Yeah, it's more, yeah, more in the medical literature or the genomic literature to be

01:11:40.020 --> 01:11:41.660
able to like, training is an answer.

01:11:41.660 --> 01:11:42.660
Yes.

01:11:42.660 --> 01:11:44.460
So I think there's active work going on there.

01:11:44.460 --> 01:11:49.020
But it's, yeah, it's, I think it's making, you know, a lot of, a lot of interesting research,

01:11:49.020 --> 01:11:53.100
a lot of potential impact on how, you know, we do things.

01:11:53.100 --> 01:11:57.260
And obviously the tool sets that we currently use, we might expect in the next 10 years

01:11:57.260 --> 01:11:58.260
to change.

01:11:58.260 --> 01:11:59.820
Yeah, for sure.

01:11:59.820 --> 01:12:01.180
All right.

01:12:01.180 --> 01:12:02.180
Final thought here.

01:12:02.180 --> 01:12:04.180
People are listening.

01:12:04.180 --> 01:12:08.380
They're maybe doing similar work to you.

01:12:08.380 --> 01:12:09.380
How do they get started?

01:12:09.380 --> 01:12:11.580
What would you tell them?

01:12:11.580 --> 01:12:13.580
Get going with Python and some of these packages?

01:12:13.580 --> 01:12:19.100
Yeah, I mean, I would, you know, my reflecting on my own experience sort of, you know, in

01:12:19.100 --> 01:12:22.660
a very winded way that I ended up here.

01:12:22.660 --> 01:12:29.900
I think, you know, Python is, I feel the program in general, and I think Python particularly

01:12:29.900 --> 01:12:36.220
as a programming language is a very low, you know, sort of, you know, entry point in terms

01:12:36.220 --> 01:12:40.100
of being able to really quickly get things done, like learn it easily and get things

01:12:40.100 --> 01:12:41.100
done.

01:12:41.100 --> 01:12:48.020
I think it should be, to me, anybody, anybody who's trying to pursue something in biology

01:12:48.020 --> 01:12:53.420
or competition biology or bioinformatics, I think this is the first thing it's something

01:12:53.420 --> 01:12:54.420
easy to do.

01:12:54.420 --> 01:12:59.020
To be, you know, I would say relatively easy to do to be able to get from that.

01:12:59.020 --> 01:13:05.980
Anybody with a desire to learn this has analytical thinking.

01:13:05.980 --> 01:13:12.700
I mean, I think investing into Python is probably the best bet because you can pretty much do

01:13:12.700 --> 01:13:13.700
anything you want.

01:13:14.700 --> 01:13:18.660
That's what I tell, you know, when I tell train people in my lab or I talk to other

01:13:18.660 --> 01:13:22.700
students is that if you want to spend your time, you have very little time because you're

01:13:22.700 --> 01:13:24.980
busy, you know, with your other things.

01:13:24.980 --> 01:13:28.860
I think the one thing that can get some of the job done and be still aligned with what

01:13:28.860 --> 01:13:31.580
you're doing is Python.

01:13:31.580 --> 01:13:37.180
And after that, I think it's, you know, it's a lot of self driven learning where, you know,

01:13:37.180 --> 01:13:39.260
you kind of, you know, looking into things.

01:13:39.260 --> 01:13:43.460
But the good thing is, I think the Python community is wonderful.

01:13:43.460 --> 01:13:46.500
It's almost like I sit down and I think about, oh, I have to solve this problem.

01:13:46.500 --> 01:13:50.740
Probably there are 50 other people who are thinking about that and maybe two people have

01:13:50.740 --> 01:13:51.740
already worked on it.

01:13:51.740 --> 01:13:52.740
So it's right.

01:13:52.740 --> 01:13:56.580
They've already published it to PyPI and you're good to go.

01:13:56.580 --> 01:13:57.580
Absolutely.

01:13:57.580 --> 01:13:58.580
I totally agree with that.

01:13:58.580 --> 01:14:05.460
And, you know, people should take the couple of weeks, get good at it and it'll amplify.

01:14:05.460 --> 01:14:06.460
It'll save you time.

01:14:06.460 --> 01:14:07.460
Definitely in the long run.

01:14:07.460 --> 01:14:08.460
Oh, absolutely.

01:14:08.460 --> 01:14:09.460
Yes.

01:14:09.460 --> 01:14:15.700
The only thing that I, that I, the only thing I would say like an added thing is if somebody

01:14:15.700 --> 01:14:22.460
is learning Python and then they do have an intention, you know, to take it to the point

01:14:22.460 --> 01:14:27.500
where they will be involved in more serious, like, you know, application development or

01:14:27.500 --> 01:14:31.100
maintaining an open source package or, you know, however they contribute to that.

01:14:31.100 --> 01:14:37.660
I think learning a little bit more like learning Python in its real sense in terms of how to

01:14:37.660 --> 01:14:38.660
do it right.

01:14:38.660 --> 01:14:42.860
I think there are five ways of doing something correctly, but I think there's one way that

01:14:42.860 --> 01:14:47.940
is consistent so that it's again, you know, easily shared, it's easily maintainable.

01:14:47.940 --> 01:14:48.940
Others can easily understand.

01:14:48.940 --> 01:14:51.220
I think that would be my second advice.

01:14:51.220 --> 01:14:55.260
It is, it takes a little bit of time, but I think it's well worth the effort to spend

01:14:55.260 --> 01:14:59.580
the time writing, you know, idiotic Python code.

01:14:59.580 --> 01:15:02.780
So it's, it's portable.

01:15:02.780 --> 01:15:03.780
Absolutely.

01:15:03.780 --> 01:15:04.780
All right.

01:15:04.780 --> 01:15:06.620
So, Mac, thank you for being on the show.

01:15:06.620 --> 01:15:09.980
It's been great to get this look inside of what you all are doing with Python.

01:15:09.980 --> 01:15:10.980
Yeah.

01:15:10.980 --> 01:15:11.980
Thank you for having me on the show.

01:15:11.980 --> 01:15:12.980
I appreciate that.

01:15:12.980 --> 01:15:13.980
Yep.

01:15:13.980 --> 01:15:14.980
Bye.

