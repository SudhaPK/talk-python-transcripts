00:00:00 At some point, you've probably migrated an app from one framework or major runtime version to another, for example, Django to flask, python two to three, or even Angular to view.js. This can be a big challenge. If you had hundreds of active devs and millions of lines of code, it's a huge challenge. We have been Barito from Yelp, here to recount their story of moving 3.8 million lines of code from Python two to three. But this is not just a two to three story. It has many lessons on how to migrate code in many situations. There are plenty gems to take from experience. This is talk Python me Episode 401, recorded January 18 2023.

00:00:56 Welcome to Talk typing a weekly podcast on Python. This is your host, Michael Kennedy. Follow me on Mastodon where I'm at M Kennedy and follow the podcast using at talk Python, both on Boston on.org. Be careful within preceding accounts on other instances, there are many keep up with the show and listen to over seven years of past episodes at talk python.fm We've started streaming most of our episodes live on YouTube, subscribe to our YouTube channel over at talk python.fm/youtube to get notified about upcoming shows and be part of that episode. This episode is brought to you by Cox, automotive, join their team and use your technical skills to transform the way the world buys, sells and owns cars finding an exciting position that's right for you at talk python.fm/cox. And it's also brought to you by user interviews, earn extra income for sharing your software development opinion at user interviews. Head over to talk python.fm/user interviews to participate today. Ben, welcome to talk Python to me.

00:01:58 Thank you, thank you so much for having me, Michael,

00:02:00 we're going to talk a little bit of legacy code, a little bit of very, very large code bases, and how you might not have to permanently live in the past, which I think would be really welcomed to a lot of people. I just talked a little bit about this for a hit record by even though your topic is specifically how the story have moved from Python two to three. And this like making your whole code base modern, I do think that this idea of how do I move from one code base to another code base is super relevant to lots of folks who might not be going from Python two to three, but maybe from flask to fast API or vice versa, or those types of things. So I think this, the techniques that you're going to talk about here are more broadly applicable than just a two to three migration. And it's really cool, how you, you all migrated 3.8 million lines of code without interrupting development. That's kind of nuts.

00:02:50 Yeah, it's, I did it and it still seems ridiculous you lived in

00:02:53 it seems like a dream. Amazing. Before we get to all that though, let's start with your story. How'd you get into programming and Python took a

00:02:59 job at Yelp. Yelp was a Python shop. Before that. I had a couple internships and I went to Georgia Tech and I mostly to Java. So it was sort of a new experience. For me, I you know, Python was is one of those, like beginner languages that everyone loves to throw around. So, so I had done, you know, dabbled in a little bit, but, but I first started really getting like, deep into the language when I started it at Yelp. And I've definitely made it, it started become like, I've become sort of a local expert on it. So I've been able to build up a lot of knowledge about like, you know, a lot of weird edge cases, and you know, stuff like that. So

00:03:35 you may be familiar with it. There's a t shirt, that's kind of a joke. meme. It says I learned Python. It was a great weekend. Yeah. And yet, I've been doing Python for many years, and I'm still learning new stuff. Even today, I learned some interesting new Python things. So which is it? Do you learn in a day? Or is it like, this deep journey?

00:03:54 I think most programming languages have some amount of, you know, width and depth, I think, you know, Python definitely has the advantage of being, you know, a relatively straightforward language. One of the nice things obviously, is that, like, instead of using a lot of weird keywords, it has, like, you know, words like, you know, instead of being like, oh, like, or a pipe? Yeah, or Yeah, or instead of double pipe and stuff like that, like, those are the things that I think, I think definitely help people personally, you know, me coming into it and what that wasn't like as big of a deal for me, because like, I was already familiar with all that stuff. But like

00:04:27 you were, you're coming from a very simple, heavy world of Java, which is not as cymbal heavy as C++, but it's got a lot of abstractions in what it builds for sure.

00:04:36 Yeah. I will say like, I think there are certain things that Python does. I will say python is not is not like a perfect language by any stretch of the imagination. But I will say one thing about Python that I think is really cool is did sort of before many other languages, finish to integrate a lot of like functional paradigms, like list comprehensions or comprehensions. In general, are I think one of those features where it's just like, this doesn't exist in a lot of other sort of more popular languages, and they are really, really fluent and powerful in a way that like, if you kind of miss when you don't have it, right, and so like, I think that's something that's really cool about Python, but Python itself, you know, being being a language with the legacy that has has, you know, I mean, we're going to be talking about a two to three differences, which have their own nuances to them, but like, it's always going to have some weirdnesses to it. And some of those things are like, just like, Oh, someone made a decision, you know, 30 years ago, that like, still kind of reverberates today. And, and so that means that like, it has this depth to it, you know, you have to really learn the depth in order to fully understand all of the problems that exist, like dealing with not necessarily problems with the language, but like, you know, when you're building software, you run into problems. So you have to solve right. And so that's like the main I think that's, that's true of all languages to an extent, especially, you know, popular ones and older ones. But yeah, I do think that Python, more than a lot of languages really is able to straddle the line of like, being like, oh, it's approachable. But also, you can do a lot of, you know, really interesting and powerful stuff with it. Yeah, you

00:06:02 compare that with like Java, Java, you've got to understand functions, you've got to understand classes, possibly namespaces. Like, they just write the first line of code, whereas Python you can work with, therefore, if you know that this is really clumsy to repeat this, maybe I'll learn what a function is. And then I can start using that. But you don't know what a class is. You don't care about it. You kind of like slowly layer on the stuff as you need it, rather than you've got to jump in and go with it all at once. Yeah, for sure. Yeah. Dressing. So you're still at Yelp? Yeah.

00:06:34 And I'm in our, in a conference room in our San Francisco office right now.

00:06:38 Excellent. And what do you do in there?

00:06:40 So I work on a team that's called core services, our team is responsible for a lot of infrastructure, mostly Python focused, though not exclusively, we do a lot of our sort of like internal Python infrastructure. So you know, we'll we'll be responsible for making sure that we can upgrade to new Python versions, we've got We on our internal pipe guy, we recently this is a cool thing that has happened since my talk. So I didn't mention it is we recently built a system to automatically import certain packages from public pi pi. And that has saved us some headaches. And then we own some other stuff. Like, you know, we've dealt a lot with sort of this the general service contract at Yelp. So like being like, Okay, what, what does it mean to be a service? How do you how do you be a good citizen there? And a lot of other things like testing tools, a lot of like, sort of, like, oh, I need to test against multiple services, we have a testing tool that like, automates a lot of the steps to like, sort of get those all connected together. So you can test against that.

00:07:42 Yeah, that sounds like a really fun task, you're doing their internal, we're gonna dive into code and stuff, all this whole migration, but you know, kind of sidebar, like you said, you have this internal private peipsi server, what's the details around that? Like how, obviously, you're whitelisting things that can be brought inside? So we're gonna put those onto our server, and you can think requests, and you can choose when to let the new one in, and so on. But what's the software? And how do you put that together?

00:08:12 A number of years ago, now, we switched to a piece of software that I don't think is used pretty much anywhere else, which was built by one of my teammates, who named Chris keel. So Chris keel, we built essentially a pie pie implementation called dumb pie pie. It's called, it's called dumb pipe VI. Because unlike some other pie pie servers, the way that it works is you just sort of give it a list of distributions, and then it just generates all of the HTML pages. So instead of instead of being like, Oh, I'm a server. And I'm like, you know, going to handle this request and blah, blah, blah, and like, run some code. It's literally like, okay, here are the HTML pages. And I

00:08:52 see it's like a, like a static site generator for IPI back end.

00:08:57 Yeah, yeah. And we've been using that for a really long time, and maybe like, four or five years now. And it's, you know, it served us pretty well. It's really nice, in my opinion, because it's the only service that my team actually owns. So and it never paid shows us. So that's great. I love that it never reaches us.

00:09:15 It can't go down. Yeah. Not really. It can't it wouldn't

00:09:19 be good that have gone if it goes down. But also it doesn't. That's the great part of it. Just it just doesn't. So Christmas. Christmas software works

00:09:25 great. Yeah. It's a really cool idea. And so you tell it certain versions, or or do you just limited to the libraries and let it pick the latest versions of whatever's on real pipe? Yeah.

00:09:36 So the way that we do it is we have a whole system which like imports, packages, we actually rebuild all of our wheels. It's kind of for kind of hard to explain reasons. So what we'll do is we'll like be someone will say, hey, I want this version of this package. Or maybe they'll just say, hey, I want this package and then we'll just pull down the newest one at the time and we'll do some like security betting on it. So we have some, like automated security stuff. And basically just make sure that it's like, not malicious. And then we build the wheels. And then we upload those to the s3 bucket that like backs our PI. Right? So we just do that, in terms of like, how we decided it basically just sort of like we, you know, make sure, yeah, we do the security check, we do. Like, there's a few other things like we make sure we have all the dependencies we make sure we have, that it has like a license that we're okay with, with using internally. And so all of those things are checked. And then we have, as I mentioned, we have this sort of like, automated import system. So like, certain packages will just will try to download them, they might fail, you know, one of those checks, and then we won't upload it, but like, you know, so we'll just like import it, we'll try to import it. And, and so certain packages will try to get the newest one, some packages, you know, however, we haven't set that up for one reason or another, some packages, there's certain packages that are just, like difficult to build. And so we avoid importing them.

00:10:58 Right? You just we got this one working, it's fine.

00:11:01 Yes, yes. And so like, some are difficult to build. Some are just like, oh, this is a package we've never used before. So we just like don't use it. Yeah. So are we don't have it.

00:11:11 You talked about how many dependencies your projects have and stuff, and then that'll be fun. But let's maybe take a step back and just talk about, you know, Python at Yelp, you've this main project that you have, it was running on Python two, it's kind of obvious, but some of the reasons are obvious. Some are not like, why did you care? What version of Python? That's,

00:11:31 that's good question. I mean, I think the main reason was just sort of like we saw the writing on the wall, and the running on the wall was the end of life for Python two, right. And I think everyone else, we knew that other people were gonna follow that, right. There was I remember, in 2019, when I was looking into this, there was a thing I think, was called, like, the Python pledge or something like that, where basically, like packages would like open source packages would say, like, Hey, we're gonna drop python three, you know, after end of life at some, like, you know, either the day of or, or a few months later, or something like that. And so we were sort of looking at that and being like, well, we use some of those packages, you know, and eventually, we might want to upgrade them.

00:12:09 Yeah, you're about to get frozen in time around 20, mid 2020 20. So you're, you maybe don't want that.

00:12:16 By the time that I did my, my talk. I remember, I think it was early 2021 or something, you know, Pip had dropped support for Python two. So that was like one of those things where it was just sort of like, yeah, there's not, there's not a realistic ecosystem in which you are able to use like, open source and upgrade your stuff, you know, for security patches, or whatever, you know, I want this new feature. Oh, sorry, that's python three only, you know, kind of thing. So that was like, the main motivation, right. And then I think some secondary stuff was just sort of like, as you build, you know, as time marches on, and like, people stop being familiar with like Python two, and it has some quirks, you know, python three, you definitely have the problem of like, okay, now you have to like, if you're hiring people, and they're working on Python two, you have to train them up on those quirks in a way that like, you wouldn't necessarily have to do if you're using a modern language that other places are using. And so those are the I think, the main motivations. Personally, I think I had like a small motivation myself, which was just sort of like, I hate seeing things like be left behind like this. Yeah, sure. Okay. Very emotional thing. But yeah, yeah, that's part of the reason I push for it. Well,

00:13:21 there's the training thing. Yeah. There's obviously the just the infrastructure Stopping, stopping the updates, but there's the training side of helping people who are new come, but there's also the, how do you hire the very best engineers, it's really hard to get an amazing Python engineer to come and say, You're gonna do amazing work from 2008. You're gonna love it, you know what I mean? Right? Like, if they're working on some new package that they're inspired about, instead of trying to bring that in and like, help make that better, and also boost what you're doing. It's like, well, we can't use that. Because that you only draw on python three level, of course, I created this, you know, two years ago, why wouldn't it be python three only? And there's a lot of knock on effects like that, right? Yeah. Did you see the performance stuff from 211, or even from two attack 311 or even 310? Where we're like, you know, there might actually be fewer servers, as well, if we do this, that's definitely

00:14:15 something that we are, you know, we want to do that that specific issue is something that we're sort of we're trying to move towards being able to use the those versions of Python right now. It's always a process just because of various, you know, internal names, but it's definitely something that has been that has been talked about as we're like, yeah, if we could use new versions of Python, maybe things will be faster or things will be more efficient. Try not to spend too much money is definitely a thing that we we think about, so that's definitely exciting.

00:14:43 Yeah. When I did the episode on 311, we talked a lot about the performance there. And it's, it's impressive. It's, you know, 4050 60%, and I won't steal your thunder. I know at the end, you've got some nice performance boost that you got even from the changes that you made, but there was some Really the audience have pointed out like, not only is this faster, which is nice for us, right? It's nice that we have to pay less for servers or it's nice that our code runs a little bit faster. But it's also good for the planet. Right? If we just all start using newer, faster foundations, then necessarily we just use less energy to do the same thing that we're already doing, right?

00:15:19 Yeah, that's definitely. I like that.

00:15:23 This portion of talk Python, Emmy is brought to you by Cox automotive, with brands like Kelley Blue Book, auto trader, dealer.com, and more. Cox, automotive flips the script on how we buy, sell, own and use our cars. And now the team at Cox Automotive is looking for software engineers, data scientists, Scrum Masters and other tech experts to help create meaningful change in the industry. Do you want to be part of a collaborative workplace that values your time and work life balance? Consider joining Cox automotive visit talk python.fm/cox today, thank you to Cox automotive for sponsoring the show. Let's talk about Python at Yelp. So you've you've got this repo this this big project called Yelp main. Let's start there.

00:16:12 Sure, y'all man is what it sounds like. It is sort of the original repo y'all. That's when you're a startup in 2004. You're you kind of just make a repo, right. And it's your web app.

00:16:24 And that probably made a subversion repo, because it wasn't that CVS stuff we're gonna do in Subversion.

00:16:30 I don't remember when we switched from subversion. But we it was subversion. I don't know. I don't know if it was before. So I don't know if we actually started out in Subversion. Because I didn't start until 20 Share. But yeah, it's definitely subversion was I know, it was there was some old subversion stuff. But so you have this one, you know, sort of web app. And the web app is a server that serves that originally served everything. So you know, there's a bunch of stuff that like, you know, you can sort of think of as like, yelp.com, right? Like, if you, if you go to www.yelp.com, then you're, you're looking at what you think of as your right is like, Oh, I search for businesses, I can look at their reviews, I can write my own reviews, that kind of stuff. So it's that, but it's also other stuff. It's also our business owner site. So biz.yelp.com, which is where business owners, like look at their own businesses and like, are able to see metrics and like, you know, buy ads and stuff like that. There's our admin site, which is you know, where a lot of anybody, we have our sort of user operations, people whose whose job is at least partially to do some moderation and stuff like that. So like, we need to be able to have those tools. And then there's also what we call the turn, call internal API. And internal API is a way for internal stuff to get the data that's in your name. So that's what that is. And that's like its own separate sort of site. And but these are all in the same repo, they all run in the same process. That's sorry, no, I was just

00:17:59 going to ask is this kind of the mono repo style or it's truly a monolith in the sense that it's kind of all the same app,

00:18:06 it's truly a monolith, there is some amount of stuff where it's like, oh, we have like different containers running like different entry points. But like, the code is all kind of tangled up together. So there's not really a meaningful delineation between different components in a way that you could really separate them out in any meaningful way. So like, my understanding of like, what I would define as a mono repo, I wouldn't really call it that. I would just call it I would call just a

00:18:31 large app. That's a huge, huge,

00:18:33 huge app. Huge repo. Yeah,

00:18:36 yeah. Okay. So in your talk, you said that you have six different sites with 2000 different endpoints. Yeah. Which it's a lot. I don't think it's completely excessive or anything like 2000, URL endpoints for all those different services. And like, all those different admin apps, it seems it's a lot, but it's not insane. And then you have these background batch services, what what story, those,

00:18:59 it's just sort of anything that you need done, as I said, this was just sort of like, this is the one repo right. And so there's a lot of things that you want done, that aren't necessarily done in the context of a web request, or don't make sense to do synchronously. So a lot of that is just sort of like, okay, you know, I need to like do this, like, really complex report or something, right. You know, I want to get some metrics that like, involve collating a bunch of data, doing a bunch of joins against a bunch of tables. Okay, well, I'm not going to have just like web requests do that. I'm going to put that in like a separate process. And we originally, as you can imagine, for that type of application, we just called them as batches. Yeah. Batch a batch job, right? That name has stuck, despite the fact that now batches don't necessarily do that type of work. They're just sort of anything you want to do in the background, right? And that could be something like, oh, the first of the month we do our like, add billing, or we might have some process where it's just sort of like oh, we want to like update this cash, you know, based on like day Gotta like stuff. But we don't want to do it in line in a in a web request, we can do it asynchronously. So it's really anything that is not in the context of a web request.

00:20:10 I suspect, most major apps, most companies have that kind of stuff to write. They've got to

00:20:16 I mean, everyone has some version of it, whether or not they do it exactly the way that we do. It is separate question, but I'm not really sure. But

00:20:23 yeah, I think part of the story is do you deploy them all out at the same codebase? Or are they, you know, a bunch of different jobs, and repos? Or how's that fit together? That's probably where the, it varies.

00:20:33 Yeah. I mean, for us, we have, I mean, I said, 800 batches. And I was referring specifically to the batches that are still in the main repo. And like I said, all of these things are kind of tangled together. So it's not like, Oh, you can just like pull a batch out. Like, that's like talking about like, Well, how do you get the data that it needs? And like, what does that look like? And blah, blah, blah?

00:20:52 So how does it get the data access layer? And how does it get a hold of the login thing that's over here? And, and all that kind of stuff? Right?

00:20:57 Exactly. So like, so those 800 batches, but we also have tons and tons of batches that are in services. So they live in Server three pose, and they run and they're they're in a totally separate probates? I don't know what that number is. I'd have to figure it out. Yeah, it's definitely a lot. It's probably it's almost certainly more than that than we have in Yelp main at this point. But that paradigm exists all over Yelp and not just in this room. Yeah.

00:21:21 Well, I think these are a lot of value to having that code together. Right? If you break this out into a whole bunch of different repos, you've got dependency management, versioning. And deployment, like there is some value to just saying, like, just let it live together. We'll upgrade it together. But it does make for some striking headlines when you talk about how many lines of code got upgraded at once. Right? Yeah,

00:21:41 I mean, I think that when you're talking about like, why do we solve them all up? The answer is mostly just because it's really hard to not have one, once you have one, you have to do all the work to move out. And there are disadvantages. Like you said, it's sort of like, okay, now as soon as you have a new repo, it has its own set of dependencies that you have to keep up to date, and you have to do other sort of maintenance on it. Generally speaking, we consider that better, though, still, because it's sort of like, it's always better. Like imagine if I'm in in this giant monolith, and I'm like, oh, I need to upgrade this package. And it's like, okay, well, you want to do a major upgrade, and his packages imported in 1000 places. Now, you may you'll with that migration, whereas if it's like, oh, I'm in my service, and this and that, I need to do this package upgrade. And it's important in 10 places, that's like an afternoon instead of like, you know, coordinating here is one thing, right? Yeah. So there's definitely advantages to that it does add, it's sort of like more work overall. But you can do it in a more granular way. So it allows you to unblock people faster, essentially. So like, we definitely want to move away from monolith. And we have been doing that, like, be careful when I started that y'all. We have way, way less code that is important running in your name, there is still a ton that's important in there, like I mentioned in my talk, like, almost inevitably, someone has to like call into an internal API to get our get data out of it. So that's something that like, we definitely want to fix at some point. But it is a process. And that process is generally speaking, like we're getting to the point where like some people who work at Yelp don't really work in the alternate anymore. Like they just don't have to deal with it. Especially not on a day to day basis.

00:23:20 Right. Sure. And you mentioned your talk. I don't know if I said this beginning, but you gave a talk at Pycon 2022, which is definitely it was a very popular one, highlight some of these things there as well. So I'll be sure to link to that. So people can check it out. And you talk about people developing NLP, and some of them not. But there's still a lot happening there. You said 20 pushes a day 800 simultaneous, simultaneous developer developers? And yeah, that's no joke. That's a lot of traffic on a repo. Yeah,

00:23:49 I think since I did that talk, where we've been going, we've been trending down in terms of number of changes per day, but it would still probably close, like somewhere in the, like 15 to 25 a day. So it's less like that's an appreciable percentage less, but it's still a lot of changes per day.

00:24:07 Yeah, yeah. And you also said, you have 700 Python package dependencies. We talked about the private pay API. So when you say you have 700 dependencies, that's if I go into the virtual environment and type, you know, Pip list, I see 700 things.

00:24:20 Okay. It's a lot. There's a lot. It was an ordeal dealing with,

00:24:24 especially coming from a long time ago until present, right, in terms of code and code compatibility, right. Some of those things you dependent on, maybe their new versions have moved to python three, but maybe with breaking changes. Others, they might just not have a python three version. And how do you deal with that?

00:24:42 They're all basically in terms of like open source stuff. There are basically like three ways so we dealt with that. So one is just like upgrade and like, deal with whatever the upgrade entails. We didn't I don't think we really ran into any issues where we were like, oh, no, we have to do this like massive breaking change. You know, migration, that wasn't really a problem that we ran into, thankfully. So a lot of those were just sort of like figuring out what packages need to be upgraded. And just like sort of doing the upgrade, making sure that they test paths and that kind of stuff. So that wasn't too bad. The other one, which was a little bit more annoying, was like he said, Some packages just stopped updating before they got python three support, and we were relying on them. So we had to be like, Okay, well, can we replace these with something that, you know, fixed. And there were a few examples of packages, where it sort of stopped getting development, and then someone was like, Oh, I see where the problem lives. That's a problem for me. So I'm going to fix that. And so luckily, a lot of people have already done that work. And they there were like forks or sort of drop in replacements, sometimes not exactly drop in replacements, but like, you know, close enough that we could like, do do the small amount of work that was needed. It's one

00:25:52 of the advantages of being a little bit later to the party, as well as other people bump into those problems. And maybe they fix them for you, right? I probably had most of the time. Honestly,

00:26:01 that was definitely a good chunk of the time. I couldn't tell you, I'd have to like go back and like run the numbers on like, what percentage of time that was, but like, we definitely there was definitely a good chunk of things. Were just sort of like, Oh, someone already made the fork or whatever. And we can just use that. And that was that was nice. That was okay, that's, that's, you know, that one checked off. And then the final sort of grouping was stuff where there was that wasn't available. So it was like, Oh, this package is python two only, and no one ever made a replacement. So we need to deal with that. Luckily, we none of those were in a position where we were completely unable to deal with it. Like we didn't run into anything where we were like, Oh, this is just like, this is like a blocker. But there were things were like, Oh, this thing needs to be replaced with something else that does something similar. Or maybe after I'd away like very often, we ran into code where it was like, Oh, this is using this thing. And then you start looking into it. And you're like, oh, actually, this code is like this, like branch or whatever that uses this package isn't actually used anymore. So we can just delete all that code and like not have to think about it. So that's, that's how we dealt with. Yeah, that's

00:27:09 a nice way to upgrade. It's just get rid of it. Yes. Were there any packages that you're out there that didn't have python three support? No, really, we really depend on this one that you upgraded, and contributed back to be able to just move on,

00:27:24 there was nothing that we run into that was like an absolute blocker like that. So we didn't end up contributing anything in terms of open source, other than there were some packages that are like on our GitHub, like the Yelp GitHub, that we did do upgrades for sure. So that was, you know, that was the only sort of open source work. We I think we're really ended up doing. Yeah, so luckily, I mean, I don't know if this is lucky or not. But it's definitely it happened so that we didn't have to

00:27:51 do that. Yeah, that's good. I mean, it'd be nice if you ran across that and, and helped it, solve it for someone, but you don't have to do even better testing. One of the challenges of versus good to have tests. But one of the challenges of, of these upgrades is you wanted to do this without disrupting development, you wanted to keep adding new features, you didn't want to say, hey, everyone stopped making any progress or, or bug fixes for six months. And we're all just going to do this until we're done. Right? You wanted to keep it moving. But in order to do so you got to run the test, because you're making wholesale changes to millions of lines of code. So that's pretty nerve racking, right? And you're swapping out its dependencies and big ways. And yet running tests. Y'all have a lot of tests, and they take a while to run, right? Yeah, we

00:28:36 have about 100,000 tests in the main little under. And, yeah, if you were to run them serially, at least when I wrote my talk, it was about 35 hours total. But we have a test runner framework, and called jolts that we run internally. And what it does is it basically like puts those tests up into bundles, and then runs those on across a bunch of machines. And so you're basically able to get a all of the tests run for y'all man and about give or take an hour and a half.

00:29:05 Okay, that's pretty good for running 100,000 tests. That's still a long time to have a test run, though, right? So you probably need it. You can't just get immediate feedback, minor change, how'd that go? minor change had that go? You kind of it'd be a little more thoughtful than that. Right? Yeah.

00:29:17 I mean, I think that in terms of, and this sort of gets into, like, testing theory, is that, like, you start to get an idea of like, what changes are like, effect, what other things like sometimes you're not, you're not gonna have a perfect idea. But like, if you're like, Oh, this is a thing that just affects everything, then you're going to run all the tests. But we did have the ability to run tests, if we were like, Okay, we want to just run tests under python three, we could do like, Oh, I'm just going to run this, you know, test module under pray, I can do that. And so like, if you were literally just like, Oh, I'm checking. I'm like fixing this test under python three, then you could just do that. You could just be like, Oh, I'm iterating very quickly by like changing the code and then running the tests on your python three, and then, you know, oh, it passes. Okay, let me double check, it passes under python two as well. And then you can commit that and then like, put that into PR. And then we do require. So one of the things is that we do require running all during a full jolt run for every pull request to me. So in order to do so you have to run that anyway. But like, while you're waiting for that to run, you can work on something else. Sure. And your high confidence that you run

00:30:26 a couple. Okay, that makes sense. So run a couple of local tests, 10 100 500, whatever. Once you're happy with that, then you put it as a PR and CI figures out what happens. Yeah. And I think that

00:30:37 ultimately, like there, one year, really early on, we were working on, like the really foundational stuff. But that was like the causing the most issues. That was the time when we're like, oh, we really got to run all the tests. But once you get down to the nitty gritty, pretty early on, actually, you really don't need to think about how it affects other things. Like it's mostly just sort of like, yeah, you know, this module effects its own tests. And that's pretty much it.

00:30:59 Okay. Yeah, I'm sure you get a feel for it over time. Like, these are the kinds of far reaching changes. And these are the kinds of things I can stay really focused on. This portion of talk Python, to me is brought to you by user interviews. As a developer, how often do you find yourself talking back to products and services that you use? Sometimes it may be frustration over how it's working poorly. And if they just did such and such, it would work better? And it's easy to do. Other times? It might be delight. Wow, they autofill that section for me? How do they even do that? Wonderful. Thanks. While this verbalization might be great to get the thoughts out of your head, did you know that you can earn money for your feedback on real products, user interviews connects researchers with professionals that want to participate in research studies, there is a high demand for developers to share their opinions on products being created for developers. Aside from the extra cash, you'll talk to people building products in your space, you will not only learn about new tools being created, but you'll also shape the future of the products that we all use. It's completely free to sign up and you can apply to your first study in under five minutes. The average study pays over $60. However, many studies specifically interested in developers pay several hundreds of dollars for a one on one interview. Are you ready to earn extra income from sharing your expert opinion? Head over to talk python.fm/user interviews to participate today? The link is in your podcast player show notes. Thank you to user interviews for supporting the show. The other requirement he said that you had was that any changes must be rollback safe. Can you speak to that? And they can like database migrations are that that right? What do you think in here?

00:32:47 Yeah, I mean, it's I think database migrations are a good example of that type of thing. We didn't really run into a situation where we actually had to do any schema changes to databases, although there was a thing where we had to do we had to make some, some changes to some data, such that it would be parsed properly under both python two and three. But yeah, what you always want to do is you want to say like, Okay, if I undo this later, maybe like a week later, someone realizes, Oh, this change made a problem has a problem. We don't want to be in this vicious war, we say, oh, we can't undo that something else, you know, it depends on it. And we can't, we can't undo it. And so that was like a main thing. I was just sort of like, don't do these things where you're just sort of like, oh, well, once we do this, we can't go back like no, don't do that. Right? If you need to, like, do some extra work, where you like build up scaffolding or whatever, then like do that work instead. And it might take a little bit longer and in the in the long run, but it makes us have less risk.

00:33:43 Yeah, I'll save diving into this for later in our conversation. But one of the things that you were able to do because of that is you were able to run apps simultaneously in two and three and use a URL reverse proxy like nginx, or something to say, this part of the web app runs python three, and this one over here runs run in python two and filter the traffic and switch it based on how it's performing or behaving. If it goes wrong, and you switch it back quick. If you didn't have that compatibility, it would be like alright, today, we pull the switch chunk, and then like you deal with the consequences for how long Yelp is down, right. So that's an interesting consequence of this idea that it should be able to be rolled back, rollback doubles, you can actually run both versions, and then sort of migrate more cautiously. You had a cool picture. And let me put it on the screen for us here, where you talked about that four different steps, the phases and timelines and how much time you spent in there. Want to talk us through this?

00:34:43 Yeah, sure. So this is just sort of like if you want to think about, okay, you've got some Python two code, and you want it to get it to python three, it's very easy to think about it in a sort of atomic way is you just sort of like oh, make it Python. Python three compatible, and it's like Okay, makes sense on Small stuff, you know, if you're like, Oh, I got my 500 lines backing on on my iPhone three today, you know, but I'm big stuff. When you're talking about millions of lines of code, you want to think about it in terms of in sort of level of compatibility. And so the three levels that we had to deal with here were possibility, which basically just means if you try and run this module with python three, will it fail with a syntax error or not? Okay. And so that's the main thing. And possibility, it turns out is pretty easy to fix. Because there were not a lot a huge number of syntax changes. And they're pretty easy to detect and fix in an automated way. Yeah, did

00:35:35 you use some tooling like pi upgrade, or what types of things

00:35:39 pi upgrade we used a little bit, it's not super designed for this. But there was a one specific thing that was really nice about it, which is that it could detect octal literals. So if you put like zero, and then a number, that's an ACO literal, in python two, that's a lot in python three is you have to do 00 Number. And it was able to detect those really easily and like fix them, which was really nice.

00:36:04 Those things I get sounds like, oh, well, that's not that much work aren't that much help. But when you do in across millions of lines of code, anything you can automate, it's gotta be really welcome, right,

00:36:13 there was a relatively common pattern. The reason that I remember that one is there was a relatively common pattern where like, people would create like, datetime objects, and then they would write year, month day, and if the month or a year was single digit, they would prefix it with a zero, which works in python two, they probably didn't mean to make it octal. But that's what they did. Yeah. And so it kind of worked. And so people and so that that existed in a lot of places, and it was like a popular pattern. But luckily, so So PI upgrade was useful in that way. It was useful later on when we were like, like, blown away all this stuff, because it's is able to fix all of those things automatically, which is nice or most. But Python modernize was where a lot of most of our automation went because I took fix a lot of the stuff. Yeah, yeah. So that was possibility. And portability is similar is that you try to import it. And then you say, you say like, Okay, this is failing with an import error like, or something is making it failed at import, like usually running code at the top level. And that was a little bit longer. A lot of that was fixing standard lib imports, you might make them most of those use six shims, if they change the six shim for that. And then some of it was also upgrading the packages. So that could be used under python three, and like imported, but there was a little bit of like, top level stuff where it was like, Oh, this like top level thing is like calling, like dict dot itter items or something. And you got to fix that. Yeah, yeah. So

00:37:41 that's, that probably gets maybe a little bit into the functional parity, which if people look at your talk, we'll see there's a couple weeks of the possibility, maybe a month or two of them portability. Now a whole bunch of the functional paradigm. It reminds me when I was learning C++, way, way, way back. And I got really excited because I finally got some complicated code to compile. Not really knowing like, Oh, no. And then you're only the beginning of figuring out what's wrong with this. The compile is the part where it shows you what's wrong. Now. It's like the mystery tour. And like, this is after that, right? It's like kind of once you get past parsing and importing, then Yuri, enter the how are they different pay really Yeah, and

00:38:21 this is, it's just sort of like I alluded to this earlier, but basically, the idea of you run all of your tests. And luckily, we had already built up a lot of infrastructure that was really useful to us. So one of the things that jolt that was able to do is it was able to do some like normalization of like trace backs, and then be like, Oh, these trace backs are like similar enough that I'm gonna group them together as like a single error, and say, like, oh, this many tests are failing with this sort of trace back. Okay, that was really useful, because it was we were able to just sort of be like, Okay, here's where the error is. And it's going to fish fix this many tests, or at least unblock this many tests. Yeah. So that was about a year of basically going through all of those test failures, and figure out, okay, why did they fall fail under python three, and just fixing them? So a lot of it was like, Oh, this thing's supposed to be a string. But it's bytes or vice versa, or they're calling

00:39:19 God items. But it's that used to be a list and it's not a list anymore. Yes, you can index it.

00:39:25 Yeah. So there's all sorts of nitty gritty things that you just have to go through them and fix them. Some of them are automatable. But like, you really need to, but not everything is and some of them are more subtle. Yeah.

00:39:37 What was your target python three version.

00:39:39 So we originally targeted three six. At the time, it was the newest version when we started the project. That was like the newest version that we had available that was that we were like we're like, you know, we're sort of ready for if you will, during during the project because obviously long project we were able to get three seven available and it was actually really great because As we were like, I don't know, um, less than a month out from when we were like open to start doing the rollout. And my coworker Chris, who were up dump, IPI was working on this project at the time. And he was like, You know what, I bet we could migrate this to python three, seven, and I'm like, go for it. Let's see, let's see how hard it is. And he did it in like a day. So it was just like, it was just like, oh, he just upgraded. It was like, I think there were like, maybe a few, three, seven does have like that one backwards, incompatible incompatibility where it makes a simpler keyword. So there were like, a few packages where he needed to like upgrade, but like he was able to do it like really quickly. And we were just sort of like, okay, and now we're going to roll out three, seven. So that was nice that it was it was sort of like we were working on three SEC's for most of it. We were we switched to three, seven near the end, and it just sort of

00:40:41 worked. It sets the foundation for going to the next version after that, right?

00:40:44 It's actually really weird. Chris is working on that, again, is going to be trying to upgrade us to three, eight, like this week, basically. Okay, cool.

00:40:52 That's really, really excellent that what was the emotional state of you and the team as you were going through that year of fixing? Nope, its list of Dick dot items, not list dot items and or dictionary dot items, and probably excited in the beginning, but you know, six months? And what was that? Like? Are we making progress? Or like, Oh, God, it's still here, we're not done.

00:41:13 I knew what it was going to be like going into it. Like I was like, I mean, not exactly. But like, I was like, I know that it's going to be this thing where it's like, we're gonna make some progress. And then we're gonna it's gonna taper off because of the way that leaves things work. And, but it was definitely like, it was sort of like you were just sort of doing your tasks every day. And each task in and of itself was not valuable, right? It was sort of like, oh, well, I've fixed three tests today, you know, kind of thing. But ultimately, I was able to see like, where the end was. So for me, I was like, I was like, Yeah, we're going to do this, we're going to do it. I think not everyone on my team was necessarily like, as sort of buying the prizes. I was, which is fine. I think we ended up we ended up swapping out. Basically everyone on the team ended up working on it at one point or another, but it was only me and and another one of my colleagues who who worked on it basically the whole time. So I think, you know, part of it was that some people are like, Okay, I'll work on that a little bit. But I don't want to only work on that. And that's totally understandable. Like, I think that this type of work is kind of tedious. And this is sort of sort of like this is another argument against monoliths is sort of saying, like, if you have to do this, when you need to do this type of migrations, it becomes really punishing on software engineers,

00:42:25 like if you haven't done linting, ever, five years into it, you like, oh, let's go see what's wrong with you went to lunch, like 100,000 years, like, you know what, we're not doing that we're just, we're just gonna ignore those just stay it because you can't just stop and go do 100,000 fixes this is there's more value on the other side of this. So it makes a lot of sense. But yeah, it must have been felt pretty good to get it all done, though.

00:42:47 It really did. I mean, it was it sort of weird how these projects work is that like, you're sort of like you're doing the work, you're doing the work. And then like, one day, you're just sort of like, No, we're done. And it's been a year and a half of my life, you know, like, but citing it was I had multiple people tell me, they said to me, Hey, it's so cool that you that, you know, we were able to do that, because I never thought it would happen. Yeah, it's kind of amazing to do something that some people are like, this won't ever happen. But I did it happened. And we made it happen. And I think that that was, you know, really great.

00:43:20 Let's talk a little bit about how you're able to, to run this on Python two and three, would you do you basically create two virtual environments, one from each setup, and then each version, and then run tests there? Try it out there?

00:43:34 Yep. That's basically it. I mean, there's a technique to having like code that runs under python two, and three, which is that, you know, you basically have to make sure that you're using compatibility layers, and we use six for that. I that was something that me and most of the people on my team had some pretty significant experience doing, because that's basically how we wrote all of our like, libraries are internal libraries. And actually, a lot of our light source ones as well. Because you know, you want for a long time there, you were like, Okay, I want to have python two and three compatibility. So having code that works under both was like pretty normal. Yeah, making sure that that code is sort of can run the Python two and three, and then building the virtual arm, there was a little bit of nuance, or like, there was a snag there, which is that like, something that comes up every once in a while when you're doing this kind of stuff. And this still, this is still a thing that happens to this day, is you have you have to deal with backward packages. So there's like the future is backport, which was the concurrent which like concurrent features was added and might have been three Oh, I don't remember exactly what version of Python three, Python it was added in. And there was like a few other backports func tools 32 spec back pork for adding some of the stuff in python three, three twos func tools like LRU cache, which is something we used a lot of. So those were both packages, where we needed to actually install them in python two, because like, there are packages somewhere in our in no depth tree that needs them. So what we had, what we ended up doing as we was we made this like silly little, little script that just sort of like took out a requirements file, and then filtered out the things that don't under install under python three, and just spit out a new one. And that's the one build our python three virtual input. And so that's how we have python two and python three virtual in, and they're like, really similar. Not exactly the same, but close enough. And then we can run run the tests against either one of them nice, or and then eventually we would, you know, do the rollout like,

00:45:30 does that like one of the challenges had to do with caching? And you have a way in which you were using pickle to stuff some results into Memcache? Is it Memcache? D or memcached? Like past tense? I never not opinion, I've never not pronounced that that one. Right.

00:45:46 I looked at their website, like, a year a day, or like, I guess two years ago or something when I was actually working on this. And I'm sure that I know. I'm for that I read it, because it's there. I remember, but I don't remember what the answer is.

00:45:58 Yeah, no worries. So let's go to memcached. I'll call it Memcache. So you were you were stuck. Previously, you were pickling? Things? You were see pickling. But then that just became pickling. But at some point, it's one thing to say at the database query level will T serialize. And serialize. an ORM object to match the schema is a whole nother to say the binary shape of this thing is the same across Python versions, which is highly unlikely, right, which

00:46:23 is pickle, it's basically impossible. Yeah, that was like the Yeah, that was one of the big problems that we had. So we're basically taking, we're basically like, so we'd pickle, there's like a cache key. And then there's a cash value with pickled both. And then the cache key, we would, we would like hash, so that it could be like, you know, a specific binary sequence. And then that would, and then we key into that in order to get stuff out of the out of the cache. And but it turns out that for a multitude of reasons, both the key like he said, the key is not going to be binary, the same. So like, that's one of the problems. And the other problem is that there's a lot of like, weirdnesses, when you end up like either reading Python, two pickles in python three, and you're reading Python, three pickles.

00:47:08 That seems like pickles are kind of meant to be transient. They're not meant to sort of be long term storage, because there's not a lot of guarantees around their parse ability. Yeah,

00:47:17 we were like, Okay, well, what's what's the thing that we can do, where we don't have to start being like, Okay, now we have to write complicated serialization and stuff. And we're like, well, probably JSON JSON will work. And so this is something I worked on for about three months or something was just migrating all of our caches to, to use JSON instead of pickles,

00:47:37 you had this kind of fallback mechanism, or this Salou upgrade mechanism that said, try to get the JSON version from memcache. And if you got it, awesome, go with that. But then fall back and try to get the binary pickle, but then immediately replace it with the JSON version, so that it just grows over time. I mean, thinking about that much code. And that many services, there must just be a ton of startup cost, if you just kick all the servers over and clean the cache, we've never

00:48:06 tried it, I think everyone's a little bit too scared. But it's definitely like not something we wanted to do. And we wanted to be able to be like, okay, for one, we cut over to python three, we're not just gonna lose all our caches. I think this is actually a really great example of something we were discussing before the recording started of like, doing a sort of like incremental upgrade. And one of the other things I didn't super get into with in my talk is that like, one of the things that I thought was a really cool technique. And this really depends on whether or not this is worth, it depends on like, how you ended up what the value of your like uptime is basically, compared to your dev time, but we were, what I did is I sort of logged, what I would do is I would like, for every cache, I'd be like, Okay, I'm gonna try to log this to JSON. And then if it failed, I wouldn't just fail. I'd like do the normal stuff. I do all the technical stuff, whatever. But then I'd log it somewhere. And so that way, I could just like look at this log, and be like, Oh, here's where my errors are. So it wasn't just like, oh, I would do I would like ship changes. And then like, see if there were actual errors on production. And it's like, there's no errors on inspection. There's just errors in this log that I can like, fix and like, iterate on and know, you know, user ever sees a season 500 not gonna fit into that. But I think that that's a really, I think that's a really useful tool. Yeah, that

00:49:23 is really cool. Because no matter how much testing you do on something that's big. It's not until you really put it out there, you see that 100% Sure is going to hang together. But if it can fail silently in a way that people don't see, but you you get notified about this and can start working on it. That's, that's really valuable. Another thing that you did that I thought was pretty clever, was the way that you did the rollouts, where you were able to say, even though this is one huge monolith of code, that doesn't mean it breaks evenly, right? Once you get past the possibility stage, there could be some URL endpoint that's going to fail. If you request it and another that works totally fine. Alright, so what you were what you all did is you created a reverse proxy. And I was imagined nginx do what what were you actually using here?

00:50:10 So it's kind of Nginx. It's open resti, which is a framework where you can write plugins for Nginx. Okay, in Lua, so you can, you can do some sort of, you know, general logic.

00:50:24 So we were basically able to say, you know, when you go to yelp.com/something, or api@yelp.com, or whatever it is, as far as a user, it's the same, but some of those URLs are hitting the python three version of this large monolith app running and somewhere hidden in python two, and you could move it URL URL endpoint endpoint at a time, right? Yeah, talk to you about that. That's pretty clever.

00:50:46 Yeah, this is super cool technique. So we already had the reverse proxy layer, we had the Routing Service, this is something that we have built for just sort of consolidating a bunch of logic in a general place where like, everything could rely on it. But it was a really great place for us to be able to put this logic as well. And I'm gonna say, say him again, Chris keel on my, my colleague on my team came up with this idea as well. So it's, it's such a great idea and applies, I think, really generally like, you can just sort of say like, okay, anytime I'm doing some sort of rollout where the setup is such a work in such a way that like, I can't, like do it within my application, like, there's something about the application setup, you can, if you have this external layer, then you can, then you can pretty easily do it. And yeah, it was basically just sort of like, you know, we would have a configuration and it would say, like, Okay, this, this like, prefix endpoint, or like this endpoint prefix, would go to python two, or this one would go to python three, and we can actually even be a little bit more granular that we could actually give it a percentage of the time. So basically, like, you know, 20% of the time, it goes to Python to 80% of the time, it goes to python three. And so we could do these sort of slower rollouts if people wanted to be more careful.

00:52:01 I see. So maybe it goes like, it's on Python two, now. 1% of the traffic goes to python three, is it dying? Or no? It seems okay. It seems okay. All right, not 20. Now at like, you could like slowly move it over. So if it fails, at least fails, just for a few people. And even you don't even roll it back. You just stopped sending traffic there and fix it, which is really good. Yeah, pretty clever. And it certainly makes sense for large projects. But it was great as it lets you start getting your python three version in production way earlier, right? You're not waiting on the last endpoint, you just need the first employee. I mean, probably you didn't do this very, like, while you were all works, put it out there. But like, you could do it much sooner than you would otherwise. Right.

00:52:42 For various sort of practical reasons. We didn't do we didn't want to actually start the rollout until we were like, oh, all the tests pass under python three. We didn't want people to be like, Oh, I'm running my tests, and they're not passing. And that's bad. And I'm either gonna, like ignore them or tried to fix them in a bad way and stuff like that. But like, I mean, it was like a two month process where we were like, from the first endpoint to the last endpoint was like two months. And so that was able, that was really nice, because it was like, Oh, we would detect issues. And then we would, but we would keep rolling out other stuff. And then, you know, the teams or we could try and fix the issues. And so very neat.

00:53:22 That's great. All right. Let's wrap this up. We're getting short on time here. You had some some clear benefits, even though you went to python three, six, which I think you'll see those benefits again, if you go to 311. All right. But even so going from where do you go from two, seven to three, six wants from 272372737. Right on? Okay, cool. And you said it got faster and use less memory? That's pretty good.

00:53:48 I don't remember the exact numbers. It was in my talk, I stolen from your talk. 15

00:53:51 To 20% Speed up and 20% less memory. That's that's tangible.

00:53:56 That's right. That's right. Yeah, I remember, this is something I didn't mention my talk, but I thought I think it's kind of interesting. So we have some stuff that is, you know, more CPU heavy, which we send to what we call VIP instances. So VIP, like containers have more memory and more CPU, okay, allocated towards them. And so I remember I talked to someone who was involved in like, doing a lot of that sort of, like operational stuff. And and after that migration, they like looked at numbers, and they're like, Oh, we can now scale down the VIP to what the old normal one was. And the normal one is now scaled down even more. Oh, that's cool. Yeah. Which is super cool. So it was like, super good to do that. And I think that beyond just sort of like, oh, this like, gave us this immediate, or this gave us this like outcome. It's like we weren't going for this outcome. But I think it really shows how like this type of work. Like if you're like, you know, I think very often it's easy to look at, like base level infrastructure workers. Like, Oh, well, it's just maintenance, and you just need to do it and blah, blah, blah. And, you know, it's not really benefiting anything. And it's like, no, like, we did this and it like saved money on our bottom line, you know, and not necessarily everything is going to be like that. But like, I think that thinking about base level and for infrastructure is like, it does have a benefit. It might not necessarily be obvious before you do it. But you know, this is an example of, okay, if you're doing your upgrades, you get to take advantage of all the really hard work that all of the people on the Python language team have done to make the, you know, make it more efficient and faster.

00:55:35 Yep. And it probably opens up other possibilities. The previous show I just did, which not out yet. So you wouldn't know. But was talking about rough, the linter written in Rust for Python. But you know, you have this ability to integrate with more modern tools in modern language. It's like, Oh, if we got to rewrite this section and Russ, for that computation, it's trivial now, where probably it wasn't before. I would imagine I haven't tried it ingredient by 27. With, you know, things like that. But I bet it's not as easy as the new tools, you know? Yeah, for sure. All right. Well, let's leave it here. I think that's all the time, we got to talk about it. But you must be enjoying it. Enjoying work on the projects and the features more now you can just kind of the world is your oyster again?

00:56:17 Yeah, I love using we bit the project that I've been working on actually lately, as we've been adding a lot of type annotations internally. That's, you know, python three feature

00:56:26 right there. So absolutely. You can use F strings. You can use type annotations, you can start using tools, like my PI, not just standard nine type annotations, just for editors. But yeah, it Pydantic For example, all those things right. Very cool. All right. Now, before you get out of here, I got two questions. Always at the end of the show, you're going to write some Python code, what editor are using these

00:56:48 days, I'm a vim person, do all my development and vim right on

00:56:52 and then notable pi pi package, give a shout out to Python modernized. But anything that stands out, you want to give a shout out to like that

00:57:00 I mentioned Python, modernize Great, excellent tool for what it is. I also give a shout out in my I give a shout out to a couple other things in my talk. But I think they're they're definitely worth giving a shout out to steal, which is pi upgrade, which we mentioned earlier, it has a lot of really nice features. One of the sort of other things is kind of the other half of Python, Python modernized is that it can take your sort of six shim filled code and turn it into sort of normal python three code. And then another tool by the same same a former colleague of mine, and these Tilly eyes, pre commit their modernizes a pre commit hooks, Pat grade is pre commit hook, that's a that's something that we use extensively internally, super, super nice to be able to, like, you know, do all those sorts of things and, and do it in an incremental way, which is something that was really valuable. And then the last one, this is just completely random one, but I just love it is more itter tools. One of my favorite packages, we have like an internal package that has a lot of the like functions that are in monitoring tools, but they're worse, or like cookie in some way that I that I don't like. And so that's something that was like, when I first found out about it. I was like, oh, man, this is great. And I think it's pretty popular now. But like, I think it's it's one of those things where just sort of like, Oh, these all these little functions that you're like, Oh, I could write that. And it's like you could but you'd probably read it, you know, with that edge cases or something. It's just it's a great, great library.

00:58:24 And it's better if you don't have to read it. That's for sure. Yes. All right. Well, then, thanks for being on the show. Final call to action. Maybe some other people are out there facing this transformation they got to do like I said, not actually python two to three, but you know, some major foundation in their code base, you know, there, what do you tell them figure out

00:58:40 a way to make it incremental? That's really I think the main takeaway for me is that incremental changes have multiple benefits. They're making you less risky, you're able to do these types of changes in a way, like where you don't necessarily have to be like, Oh, we have to schedule two years of work. It's like, No, you can do you can do it, you know, a chunk at a time when you have time. And also it just like generally, make sure you have less errors.

00:59:08 Absolutely. All right. Well, thanks so much for being here. It's been great to have you on the show. Appreciate it.

00:59:13 Thanks so much for having me.

00:59:15 This has been another episode of Talk Python to me. Thank you to our sponsors. Be sure to check out what they're offering. It really helps support the show to win Cox, automotive and use your technical skills to transform the way the world buys, sells and owns cars. Find an exciting position that's right for you at talk python.fm/cox. earn extra income from sharing your software development opinion at user interviews. Head over to talk python.fm/user interviews to participate today. On level up your Python we have one of the largest catalogs of Python video courses over at talk Python. Our content ranges from true beginners to deeply advanced topics like memory and async. And best of all, there's not a subscription in sight. Check it out. for yourself at training dot talk python.fm Be sure to subscribe to the show, open your favorite podcast app and search for Python. We should be right at the top. You can also find the iTunes feed at slash iTunes, the Google Play feed at slash play and the direct RSS feed at slash RSS on talk python.fm. We're live streaming most of our recordings these days. If you want to be part of the show and have your comments featured on the air, be sure to subscribe to our YouTube channel at talk python.fm/youtube. This is your host Michael Kennedy. Thanks so much for listening. I really appreciate it. Now get out there and write some Python code

