00:00:00 If you're a fan of Pydantic or data classes, you'll definitely be interested in this episode.

00:00:04 We are talking about a super fast data modeling and validation framework called MessageSpec.

00:00:09 And some of the types in here might even be better for general purpose use than Python's native classes.

00:00:15 Join me and Jim Chris Hariff to talk about his framework, MessageSpec.

00:00:19 This is Talk Python to Me, episode 442, recorded November 2nd, 2023.

00:00:25 Welcome to Talk Python to Me, a weekly podcast on Python.

00:00:43 This is your host, Michael Kennedy.

00:00:44 Follow me on Mastodon, where I'm@mkennedy, and follow the podcast using @talkpython, both on fosstodon.org.

00:00:52 Keep up with the show and listen to over seven years of past, episodes at talkpython.fm.

00:00:57 We've started streaming most of our episodes live on YouTube.

00:01:01 Subscribe to our YouTube channel over at talkpython.fm/youtube to get notified about upcoming shows and be part of that episode.

00:01:08 This episode is sponsored by Posit Connect from the makers of Shiny.

00:01:14 Publish, share, and deploy all of your data projects that you're creating using Python.

00:01:18 Streamlet, Dash, Shiny, Bokeh, FastAPI, Flask, Reports, Dashboards, and APIs.

00:01:24 Streamlet, Dash, Shiny, Bokeh, FastAPI, Flask, Reports, Dashboards, and APIs.

00:01:25 Streamlet, Dash, Shiny, Bokeh, FastAPI, Flask, Reports, Dashboards, and APIs.

00:01:25 Streamlet, Dash, Shiny, Bokeh, FastAPI, Flask, Reports, Dashboards, and APIs.

00:01:25 Posit Connect supports all of them.

00:01:27 Try Posit Connect for free by going to talkpython.fm/Posit, P-O-S-I-T.

00:01:32 And it's brought to you by us over at Talk Python Training.

00:01:36 Did you know that we have over 250 hours of Python courses?

00:01:41 Yeah, that's right.

00:01:42 Check them out at talkpython.fm/courses.

00:01:45 Jim.

00:01:48 Hello.

00:01:48 Hello.

00:01:48 Welcome to Talk Python To Me.

00:01:50 It's awesome to have you here.

00:01:50 Yeah, thanks for having me.

00:01:51 Yeah, of course.

00:01:52 I spoke to the Lightstar guys.

00:01:54 You know, at Lightstar.dev and had them on the show.

00:01:57 And I was talking about their DTOs, different types of objects they can pass around in their APIs and their web apps.

00:02:04 And like FastAPI, they've got this concept where you kind of bind a type, like a class or something, to an input to a web API.

00:02:12 And it does all that sort of magic like FastAPI.

00:02:15 And I said, oh, so you guys probably work with PyDanta.

00:02:17 It's like, yes, but let me tell you about MessageSpec.

00:02:19 Because that's where the action is.

00:02:21 They were so enamored with your project that I just had to reach out.

00:02:24 And have you on.

00:02:25 It looks super cool.

00:02:26 I think people are going to really enjoy learning about it.

00:02:28 Thanks.

00:02:29 Yeah, it's nice to hear that.

00:02:30 Yeah.

00:02:31 We're going to dive into the details.

00:02:33 It's going to be a lot of fun.

00:02:33 Before we get to them, though, give us just a quick introduction on who you are so people don't know you yet.

00:02:39 So my name's Jim Christreif.

00:02:41 I am currently an engineering manager doing actually mostly dev work at Voltron Data, working on the IBIS project, which is a completely different conversation than what we're going to have today.

00:02:51 Prior to that, I've worked on a couple of startups.

00:02:53 And was.

00:02:54 Most of them doing Dask was the main thing I've contributed to in the past on an open source Python front.

00:03:01 For those not aware, Dask is a distributed compute ecosystem.

00:03:04 I come from the PyData side of the Python ecosystem, not the web dev side.

00:03:09 Nice.

00:03:09 Yeah, I've had Matthew Rocklin on a couple of times, but it's been a while, so people don't necessarily know.

00:03:13 But it's like super distributed pandas, kind of.

00:03:18 Grid computing for pandas, sort of.

00:03:19 Or say like Spark written in Python.

00:03:22 Sure.

00:03:23 You know, another thing that's been.

00:03:24 Kind of on my radar, but I didn't really necessarily realize it was associated with you.

00:03:29 Tell people just a bit about IBIS.

00:03:31 Like IBIS is looking pretty interesting.

00:03:33 I don't want to say the wrong thing.

00:03:35 IBIS is a portable data frame library is the current tagline we're using.

00:03:38 If you're coming from R, it's dplyr for Python.

00:03:42 It's more than that.

00:03:43 And it's not exactly that, but that's a quick mental model.

00:03:46 So you write data frame like code.

00:03:49 We're not pandas compatible.

00:03:50 We're pandas like enough that you might find something familiar.

00:03:53 And it can compile.

00:03:54 Down to, you know, generate SQL for 18 plus different database backends.

00:03:58 Also like pies.

00:03:59 More interesting.

00:04:00 A couple other things.

00:04:01 Okay.

00:04:01 So you write your code once and you kind of run it on whatever.

00:04:03 I see.

00:04:03 And you do pandas like things, but it converts those into database queries.

00:04:08 Is that.

00:04:08 Yeah.

00:04:09 Yeah.

00:04:09 So it's a data frame API.

00:04:11 It's not pandas compatible, but if you're familiar with pandas, you should be able to pick it up.

00:04:16 You know, we cleaned up what we thought as a bunch of rough edges with the pandas API.

00:04:19 Yeah.

00:04:19 Were those pandas one or pandas two rough edges?

00:04:22 both.

00:04:22 It's, I don't know.

00:04:23 It's.

00:04:24 Yeah.

00:04:24 It's pandas like.

00:04:25 We'll say.

00:04:25 Sure.

00:04:25 Yeah.

00:04:25 This looks really cool.

00:04:27 That's a topic for another day, but awesome.

00:04:29 People can check that out.

00:04:30 But this time you're here to talk about your personal project message spec.

00:04:37 Am I saying that right?

00:04:38 How are you saying MSG or message spec?

00:04:40 Message spec.

00:04:41 Is right on.

00:04:42 It is.

00:04:42 I think a lot of these projects sometimes need a little, like here's the MP3 you can press play on, like how it's meant to be said, you know, sometimes it's kind of obvious like PI PI versus.

00:04:54 Pie pie.

00:04:55 Other times it's just like, okay, I know you have a really clever name.

00:04:59 Yes, I know.

00:05:00 People say numpy all the time.

00:05:01 I'm like, I don't want to, I try to not correct guests.

00:05:04 Cause it's, it's not kind of, I also feel awkward.

00:05:06 They will say numpy and I'll say, how do you feel about numpy?

00:05:08 Like numpy is great.

00:05:09 I'm like, okay, we're just going back and forth like this for the next hour.

00:05:12 It's fine.

00:05:13 But yeah, it's, it's always, I think some of these could use a little, like a little play by.

00:05:18 So message spec, tell people about what it is.

00:05:20 Yeah.

00:05:21 So gone through a couple of different taglines.

00:05:22 The, the current one is a fast serial.

00:05:24 Stylization and validation library with a built-in support for JSON message pack, YAML and Toml.

00:05:29 If you are familiar with.

00:05:31 Pydantic that's probably one of the closest, you know, most popular libraries that does a similar thing.

00:05:36 You define kind of a structure of your data using type annotations and message spec will parse your data to ensure it is that structure and does so efficiently.

00:05:44 It's also compatible with a lot of the other serialization libraries.

00:05:48 You could also use it as a stand in for JSON, you know, with the JSON dumps, JSON loads, you don't need to.

00:05:54 To specify the types.

00:05:55 Right.

00:05:56 It's I think the mental model of kind of like it swims in the same water or the same pond as Pydantic, but it's also fairly distinguished from Pydantic, right.

00:06:06 As we're gonna explore throughout our, our chat here.

00:06:09 The goal from my side, one of, one of the goals, was to replicate more of the experience writing rust or go with rust Surde or goes JSON where the serializer kind of stands in the background rather than my experience working with, with Pydantic, where it felt like the base model kind of stood in the foreground.

00:06:25 You're defining the model of serialization kind of comes onto the types you've defined, but you're not actually working with the serializers on the types themselves.

00:06:31 Got it.

00:06:32 So an example, let me see if I see if I do have it.

00:06:36 An example might be if I want to take some message I got from some response I got from an API, I wanna turn it into a Pydantic model or I'm writing an API.

00:06:44 I wanna take something from a client, whatever.

00:06:46 I'll go and create a Pydantic class and then I, the way I use it is I go to that class and I'll say star, star.

00:06:53 Dictionary I got, and then it comes to life like that, right?

00:06:57 Mm-hmm where there's a little more focused on just the, the serialization and has this capability, but like, like you said, it's optional in the sense.

00:07:06 Yeah, I, in message spec, all types are on equal footing.

00:07:11 So we use functions, not methods, because if you wanna decode into a list of ints, I can't add a method to a list.

00:07:18 You know, it's a Python built in type.

00:07:20 Yeah.

00:07:21 So you'd say message spec, dot JSON dot.

00:07:23 Decode your message.

00:07:25 And then you'd specify the type annotation, as part of that function call.

00:07:29 So it could be, you know, list bracket int.

00:07:30 Right.

00:07:31 So you'll say decode and then, then you might say type equals list of, of your type or list, like you say, list of int.

00:07:38 And that's hard when you have to have a class that knows how to basically become what the model, the data passed in is, even if it's just a list.

00:07:46 Mm-hmm some Pydantic classes, you gotta kinda jump through some hoops to say, hey, Pydantic, I don't have a thing to give you.

00:07:52 I want a list of the.

00:07:53 List of those things.

00:07:54 And that's the, the top level thing is, you know, bracket bracket.

00:07:57 It's not, it's, it's not any one thing I can specify in Python easily.

00:08:00 Yeah.

00:08:01 To, to be fair to the Pydantic project, I believe in V2, the type adapter.

00:08:04 Yes, exactly.

00:08:05 object can work with that.

00:08:06 But that is, you know, it's a, it's a different way of working with it.

00:08:09 I, I wanted to have one API that did it all.

00:08:12 Sure.

00:08:13 And it's awesome.

00:08:14 They made a, I mean, I wanna boost, put this out front, like I'm a massive fan of Pydantic.

00:08:18 What Samuel's done there is incredible and it's just, it's really made a big difference in the way that people.

00:08:23 People work with data and Python.

00:08:24 It's, it's awesome.

00:08:25 But it's also awesome that you have this project that is an alternative and, and it makes different assumptions and you can see those really play out in like the performance or the APIs.

00:08:34 So you know, like Pydantic encourages you to take your classes and then send them the data, but you've kind of gotta know like, oh, there's this type adapter thing that I can give a list of my class and then make it work.

00:08:45 Right.

00:08:46 But it's not just, oh, you just fall into that by trying to play with the API, you know?

00:08:51 Yeah.

00:08:53 By any type means we work with standard library data classes, the same as we work with our built in struct type.

00:08:59 We also work with adders types.

00:09:00 Everything is kind of on equal footing.

00:09:02 Yeah.

00:09:02 And what I want to really dig into is your custom struct type that has some really cool properties.

00:09:10 Not class properties, but components.

00:09:11 Features of the class of the type there.

00:09:14 Let's look at a couple of things here.

00:09:16 So as you said, it's fast and I love how somehow italicize on the word fast makes it feel even faster.

00:09:23 Like it's leaning forward, you know, it's leaning into the speed.

00:09:26 A fast serialization and validation library.

00:09:28 The validation is kind of can be, but not required, right?

00:09:32 The types can be, but they don't have to be.

00:09:34 So I think that's one of the ways it really differs from Pydantic.

00:09:37 But the other is Pydantic is quite focused on JSON.

00:09:41 Whereas this is JSON, MessagePack, YAML, and TOML.

00:09:45 Everyone knows what JSON is.

00:09:46 I always thought of TOML as kind of like YAML.

00:09:49 Are they really different?

00:09:51 It's another configuration focused language.

00:09:54 I think some people do JSON for config files, but I personally don't like to handwrite JSON.

00:09:59 YAML and TOML are like more human friendly, in quotes, forms of that.

00:10:04 YAML is a superset of JSON.

00:10:06 TOML is its own thing.

00:10:08 Got it.

00:10:08 And then MessagePack is a binary JSON-like file format.

00:10:12 Yeah, MessagePack.

00:10:13 I don't know how many people work with that.

00:10:14 Where would people run into MessagePack?

00:10:16 Yeah.

00:10:17 If they were, say, consuming an API, or what API framework would people be generating MessagePack in Python?

00:10:23 That's a good question.

00:10:24 So going back to the creation of this project, actually, MessageSpec sounds a lot like MessagePack.

00:10:30 And that was intentional because that's what I wrote it for originally.

00:10:33 So as I said at the beginning, I'm one of the original contributors to Dask.

00:10:37 Worked on Dask forever.

00:10:38 And the Dask distributed scheduler uses MessagePack for its RPC serialization layer.

00:10:43 That kind of fell out of what was available at the time.

00:10:46 We benchmarked a bunch of different libraries.

00:10:47 And that was the fastest way to send bytes between nodes in 2015.

00:10:52 The distributed scheduler's RPC framework has kind of grown haphazardly over time.

00:10:58 And there were a bunch of bugs due to some hacky things we were doing with it.

00:11:01 And also, it was slower than we would have wanted.

00:11:03 So this was an attempt to write a faster MessagePack library for Python that also did fancier things.

00:11:10 Supported more types.

00:11:11 Did some schema validation because we wanted to catch the worker is sending this data.

00:11:16 And the scheduler's getting it and saying it's wrong.

00:11:18 And we wanted to also add in a way to make schema evolution.

00:11:22 Meaning that I can have different versions of my worker and scheduler and client process.

00:11:27 And things kind of work.

00:11:28 If I add new features to the scheduler, they don't break the client.

00:11:33 We have a nice forward and backward compatibility story.

00:11:36 And so that's what kind of fell out.

00:11:38 Yeah, it's a really nice feature.

00:11:39 We're going to dive into that.

00:11:40 But you might think, oh, well, just update your client or update the server.

00:11:45 But there's all sorts.

00:11:46 There's all sorts of situations that get really weird.

00:11:47 Like if you have Redis as a caching layer and you create a MessagePack object and stick it in there.

00:11:54 And then you deploy a new version of the app.

00:11:57 It maybe can't deserialize anything in the cache anymore.

00:12:00 Because it says something's missing or something's there that it doesn't expect.

00:12:04 Right?

00:12:04 And so this evolution is important there.

00:12:07 If you've got long running work and you stash it into a database and you pull it back out.

00:12:10 Like all these things where it kind of lives a little outside the process.

00:12:14 All of a sudden it starts to matter that.

00:12:16 Before you even consider clients that run separate code, right?

00:12:19 You could be the client.

00:12:20 Just different places in time.

00:12:22 So adding a little bit more structure to how you define messages in a way to make the scheduler more maintainable.

00:12:27 That work never landed.

00:12:28 As it is with open source projects, it's a democracy and also a duocracy.

00:12:33 And you don't always.

00:12:34 Paths can be dead ends.

00:12:36 I still think it'll be valuable in the future.

00:12:38 But some stuff was changed in the scheduler.

00:12:40 And serialization is no longer the bottleneck that it was two and a half years ago when this originally started.

00:12:46 So let me put this in context.

00:12:48 People maybe make it relevant.

00:12:49 Like maybe right now someone's got a fast API API and they're using Pydantic and obviously generates all the awesome JSON they want.

00:12:58 Is there a way to how would you go about creating, say, a Python server based system set of APIs that maybe as an option take message pack or maybe use that as a primary way?

00:13:11 Like it could be maybe, you know, passing in accept header to take message pack.

00:13:16 If you want to exchange message pack client server Python right now, what do you do?

00:13:19 That's a good question.

00:13:20 To be clear, I am not a web dev.

00:13:22 I do not do this for a living.

00:13:23 I think there is no standard application slash message pack.

00:13:26 I think people can use it if they want.

00:13:28 But that's not a it's a standardized thing the same way that JSON is.

00:13:32 Yeah.

00:13:32 I think that Lightstar as a framework does support this out of the box.

00:13:35 I don't know about fast API.

00:13:37 I'm sure there's a way to hack it in as there is with any ASCII server.

00:13:40 Yeah.

00:13:41 Lightstar.

00:13:42 Like I said, I had Lightstar on those guys maybe a month ago.

00:13:44 And yeah.

00:13:46 It's super, super cool about that.

00:13:47 So, yeah, I know that they support message spec and a lot of different options there.

00:13:52 But, you know, you could just I imagine you could just return binary bits between you and your your client.

00:13:58 I'm thinking of like latency sensitive microservice type things sort of within your data center.

00:14:04 How can you lower serialization, deserialization, serialization, like all that that cost that could be the max.

00:14:10 You know, the biggest part of what's making your app spend time and energy.

00:14:14 Michael out there says, would.

00:14:16 I love high arrow parquet support for large data.

00:14:18 There's been a request for arrow integration with message spec.

00:14:22 I'm not exactly sure what that would look like.

00:14:24 Arrow containers are pretty efficient on their own.

00:14:26 Breaking them out into a bunch of objects or stuff to work with message spec doesn't necessarily make sense in my mind.

00:14:32 But anyway, if you have ideas on that, please open an issue or comment on the existing issue.

00:14:36 Yeah, indeed.

00:14:37 All right.

00:14:38 So let's see.

00:14:39 Some of the highlights are high performance encoders and decoders across those protocols.

00:14:43 We talked benchmarks.

00:14:45 We'll look at them.

00:14:45 You have a really nice lot of support for different types that can go in there that can be serialized.

00:14:52 But there's also a way to extend it to say, I've got a custom type that you don't think is serializable to whatever end thing, a message pack, JSON, whatever.

00:15:01 But I can write a little code that'll take it either way.

00:15:04 You know, dates are something that drive me crazy.

00:15:07 But it could be like object ID out of MongoDB or other things that seem like they should go back and forth, but don't.

00:15:13 You know, right.

00:15:13 So that's really nice.

00:15:14 And then zero.

00:15:15 Cost schema validation.

00:15:17 Right.

00:15:18 It validates, decodes and validates JSON two times as fast as ORJSON, which is one of the high performance JSON decoders.

00:15:24 And that's just decoding.

00:15:26 Right.

00:15:26 And then the struct thing that we're going to talk about, which is the struct type is kind of what brings the parity with Pydantic, right?

00:15:33 Yeah.

00:15:34 You could think of it as Pydantic's base model.

00:15:36 It's our built in data class like type.

00:15:38 Nice.

00:15:38 So structs are data class like, like everything in message spec are implemented fully as a C extension.

00:15:44 Getting these.

00:15:45 To work required reading a lot of the CPython source code because we're doing some things that I don't want to say that they're not they don't want you to do.

00:15:54 We're not doing them wrong, but they're not really documented.

00:15:57 So, for example, the when you subclass for message pack or message spec dot struct that's using a meta class mechanism, which is a way of defining types to define types.

00:16:06 And the meta class is written in C, which CPython doesn't make easy to do.

00:16:11 So it's a meta class that creates.

00:16:15 New C types.

00:16:16 They're pretty speedy.

00:16:17 They are 10 to 100 X faster for most operations than even handwriting a class that does the same thing, but definitely more than data classes or adders.

00:16:25 Yeah, it's super interesting.

00:16:27 And I really want to dive into that.

00:16:28 Like I almost can see the struct type being relevant even outside of message spec and in general, potentially.

00:16:34 So, yeah, we'll see about that.

00:16:36 But it's super cool.

00:16:37 And Michael also points out like he's the one who made the issue.

00:16:40 So sorry about that.

00:16:42 He's commented already, I suppose.

00:16:45 Yeah.

00:16:45 But yeah, awesome.

00:16:46 Cool.

00:16:47 All right.

00:16:47 So let's do this.

00:16:49 I think probably the best way to get started is we could talk through an example.

00:16:53 And there's a really nice article by it's more Turner Trowing who's been on the show a couple of times.

00:16:59 Faster, more memory efficient Python JSON parsing with message spec.

00:17:04 And just as a couple of examples that I thought maybe we could throw up and and you could talk to speak to your thoughts.

00:17:09 Like, why is the API work this way?

00:17:11 Here's the advantages and so on.

00:17:13 Yeah.

00:17:13 So there's this big believe this is the GitHub API.

00:17:15 Just returning these giant blobs of stuff about users.

00:17:18 OK.

00:17:19 And says, well, if we want to find out what users follow what repos or how many given a user, how many repos do they follow?

00:17:26 Right.

00:17:27 We could just say with open read this and then just do a JSON load and then do the standard dictionary stuff.

00:17:34 Right.

00:17:34 Like for everything.

00:17:35 We're going to go go to the element that we got out and say bracket some key bracket some key.

00:17:40 Now it looks like key not found errors are just lurking in here all over the place.

00:17:44 But, you know.

00:17:45 It's you should know that maybe it'll work.

00:17:47 Right.

00:17:48 If you know the API, I guess it was like this is the standard way.

00:17:51 How much memory does this use?

00:17:52 How much time does it take to look?

00:17:54 We can basically swap out.

00:17:56 Oh, our JSON.

00:17:57 I'm not super familiar with or JSON.

00:17:59 Are you?

00:17:59 Yeah.

00:18:00 Or JSON is compatible ish with the standard lib JSON, except that it returns bytes rather than strengths.

00:18:06 Got it.

00:18:06 OK.

00:18:07 There's also I JSON, I believe, which makes it streaming.

00:18:10 So there's that.

00:18:11 And then says, OK, well, how would this look if we're going to use message?

00:18:15 Spec in in his example, he's using structured data.

00:18:19 So the structs would like the pydantic version, but it doesn't have to be this way.

00:18:23 But it is this way.

00:18:24 Right.

00:18:25 This is the one he chose.

00:18:25 So maybe just talk us through, like, how would you solve this problem using message spec and classes?

00:18:31 Yeah.

00:18:31 So as he's done here in this blog post, he's defined a couple of struct types for the various levels of this message.

00:18:38 So repose actors and interactions and then parses the message directly into those types.

00:18:45 So the final call there is passing in the read message and then specifying the type as a list of interactions, which tree down into actors and repose.

00:18:54 Exactly.

00:18:54 So this is what you mentioned earlier about having more function based.

00:18:58 So you just say decode, give it the string or the bytes.

00:19:02 And you say type equals list of bracket up level class.

00:19:06 And just like pydantic, these can be nested.

00:19:09 So there's an interaction which has an actor.

00:19:10 There's an actor class which has a login, which has a type.

00:19:13 So you're pydantic.

00:19:15 And then you have a little bit of a mental model for how those kind of fit together.

00:19:17 It's pretty straightforward, right?

00:19:19 Pretty similar.

00:19:19 Yeah.

00:19:20 And then you're just programming with classes.

00:19:21 Awesome.

00:19:22 Yep.

00:19:22 And it'll all work well with like mypy or Pyrite or whatever you're using if you're doing static analysis tools.

00:19:27 Yeah.

00:19:27 So you've thought about making sure that not just does it work well from a usability perspective, but like the type checkers don't go crazy.

00:19:34 Yeah.

00:19:35 And any, you know, editor integration you have should just work.

00:19:38 Nice.

00:19:39 Because there's sometimes, oh gosh, I think maybe fast APIs changes.

00:19:44 But you'll have things like...

00:19:45 You would say the type of an argument being passed in, if it's say coming off the query string, you would say it's depend.

00:19:52 It's a type depends, not an int, for example.

00:19:56 Because it's being pulled out of the query string.

00:19:58 I think that's fast API.

00:19:59 And while it makes the runtime happy and the runtime says, oh, I see you want to get this int from the query string, the type checkers and stuff are like, depends.

00:20:09 What is this?

00:20:09 Like this is an int.

00:20:10 Why are you trying to use this depends as an int?

00:20:12 This doesn't make any sense.

00:20:13 I think it's a bit of a challenge to have.

00:20:15 The types drive the runtime, but still not freak it out, you know?

00:20:19 Yeah.

00:20:19 I think that the Python typing ecosystem, especially with the recent changes in new versions and the annotated wrapper, are moving towards a system where these kinds of APIs can be spelled natively in ways that the type checkers will understand.

00:20:33 Right.

00:20:33 But if you're a project that existed before these changes, you obviously had some pre-existing way to make those work that might not play as nicely.

00:20:41 So there's the upgrade cost of the project.

00:20:43 I'm not envious of...

00:20:45 The work that Samuel Coven and team have had to do to upgrade Pydantic to erase some old warts in the API that they found.

00:20:50 It's nice to see what they've done and it's impressive.

00:20:52 But I have the benefit of starting this project after those changes in typing ecosystem existed.

00:20:57 You know, can look at hindsight mistakes others have made and learn from them.

00:21:01 Yeah, that's really excellent.

00:21:01 They have done...

00:21:03 Like I said, I'm a big fan of Pydantic.

00:21:04 And it took them almost a year.

00:21:06 I interviewed Samuel about that change and it was no joke.

00:21:09 You know, it was a lot of work.

00:21:10 But, you know, what they came up with, pretty compatible.

00:21:13 Pretty much feels like...

00:21:14 It feels like the same Pydantic.

00:21:15 But, you know, if you peel back the covers, it's definitely not.

00:21:18 All right.

00:21:19 So the other interesting thing about Idmar's article here is the performance side.

00:21:23 So it's okay.

00:21:23 Do you get fixed memory usage or does it vary based on the size of the data?

00:21:28 And do you get schema validation?

00:21:29 Right.

00:21:30 So standard lib, just straight JSON module.

00:21:33 420 milliseconds.

00:21:35 OR JSON, the fast one.

00:21:36 A little less than twice as fast.

00:21:38 280 milliseconds.

00:21:39 IJSON for iterable JSON.

00:21:42 300, so a little more than the...

00:21:44 The fast one.

00:21:45 Message spec, 90 milliseconds.

00:21:47 That's awesome.

00:21:48 That's like three times as fast as the better one.

00:21:51 Over four times as fast as the built-in one.

00:21:54 It also is doing, you know, quote-unquote more work.

00:21:56 It's validating the responses it comes in.

00:21:58 Exactly.

00:21:59 So you're sure that it's correct then too.

00:22:01 All those other ones are just giving you dictionaries and YOLO.

00:22:04 Do what you want with them.

00:22:05 Right?

00:22:06 But here you're actually...

00:22:07 All those types that you described, right?

00:22:09 The interaction and the actors and the repos and the class structure.

00:22:12 That's all validation.

00:22:13 So in on top of that, you've created classes which are heavier weight than dictionaries because general classes are heavier weight than dictionaries because they have the dunder dict that has all the fields in there effectively anyway, right?

00:22:26 That's not true for structs.

00:22:28 Structs are slot classes.

00:22:29 Yes, structs.

00:22:30 They are a lighter weight to allocate than a dictionary or a standard class.

00:22:34 That's one of the reasons they're faster.

00:22:35 Yeah.

00:22:35 Structs are awesome.

00:22:36 And so the other thing I was pointing out is, you know, you've got 40 megabytes of memory usage versus 130, so almost four times less than the standard.

00:22:44 And the only thing that beats you is the iterative one because it literally only has one in memory at a time, right?

00:22:50 One element.

00:22:51 Yeah.

00:22:52 So this benchmark is kind of hiding two things together.

00:22:56 So there is the output, what you're parsing.

00:22:59 Everything here except for iJSON is going to parse the full input into something.

00:23:03 One big batch.

00:23:04 Message is more efficient than orJSON or the standard lib in this respect because we're only extracting the fields we care about, but you're still going to end up with a list of a bunch of objects.

00:23:11 iJSON is only going to pull one into memory at a time.

00:23:14 So it's going to have less in memory there.

00:23:16 And then you have the memory usage of the parsers themselves, which can also vary.

00:23:20 So orJSON's memory or usage in its parser is a lot higher than message specs, regardless of the output size.

00:23:27 There's a little more internal state.

00:23:29 So this is a pretty interesting distinction that you're calling out here.

00:23:32 So for example, if people check out this article, which I'll link, there's like tons of stuff that people don't care about in the JSON, like the avatar URL, the gravatar ID, the data.

00:23:44 You know, the reference type, whether it's a brand, like this stuff that you just don't care about.

00:23:49 Right.

00:23:49 But to parse it in, you got to read that.

00:23:51 But what's pretty cool, you're saying is like in this case, the class that it Mark came up with is just repo driving from struct.

00:23:59 It just has name.

00:24:00 There's a bunch of other stuff in there, but you don't care about it.

00:24:02 And so what you're saying is like, if you say that that's the decoder, it looks at that and goes, there's a bunch of stuff here.

00:24:07 We're not loading that.

00:24:08 We're just going to look for the things you've explicitly asked us to model.

00:24:12 Right.

00:24:13 That's awesome.

00:24:14 It makes no sense in doing the work.

00:24:15 If you're never going to look at it.

00:24:16 A lot of different serialization frameworks.

00:24:18 Can't remember how Pydantic responds when you do this, but it, you know, the comments beyond Pydantic, it doesn't really matter is they'll freak out to say, oh, there's extra stuff here.

00:24:28 What am I supposed to, you know, for example, this repo, it just has name, but in the data model, it has way more in the JSON data.

00:24:35 So you try to deserialize it.

00:24:36 It'll go, well, I don't have room to put all this other stuff.

00:24:38 Things are, you know, to freak out.

00:24:40 And this one is just like, no, we're just going to filter down to what you asked for.

00:24:43 I really, I think it's nice in a couple of ways.

00:24:45 It's nice from performance, nice from clean code.

00:24:47 I don't have to put all those other fields I don't care about, but also from you talked about the evolution friendliness, right?

00:24:53 Because what's way more common is that things get added rather than taken away or change.

00:24:59 It's like, well, the complexity grows.

00:25:01 Now repos also have this, you know, related repos or sub repo or whatever the heck they have.

00:25:06 Right.

00:25:07 And this model here will just let you go, whatever.

00:25:09 Don't care.

00:25:10 Not.

00:25:11 Yeah.

00:25:12 If GitHub updates their API and adds new fields, you're not going to get an error.

00:25:15 And if they remove a field, you should get a nice error that says expected, you know, field name.

00:25:20 And now it's missing.

00:25:21 You can track that down a lot easier than a random key error.

00:25:24 I agree.

00:25:25 I think, okay, let's, let's dive into the struct a little bit because that's where we're kind of on that now.

00:25:30 And I think this is one of the highlights of what you built again.

00:25:33 It's kind of the same mental model as people are familiar with some data classes with Pytantic and adders and so on.

00:25:39 So when I saw your numbers, I won't come back and talk about benchmarks with numbers.

00:25:43 But I just saw like, wow, this is fast.

00:25:45 And while the memory usage is low, you must be doing something native.

00:25:48 You must be doing something crazy in here.

00:25:50 That's not just Dunder slots.

00:25:52 Well, Dunder slots is awesome.

00:25:54 It's there's more to it than that.

00:25:56 Right.

00:25:57 And so the written NC quite speedy and lightweight.

00:26:00 So measurably faster than data classes, adders and Pytantic.

00:26:03 Like tell us about these classes.

00:26:05 Like this is, this is pretty interesting.

00:26:07 It's mentioned earlier.

00:26:08 They're not exactly, but they're, they're basically slots classes.

00:26:10 So Python data model, actually CPython data model.

00:26:13 Is either a class is a standard class where it stores its attributes in a dict.

00:26:18 That's not exactly true.

00:26:20 There's been some optimizations where the keys are stored separately alongside the class structure.

00:26:24 And all of the values are stored on the object instances.

00:26:26 But in model, there's dict classes and there's slots classes, which you pre declare your attributes to be in this, this Dunder slots, iterable and those get stored in line in the same allocation as the object instance.

00:26:39 There's no pointer chasing.

00:26:41 What that means is that you can't set extra attributes.

00:26:43 On them that weren't pre-declared, but also things are a little bit more efficient.

00:26:48 We create those automatically when you subclass from a struct type, and we do a bunch of other interesting things that are stored on the type.

00:26:55 That is why we had to write a meta class and see.

00:26:58 I went to read it.

00:26:59 I'm like, whoa, okay.

00:27:00 Well, maybe we'll come back to this.

00:27:01 There's a lot of stuff going on in that type.

00:27:03 This is what the problems with this, this hobby project is that I wrote this for fun and a little bit of work related, but mostly fun.

00:27:09 And it's not the easiest code base for others to step into.

00:27:12 It fits my method.

00:27:13 It fits my mental model.

00:27:14 Not necessarily everyone's.

00:27:15 Yeah.

00:27:16 I can tell you weren't looking for VC funding because you didn't write it in Rust.

00:27:19 Seems to be the common denominator these days.

00:27:22 Yeah.

00:27:23 Why C?

00:27:24 Just because CPython's already in C and that's the...

00:27:27 And now you see.

00:27:28 I do know Rust, but for what I wanted to do in the use case I had in mind, I wanted to be able to touch the C API directly.

00:27:35 And that felt like the easiest way to go about doing it.

00:27:38 This portion of Talk Python to me is brought to you by Posit, the makers of Shiny.

00:27:43 Formerly RStudio and especially Shiny for Python.

00:27:48 Let me ask you a question.

00:27:49 Are you building awesome things?

00:27:51 Of course you are.

00:27:52 You're a developer or data scientist.

00:27:53 That's what we do.

00:27:54 And you should check out Posit Connect.

00:27:57 Posit Connect is a way for you to publish, share and deploy all the data products that you're building using Python.

00:28:04 People ask me the same question all the time.

00:28:07 Michael, I have some cool data science project or notebook that I built.

00:28:10 How do I share it with my users, stakeholders, teammates?

00:28:13 Do I need to learn FastAPI or Flask or maybe Vue or ReactJS?

00:28:18 Hold on now.

00:28:19 Those are cool technologies and I'm sure you'd benefit from them, but maybe stay focused on the data project?

00:28:24 Let Posit Connect handle that side of things.

00:28:27 With Posit Connect you can rapidly and securely deploy the things you build in Python.

00:28:31 Streamlet, Dash, Shiny, Bokeh, FastAPI, Flask, Quadro, Reports, Dashboards and APIs.

00:28:38 Posit Connect supports all of them.

00:28:40 And Posit Connect comes with all the bells and whistles.

00:28:43 And it's a great way to build your own business.

00:28:45 And it's a great way to build your own business.

00:29:41 And it's a great way to build your own business.

00:29:42 And it's a great way to build your own business.

