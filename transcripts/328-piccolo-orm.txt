00:00:00 Arms are one of the main tools to put first class data access in the hands of non sequel loving developers. And even for those who do love sequel, making them way more productive. When you hear about Arms in python, we often hear about either sequel Alchemy or Jango RM and we should. They're great, but there are newer Orms that take better advantage of modern Python.

00:00:21 On this episode you'll meet Daniel townson. He's the creator of Piccolo Orm a great OR. That is Async first, but also has a synchronous API.

00:00:30 It has a Super clean query syntax and it's easy to learn. This is Talk Python tom, Episode 328 Recorded July 22, Nd 2,021 Welcome to Talk Python tom, a weekly podcast on Python. The language, the library is, the ecosystem and the personalities. This is your host, Michael Kennedy. Follow me on Twitter where I'm at M Kennedy and keep up with a show and listen to past episodes at Talk Python film and follow the show on Twitter via at Dock Python.

00:01:09 This episode is brought to you by land us over at Talk Python training, and the transcripts are brought to you by Assembly AI.

00:01:16 Please check out what we're all offering during our segments. It really helps support the show. Do you want to learn python? But you can't bear to Subscribe to yet another service at Talk Python Training. We hate subscriptions, too. That's why our Corres bundle gives you full access to the entire library of courses for one fair price.

00:01:34 That's right. With the course bundle, you save off the full price of our courses and you own them all forever.

00:01:42 That includes courses published at the time of the purchase, as well as courses released within about a year of the bundle. So stop subscribing and start learning at Talk Python FM.

00:01:52 Everything.

00:01:53 Dan, Welcome to Talk Python.

00:01:55 Amy, yeah, thanks for having me. I'm a big fan of the show, so it's kind of like little dream to be on the show.

00:01:59 Oh, how nice. That means a lot. Thank you. It's great to have you here, and you've built some really neat software that I'm looking forward to diving into. It's interesting because when we're going to talk about your orm, but it's also there's so many different areas of which now they're kind of pass Python two. And there's a lot of folks who are saying, you know what? We can really put Python two behind us, and Let's just build for the future that just opens up so many doors. Right? Like, oh, well, types, of course, types, not typos. Well, Python two is. Why not pythons, but not anymore. Right? And Async and all these other things. And it's really great to have these frameworks, like years coming along that just go modern Python. What can we build now?

00:02:36 Yeah, I totally agree. It felt like Python 3 6 kind of closed the door on the should we still be using Python two? Conversation because by that point, you had Async type annotations Stata classes. I think Python 3 7. No, it just goes on and on. It just felt like the Python community knocked out of the Park.

00:02:52 Python 3 6 and on.

00:02:53 I have a theory that is completely unsubstantiated that actually a lot of the progress has to do with F strings. So many people are like, I just want to easily format this code. What do I need? I need Python 3 6. Fine.

00:03:05 So actually, we're going to switch.

00:03:08 And it's such a minor feature.

00:03:09 Still liner, the pain of going back will be horrible. I couldn't imagine you in Python two now.

00:03:14 Actually, I know. Yeah. Same quick. Welcome, Ness and folks on Livestream. Chris May. Hey, happy see Paul Everett. So glad you can stop by and Teddy as well. We'll get some questions in from you all. I'm sure before we get into Piccolo and all the cool stuff that I was alluding to there, Let's just start with the story. And how did you get in a program in and by then?

00:03:31 Yeah, I've been programmed for quite long time. Now. I might look quite useful on this camera, but that's just because my web accounts got a filter on it.

00:03:37 But I actually been to to touch up my appearances checked.

00:03:40 Yeah. I've actually been getting a programmer Python for about 14 years. So Jango was kind of one of my first frameworks and just really fell in love with it because in University once. And then it's like, oh, this world of Python exists and a bit more easy than Y. And so I've used it extensively. Since then, I mostly been working for startups and design agencies and then really fell down the Async rabbit hole over the last few years to really enjoy working with web sockets and building kind of interact different ends, and also really kind of excited the way that Postgres continues to grow and help me features the other things that really excited me in the Python world. Yeah.

00:04:14 Those things are Super exciting and the web frameworks are coming along to embrace them. Language features, async and await. We had Async IO in Python 3 4 or it didn't really gain a ton of adoption because it sort of had this callback style of working, which is not the same as a weight thing and just keep rocking.

00:04:32 Totally agree.

00:04:33 Yeah.

00:04:33 So I think they pretty much took what twisted it created and ported it over. And like I say, it's all callbacks and it was still better than it's still good to have the option in the standard library. But I totally agree. As in Kuwait really kind of set on fire because it was quite hard to approach as in Coyote.

00:04:46 First, it was you don't have to think about how you write code differently. You just put the waits in the spots and then everything kind of flows.

00:04:53 It's not the same, but from how you think about structuring. Your code is real similar.

00:04:57 Yeah. And I find the maturities then now with the libraries and the stunted library, and it feels like you can just dive in, and it feels a bit like a no brainer to use async.

00:05:05 Yeah, I think it is a no brainer for sure. So it's interesting that you got into Jango in the early days because Jan goes the only major web framework that says, Here's your Rm. Here's how you use it, as opposed to Flash says, do what you want or a Pyramid. And it says, do what you want. You could use an or, but you don't have to. No, it's part of the culture and the Zen of it, right? Yeah.

00:05:27 I'm a big fan of jango. I think it's kind of a masterpiece because it's still the test of time, so remarkably well. And how you could have written a 12 years ago, and then in an afternoon, you could have upgraded it to the latest version. So there's a lot to be said for jango. And I really like the tight integration, so people tend to prefer one or the other kind of the Flash group, where you can make all of your choices. But I like really tightly integrated solutions where you come to a problem and then you pretty much know what to pay. Yeah. So that's definitely inspired Picolo to some extent.

00:05:56 I love the diversity of technology and libraries and ways of doing things in the Python space. But when people come from other technologies, it's a challenge to go, well, Here's 20 different Orms you could use in seven different web frameworks, and they're like, I don't want seven. I want to know what I should be doing. What should I do? All right. It's a mixed bag.

00:06:15 I really like that. But the thing is, if you come from the JavaScript will, then it's a relief, because you've only got 20 or 2,000.

00:06:21 Oh, my goodness. This one's seven months old. It's like ancient. Can we still use it?

00:06:26 Yeah.

00:06:26 That's a whole different discussion. The JavaScript churn over there, but Let's focus in on what you built here. So Let's talk about Piccolo. You just sell it. You describe it as a fast async Orm for Python. That's easy to learn. And I think it seems like it really hits on all those points. Tell us about it.

00:06:43 Yes. So all those terms are fairly aspirational. So the fast is because it's built on async PG. So this is a really fast, then Postgres adapter or the magic stocks guys built a the reason it's so fast is it's real in in siphon. So it's compiled. And then there's also a few other features here in Picolo which kind of help it speed wise, like frozen queries, where it doesn't have to generate the sequel each time. It kind of caches some of it. So that's kind of where the fast comes from. A knife async it supports Async ago. That was really one of the core reason for building it is because I was a Ganache power user and I had to build a lot of chat applications in my day job. So for me, Async was kind of essential. And then the easy to learn. It's called also aspirational. I've put as much effort as I possibly can into the documentation and stuff like that, but I'll let the red is be the judge about.

00:07:26 Yeah, that's in the eye of the beholder.

00:07:28 Right.

00:07:28 But the same time, you have done a lot of things that I don't see others doing. The documentation is good. Obviously, that's pretty standard on a lot of the different frameworks, although they can be Super intense. I love sequel alchemy, but when I go and read there, I'm like, okay, Here's a 20 page doc. I better pay attention and turn off my music and just not miss something. On the other hand, but what you are doing that's pretty unique is you've got a playground. You've got a playground for the admin back end. Oh, by the way, there's an admin back. And you've got a playground for trying out queries and stuff like that, right? That's pretty unique.

00:07:59 Yeah. I was really excited by the playground concept, so it's something I borrowed from the Swift world because Apple are trying to make Swift accessible in newcomers. They have this concept through a playground, which is basically a pre populated chunk of code, and then you can just play around with it as kind of the name applies. So I use I Python to achieve it. So a lot of people know I Python just running it on the command line, like a terminal, but you can actually embed it within your Python code. So the way the play ground work is, it creates a sequel ID database. It loads an example schema, populates it with data, and then basically launches the IPython shell. So you basically have all of that set up, because one of the problems we're learning an Orm is the barrier is huge. When you think about it for a newcomer, you have to set up a database. You have to understand schemas and migrations and running them and populating data.

00:08:44 So I just wanted to say, look, I'm going to shortcut all of that. Your install piccolo, you do pick a lot playground run, and then you've got an example schema, and then you can actually follow along the documentation. So whenever there's an example query in the pickle of docs, you can actually run in the playground, and you should see the results. It's quite excited about that.

00:09:00 I like it a lot. And you're right that it is challenging as we build up experience, and you get used to it. It's like, oh, yeah, you fire up the database server, and then you connect to it, and then you do this thing. But how you get the database server installed what if you have the wrong version? What if it requires authentication? But if there's a firewall, there's layers and layers of places where people get shared off. I got this doesn't work for me. And so keeping that simple, it's great. I think I just want to give a shout out to see QL light, because what you just said is such a good example of you're probably going to run this against Postgres or something like that. But for the little example you don't need that you can just use Sequel Light. And it's so nice that that's a serverless in the sense that it's just embedded doesn't require a separate process to run or connect to. It already comes with Python. Generally speaking, it's really nice. Yeah.

00:09:42 I totally agree. And that's the reason for SQL I support within piccolo, because like I said, no one's going to run in production. But then it's just that friction less setup, which is so great. Like using Sequel Light asynchronously doesn't really make a lot of sense because you don't really have any network lag top into the database, but it's great to have it in there for convenience.

00:09:58 Yeah. I suspect there may be some people who run it in production in, like, an early, early prototype stage. He just wanted to get something up. And here, Let's just put it up on on some hosting place and just check it out real quick, and then we'll go from there.

00:10:10 Yeah. One thing is quite nice is I used to do this in the design agency. We do Sequel Light for the prototype, and then you could sync it down to your local machine. So you didn't have to do a database dump and reload it. You could literally just sync the file.

00:10:21 There are a bunch of conveniences with Sequel long for sure until it gets to be too much data.

00:10:25 I really want sort of too much concurrency or multi machines scale out and all that sort of stuff. So it's not the final destination, but I do think it's a really interesting and important starting ground there.

00:10:36 Yeah, for sure.

00:10:36 Yeah. So I gave a shout out to two or Ms already, the Jango one and Sequel alchemy. And I feel like those are probably the two big hitters of the Python space, although there are many, many more. So why not just use those? Why go and create the clo?

00:10:51 Yeah. So when I started it, there was no in options for RMS. After all, it was all very new, and my day job involved async programming all of the time because of chat, apps, online games, that kind of stuff. So that was really why I was like, well, nothing really served my need at the time.

00:11:06 Because until recently, Sequel Alchemy had no Async capabilities.

00:11:10 Yeah.

00:11:11 And Jango or more or less still doesn't. Right. That's the final part that they're trying to move to async.

00:11:16 Yeah. So the work around is to run in a fred, but it's just not as performant as running erasing Coyo directly. So there's kind is vacuum for a time with Async RMS. But then it was also about just starting out a blank sheet of paper and thinking, looks like we've got all these great tools to work with. Now in Python 3, 6 and onwards, how can I absolutely push into the limit? So the syntax, it uses a lot of direct references to objects rather than strings. So for example, in jango, you do my table object and then filter and you name equals down. The problem with that is you can quite easily make a mistake as the code changes. So you might end up having a column which no longer exists, so strings can be a little bit fragile. So with piccolo, it's just object references everywhere. So rather than name it's in this example here, it's band name were band is the name of the table.

00:12:04 Right. So like many of the rms, it's sort of class Oop based.

00:12:08 Right.

00:12:09 So you think a class that maps to a table and database, right.

00:12:12 Yeah. So it's one distinct I'd like to make quickly as well. So there's Orms and then query builders. And in python, there's not really too much of a distinction. But in other languages like javascript, the query builders are really popular as like a set part idea to Orms and query builders. They kind of you create a SQL query, you execute on the database, and then you tend to work more with dictionaries and lists and objects. So I'd say that 90% of Piccolo is a query builder, but people are used to RMS in python, and it can actually lead you to some quite poor patterns. Rms, because the first thing people in with Jango is they'll go, my table objects get so it returns an object, and then they'll change the attribute of the object, and then they'll call save. But then that's actually two database queries because have to get it, and then you have to update it.

00:12:55 Well, and it's not just two database queries. It can be a lot of serialization. Like, the slowest part of all of my data stack is if I were to try to go back 10,000 records at a time, it's the deserialization of those 10,000 things that is actually the slowest part of the entire process. And here what you're talking about. You're talking about the band. If the band has tons of information and you just want to change the name. Right. You're pulling all that data back, converting it or whatever, then change the thing and then pushing it back down.

00:13:22 It's a lot of the time. What'll happen is you'll serialize it into an object, and then you'll deserialize it out into JSON anyway. And you kind of is kind of pointless when you think about it. And there's also the problem with objects gang style. So you might pull an object into memory, but then some other user might manipulate all these objects. But then when you save it, you're going to overwrite those fields that have been updating in the database.

00:13:42 So it's problematic. In a way, it is an orm. But then I'd really encourage people to look at it as a query builder. Two because in my own apps I use the Select method a lot. So rather than returning the objects, it returns dictionaries. And then it has this option and output method, so you can just literally serialize it straight into JSON. So this is what makes it fast, because the query is going through Acing pg, which is Super fast. And then it's coming back as a dictionary straight from Acing pg, and then it's using all JSON to stick it straight into a string. So you're kind of you're skipping all this D serialization nonsense.

00:14:14 Yeah. Yeah. This is Super interesting. Now that you pointed out, I'm not used to seeing projections in RMS. What I'm used to seeing is give me back the classes that in this case, a band, do a query like where the popular is greater than 100 or whatever, and give me a whole bunch of bands and objects back, and then I'm going to work with them. But sometimes, like the one I work with most commonly is Mongo engine. I know it's not an Orms odm, but close enough does the serialization bit. And you can say I don't really want the other parts. Just give me the name, like the website or something, and it won't ship or deserialize those things, but you just end up with the same objects that just have none everywhere else.

00:14:49 Right?

00:14:49 Where your you can actually say band Select band name, band, url, or something like that that would return the dictionary with those two things. Right.

00:14:58 Let's write dictionaries probably elicit dictionaries. And then it also has a feature like Jango has this feature which is invaluable it's called Values List. And so if you just want one value back, it'll then condense it down to just a list of values.

00:15:10 I want all the IDs of the bands that play hop music or something.

00:15:14 Yeah. And it's so much more efficient than doing in Jango Banda objects at all, and then looping through to get the IDs. It's just the actual like if your junk for ages, you just learn these little tricks.

00:15:26 Right. Another one that stood out to me is the ability to do set based operations.

00:15:32 When I think of RMS just for everyone listing, I adore orms, I think they're really empowering for people. I think they take a lot of the modern tooling that we love refactoring and allow you to apply that over to your query, because if you wanted to change the casing of band name or you could refactor rename that and it would affect your queries, because that's still Python code.

00:15:51 Right.

00:15:52 That said, there are places ere people either abuse it or it's just inappropriate. So the places where it gets abused a lot would be the N plus one problem, right? That's where you've got a lazy reference to something else, and you don't know that that's going to be a separate query for every time you touch one of those and you get a list of objects back and you loop over and you access. Like in your example, you got band op manager for band band band manager. That could be 101 queries for what should have been one, right?

00:16:17 Yeah, that's a really good point. And even experience. Developers got this wrong because they might use serializes. What you're calling is under the hood on the table, which are triggering sequel queries. So this is another design in 10 behind picolo. Whenever a query is run, it's very explicit. You're literally calling run or run sync. So there's none of this magic. You can't accidentally create an mPLUS one query.

00:16:37 He might actually end up with a co routine or something.

00:16:39 Yeah, it's a really good point because I think mPLUS one is kind of like the scourge of developers with performance and also coming back to your point about RMS. As a back end developer, you can spend hours a day using Orms it's kind of like one of the main tools in that tool belt, so it's kind quite nice to start from a blank sheet of paper and drink. How can I make that experience? Maybe slightly better if I can.

00:17:00 This portion of Talk Python My is sponsored by linode. Visit Talk Python Film Land to see why La Node has been voted the top infrastructure as a service provider by both G two and Trust radius.

00:17:12 From their award winning support, which is offered 24 7 365 to every level of user to the ease of use and setup, it's clear why developers have been trusting Leno for projects both began small since 2,003. Deploy your entire application stack with Node to one click App Marketplace or build it all from scratch and manage everything yourself with supported, centralized tools like terraform, the Node offers the best price to performance value for all compute instances, including GPUs as well as block storage, Kubernetes and their upcoming Bare Metal release. The Node makes cloud computing fast, simple and affordable, allowing you to focus on your projects, not your infrastructure. Visit Talk Python FMLA Node and sign up with your Google account, your GitHub account, or your email address, and you'll get 100 dollars in credit that's Talk Python FMLA Node or just click the link in your podcast. Players show notes and thank them for supporting Talk Python.

00:18:10 The N Plus one problem, I believe, is either there's some tool doing something behind the scenes, youdon't know, but often it's just a lack of understanding that actually is a lazy, le loaded property, which is going to trigger a query. So I should have put a joint and then I'd be in a better place. That's a programmer pattern thing that you should pay attention to and work with. The one where I don't know how to fix it is more like the serialization thing. What if I want to go through my database and go to 10 0 records and make some changes to them?

00:18:39 Often it's do the query loop over the 10,000 things and make a change call save. Maybe it's in one giant transaction that you finally push the changes back, but you're pulling all the data back. And one of the things I really like about your or I'm here is like this update section here where you can do set based operations without pulling the records back.

00:18:58 Yeah. So you can do stuff like so this is a complete weight band and popularity 10,000, but then you can also do band up. Popularity is band up, popularity plus 10. And then in the database, it will then just add 10 to all of the numbers.

00:19:10 Oh, really?

00:19:11 So and then it's all just magic. Upton magic methods. It's just as a library offer, it gives you so much power. It's one of the things I love about python, because when you're building, like, query languages like orms, I think very few languages can really rival Python with its flexibility.

00:19:26 Yeah.

00:19:27 That's really why all this stuff is possible.

00:19:29 It's really neat. And I think the ability to push these changes without actually you're still programming in this Orm classes and the models, but you're not actually pushing a whole bunch of them back and forth to make the changes. But to do these set based operations, like delete them where or make this update to this value where this is true, and then just push that, make that happen in the best way you can of sequel, right?

00:19:49 Yeah, exactly. I think going back to point around the N plus one, I think properties or something that can be a little bit evil, and I've really shy away from them in the Piccolo code because you call the property and you think you're getting a value back, but it could be doing any kind of magic. And then once you define something as a property, you then calm add arguments to it without breaking your API. So in that that's something I tried to steer away from in general, Piccolo at properties.

00:20:13 Yeah. A lot of hidden start hanging that round. It's not entirely clear. I think they're Super useful, but certainly in something where I thought I was accessing a field of the class, but what I actually did is make a network call. That distinction is possibly too big of a bridge to just make that automatic. A lot of the times.

00:20:30 Yeah. There's no async properties in Python as well. So that's kind of one of the reasons why it doesn't use any async properties.

00:20:36 If they are, it maybe I'll put a comment on the pep, so don't do it.

00:20:40 Yeah, exactly. Another thing that's interesting. Here is on all this code, every code you've written is a wait and Select or wait and delete, and so on or update. And then at the end you say run. This is the explicit part that you're talking about in your API. Like, I know Here's where it's happening, and it probably makes a lot of sense to do that as well, because on the flip side of it, that's where you have to wait it anyway, right?

00:21:03 Yeah. So what happens is you build up this query, you just train methods to it, and then at any point you can print out that object, then I'll give you the sequel until you it, and then until you've actually awaited, there's something under hold that don't only publicize. You don't need the dot run. If you wait, it will run as a convenience because people forget. But then it just makes it easier, from a documentation perspective, to say when it's async, use run and when it's synchronous, use run sync.

00:21:26 Right. And then if you do run sync, then I've got a bit of magic in there where it tries to create an event loop to run it, or it tries to figure out if there's already an event loop. If there is run it in there. So you can use Piccolo in an old school is if you wanted to just a synchronously. Yeah.

00:21:42 Well, Let's dive into that, because that's one of the things that really stood out to me. Many frameworks or API's packages tell you you're going to either have to go. You take a fork in the road, you're going to go down the Async fork, and you're going to use the Async library, like HTTPS. Are you going to go on another fork and you're going to use the request library that has no async, and you're going to go down that path and you choose, and then you just go, and with piccolo, you can actually run. I guess the default behavior would be to be a sync. In a way, it has this run sync, which will kind of cap where the Asynchronous behaves and goes. And it just that you could run it in a regular Flash app or Jango app or whatever and not worry about it being async at all. Right.

00:22:20 Yeah, that's right. And it's actually one of the design challenges. Re Picolo is, how do you create an api, which is synchronous and asynchronous? And there's only really two ways of achieving it with a method like run or run sync or with context managers. So some of them you create have an Async context manager or synchronous, and then that'll an impact, whether the underlying query synchronous or not, then it adds a little bit more boilerplate. Every time you want a query, you need a context manager to tell it to be async. So this is kind of the best outcome I could think of was just how to run run sync.

00:22:50 I think this is great, especially since even if you forget to run, it'll still run a sync, but there's a way to kind of cap it. So something I wanted to talk about, it's driven me crazy ever since Async and a weight were introduced, because I don't find it to be true, but I hear it all the time. Spoken about in the community is async. In a way they're Super neat, but they're like viruses. And in the sense that as soon as one of your functions way, way at the bottom has to do something async well, then the thing that calls it has to be async and await it. And the things that call that function now all have to await it, and that percolates all the way to the top of your app. And so now, by using any Async library, you turned your entire thing into this, like Async vertical call stack.

00:23:28 Your example here shows that that's not it doesn't have to be that way. That's sort of the naive. I'm just going to write the code without thinking about it. But if you wanted to say have your data access layer do three things, he's got to pull some stuff from different places. You want that to be async. It doesn't mean that function has to be async. It could just start its own event, do the three things faster than without it, and then return the answers. Right. You can kind of cap it at any level that you want, and your run sync is kind of an example of that. You can choose to not have it, just turn your entire app async.

00:23:57 You can jump between them. Typically, if people use an async, then it's like the argument is, if you need async, your whole app probably should be async, because otherwise why you use an async, but then you can flip between them quite easily. So if you've got a Synchron up and you want to cause a Mason code there's, asinkayo run, and you can also do stuff like spin up an event loop in a different threat and then send work to that.

00:24:17 Yeah, absolutely.

00:24:18 It is quite fluid. You can flip between them quite easily.

00:24:21 I mean, just one example that comes to mind is what if I wanted to go web, scrape every page at a certain domain? So I've got a function that gives me a domain, give it a domain, and then I want it to return or store into the database all the pages.

00:24:35 That would be perfectly reasonable to have that thing go. Okay, well, Let's do a request to figure out what all the pages are and then just recursively, sort of grab them all asynchronously. You would get a huge boost on getting every page off a site, even if that function blocked. You know what I mean? Because it itself could just go crazy against the server. Maybe it shouldn't, but it could.

00:24:52 Yeah. I mean, he's trying to asinkayo gaffer as well. So that's a really beautiful API just for saying, do these 50 things now, please, and let me know when they're done.

00:25:01 Yeah. In black, right. When you're done, give me a list of answers or errors.

00:25:05 Yeah.

00:25:05 Also out in the livestream. Chris me. Hey, Chris says I'm so excited to use Pickle with unsync. Have a workflow that'd be nice to paralyze. Yeah. I think Unsync is another really interesting library that wraps up async IO plus threading plus multiprocessing, but then gives you a nice way to cap it as well, because you can go be given a task that comes back from there if you just ask for the result and it's not done, it'll just block like a regular thing, and it does kind of what you're talking about. It has a background thread with its own event loop, and it just pushes all the work over to.

00:25:36 There a pool library.

00:25:39 At least for the size, like 126 lines, and it unifies those three APIs and add some more stuff. That's pretty big bang for the Python bite.

00:25:47 Yeah, that's impressive. I wish Pickles up to us, I think comparing to the thousands, tens of thousands of lines by now.

00:25:54 Yeah.

00:25:55 So another one of the new Python 3 6 on Word type of thing, so it's really cool. Is the type annotations?

00:26:02 Yeah. I love type annotations. So part of my day job in the past was using swift, and Swift is almost like pythons, like brother or sister. It was very heavily inspired by Python.

00:26:11 It's like if Python all of a sudden decided it was incredibly strict about typing and type definitions.

00:26:16 Yeah, it would be a lot like swift, right? It didn't work.

00:26:19 Invited? Yeah. It's a combination of type annotations and the tooling to support it. So in Pythons case, it's Vs code, and in Swift case, it's X code. And it just means that when you're refactoring, it just makes it so much more confident about what's going on.

00:26:31 It provides documentation because previously people were putting it in a Doc string anyway. So why not put it any function definition and then you can introspect it and my pie. Since N o be powerful, I honestly don't think I could have built Picolo without type annotations because it makes you code so much more. Maintainable the click to go to Vs code as well. It's just a beautiful usability improvement. And then kind of one of the hidden benefits is it makes top completion so good. Yeah. So a lot of Python auto completions. They use a library called Jedi under the hood. So when I was building piccolo, I had to look at the source code to try to figure out how it does its magic. And if you give a type annotation to something like, this is what this function returns. It's a really strong indicator to Jet that this is what's going to get returned. I don't need to do any magic anymore.

00:27:12 I would say that huge half the time. That's why I do it as to make the editor better. So both of us go to MPI charm, take a good look at what the type annotations are.

00:27:21 Right?

00:27:21 You'll say, oh, you're trying to pass a string, and that's really supposed to be an integer, but then also, like you say, tab completion or autocomplete all over the place. It's fantastic.

00:27:29 Yeah, I finished a distinct nas. Well, where I think if you're building an application, Let's say you're building a Jango app or a Flask cap, you don't need to care quite as much. Like I personally would still have type notations, but for libraries I think is absolutely essential. I don't have any new Python library should be written without it because you're kind of short changing your users in a way.

00:27:46 Is there an I totally agree. It's worse in the Flask app, for example, that you've mentioned, I would say, on the boundaries right here's, a data access layer. Put type annotations on those little bits there, and then the rest of the app. Usually the Editors and the tools will just pick it up and continue to tell you what you're working with. Yeah, but if you're doing a library right, you want every function or every class to be kind of stand alone and know everything it can.

00:28:09 Yeah, definitely. And one more thing about type annotations is it's probably the greatest source of interview questions ever made, because you can ask people in an interview what's the difference between a sequence and iterable. And when you use type annotations, you really start to think about what's going on. And it's a great learning experience, too.

00:28:24 I want to pass a generator here, but it takes a list of things and it says that won't work. Maybe you just need to relax your type annotations to an iteration type of thing. A quick question from Roller other N Livestream her roller, can you just pick a lot and place a mango engine? Or is it just for a relational stuff?

00:28:41 Yeah, it's just relational and you can use sequel light locally, but it's mostly Postgres. It was really built to take advantage of Postgres because Postgres. It's like the fastest growing SQL database in the world, which is remarkable to think it's how old it is. Yeah, I think adding over SQL databases would be quite easy, but adding some of that Mongo would be a bit trickier. I wouldn't say it was impossible, but a bit more work.

00:29:03 Yeah, I would think So. Yeah, it's not certainly not impossible, but joint and stuff would get tricky.

00:29:07 What about SQL injection? I mean, many of us have heard about the little Bobby tables xkcd, which is delightful sort of shot and Freud a sort of way.

00:29:16 We all kind of do a relation, somebody else suffering this. But I find that this is actually one of the really nice things about our most of the time is that they scrape off the ability to do sequel injection because you're not building the sequel.

00:29:30 Yeah, definitely. So they face it out. So something like Acing PG or Psycho PG in the synchronous world, what you want to do is you want to pass it the query string with placeholders for any user submitted values, and then you submit the values that separately, like in a list, right.

00:29:44 Like a program tried query, basically. Yeah.

00:29:47 And as long as you do that your safe. But then for a library, when people are programmatically creating very complex sequel queries, and then you need to try and make sure that you've got the right values that match the right place holders, the paste, the adapter. It is quite challenging. There's some recursive code where it has to, so we use them a query strings internally. We've been piccolo, so it never concatenate strings for SQL statements, just it uses query strings, and then it compiles them before sending it to the database adapter. And it basically looks through all of the sub query strings it might have if it's a really complex query, and then it kind of passes it to the adapter. But yeah, it's just one of the complex things about building rms, for sure. And also one of the most dangerous to get wrong.

00:30:25 Yeah. Yeah, it absolutely.

00:30:27 Is.

00:30:27 There's untold number of bad things that can happen as a sequel injection, and it's so easy. All you have to do is put a single little tick to comment out stuff semicolon finish that statement, and then you can run arbitrary code, and a lot of times as you can, even some database instance will let you run subprocess type things, which is even worse. But yeah, it's not good. So you definitely want to avoid him.

00:30:47 Yeah. It's a good ultimate fusing Orms and query builders, because it'll make it less likely.

00:30:51 I think for sure. Another thing that I wanted to touch on a little bit here is the actual filtering or projection statement type bits. So I mentioned using Mongo engine before, which I'm a big fan of, and it's basically a Mongo equivalent of the Django or so in that regard, they're real similar. And you do things like, if I wanted to say where the band popularity or Let's say the band name is Python estas, you would just say name equals. Python ESTAS has part of the filter, and there's two things that are crummy about that. One is you get no autocomplete that there's a column called name because it doesn't really know what class. Even though you started out like band at objects in the filter part, it no longer knows that the name came from the band, right? That's not part of the language. And then the other one is you're doing an equals, or you've got weird operators in the name name n underscore underscore GT for greater than and stuff like that, whereas yours, you just write what you would put into an If statement or a loop or something like that. So you would say, like, band out popularity less than a thousand. That's the thing you send in there.

00:31:51 Yeah, that's right. So I've been shipped up so many times in the past odango, where I've had something like name double underscore something else, and then it can't really understand that's wrong. Like a Linter while you're coding, only renews a runtime, and then you've got a 500 error. So the idea here is a Linter would be able to pick up these problems.

00:32:10 Exactly. Because so much of the pieces are they're just doing Star Star wars, and then they figure out how to generate a query out of looking for special keywords and the key names and then turning those columns. Also, the refactoring thing. Right? The lunches. And if I want to do a refactoring to rename popularity, it's not gonna check popular underscored GT as a keyword argument. It has no idea those are related.

00:32:32 Yeah, definitely.

00:32:34 So the way it's implemented the calls and all these operators is the amazing things about a Python is how you can just overload fundamental things about the language. So you can overload what addition means. And when someone first tells you that it sounds like the most mental thing in the world, because why would you want one is 1 equal five. But then it turns out when you're building an rm, it's gold. And this is one reason why I find Python just so compelling over and over again is because as a library offer, you can do this stuff that you can get closer to more of, like a dsl, then like a norm program in acidic language.

00:33:04 Yeah, absolutely.

00:33:05 Yeah. So if this be done with Descriptors or what's the magic for the less than there's done double under school lt, and you can override that. And then what happens is when you call that method, it returns a war object. And then you can also you could do brackets stand up, popularity less than a thousand and then double and sign as well. And popularity greater than 500, so you can combine them with and in all statements. So the war statements in Pickle can get really powerful.

00:33:30 So you just have to teach the war clauses how to end and then structure it in a way that Python will let it kind of go through. Right?

00:33:37 Yeah. Or you can do were same stuff and then end up at West statement. If you've got multiple West statements, it becomes like it's an and. Yeah, but yeah, it's just all Python magic, which is one of the reasons I love Python.

00:33:48 Yeah. Speaking of overridden things, the thing that I think is the most insane, but I'm starting to love, but took a while to get used to is the way the path object works for defining path. To be honest, the forward often means drive separation on the POSIX systems, and it's close enough. You could actually put forward slashing your strings and Python on Windows. And it'll still like you I Fi and backs what you meant. So they overrode the divide operator in code to allow you to concatenate strings and paths together. And that's just crazy. Yeah.

00:34:18 The first time I saw I was very confused, but when you understand that, it's okay, But. Yeah, totally.

00:34:23 Yeah, Yeah.

00:34:24 I've got okay with it as well. And I start to use it, and I really like it now, but I was like, I don't know if I can get behind. This is a bridge too far. That's division. What are we doing here now? It's cool.

00:34:34 It's talking of magic. So pick load all around using meta classes a lot.

00:34:39 There's something that got added in. I don't use Python 3-7-0-3-6, but they actually changed meta classes slightly. So there's now, like a Dunder magic method called in it subclass. And Piccolo uses this a lot. And it's actually an amazing hidden feature of Hyphen were you can now add keyword arguments to a class definition. So if you had class to open brackets inherit from bar comma, and then you can start adding keyword arguments to the class to customize its creation. And that's kind of like a new layer of magic that's been added to Python recently, and Picolo uses it extensively, but I don't see many of a are using it. Yes, it's probably not so well known, but we just kind of spread that bit of magic, so hopefully people can use it too.

00:35:15 Nice. Yeah, that sounds awesome. I can certanly see how I'm trying to create the classes, like the band class or whatever you say that it's going to be would definitely use that. So one of the things that you say is autumn about Piccolo. Is the batteries included?

00:35:27 So Let's talk about some of the batteries.

00:35:30 So the main battery, by far, is the admin, because when I started it, I was working for a design agency. And Admins are incredibly important for design agencies because you want to put something front of a customer that they like the look of, and they're comfortable using. So this is a huge part of the effort that's going to Piccolo. And so it's just a project called Piccolo Admin. And what happens is it's an ask app. So I can maybe go into more detail about Abe later on, but all you do is you give it a list of Piccolo tables, and then it uses Panic. So Pedantic serialization library. And it basically creates a Pedantic model from the Piccolo table. And then Pedantic models have this really useful method where it's JSON schema. And it creates a JSON schema for the Pedantic model, right.

00:36:09 As if by tender classes. Now this field is an end to this one is an optional date time, and so on.

00:36:14 Yeah. So Piccolo has really good Pedantic support, but it's in a sister repo called Pico API.

00:36:20 So that creates the Pedantic model. And it also has some call pillar crowd. So you give it a Piccolo table, and it creates an overage app which has got all of the operations for your database. So you can programmatically create a huge API just by giving it a few tables. And then the front end is written in ujs, and it's completely decoupled from the back end. It's just all by API.

00:36:39 A huge trying to is because it's very natural for Python developers who used to templates syntax in Jango and Flash. If you looked at the few templates you below, this looks very familiar. So a big fine.

00:36:49 That's nice. Yeah. I think it's Super expose to Camilion cause the attribute driven behavior as well. Yeah.

00:36:54 But then to make a working admin requires so much work because you've also got a security side. So Piccolo API has a bunch of really useful asking middleware and has session authentication, CSRF protection, and rate limiting as well, because you don't want people to spam the login. So just to get a fairly simple admin, it's like an iceberg to do it properly. So a lot of efforts gone into the admin, but I'm really proud of it. And this is really what excites me more than anything about the future, because as we have support for posts and stuff like that, being able to create really interesting widgets around data. So how can I design a rectangle field for post GIS or a location field?

00:37:30 Or I could see some really cool stuff that are sort of template extensions, like, Let's just pick ginger, for example, if you had one of these objects, you could pass it over or an it new. For example, Here's a daytime you could just say make a calendar picker.

00:37:43 And it just long as you have the JavaScript included. Instead of just putting the text, it gives you a nice little Ajax widget.

00:37:50 This list goes on a map drop in the map widget and offices.

00:37:54 Yeah. So basically Pickler admin. It just turns Pedantic models into UI. And it's actually quite interesting. And I'd love to get it to the point where for a business app, you just use Pilar admin. You don't even have to build UI. You just say, here are my tables.

00:38:07 And then, well, the truth is so often, and there's a lot of these internal apps that people build that are just like forms over data. I just need to see the details, click on one, edit it, create a new one, and delete one. And that's the app I need for this table. Would you build that right?

00:38:21 Yeah, for sure. It is a lot of it, because I think the approach I talked picolo, you have a lot of Python libraries, and they kind of start from the outside in. So they start from the URL layer, and then the views and middleware. And then over time, they then add the data layer and the security. But then with piccolo, it's kind of from the inside out. Like, I started from the data layer and then at the admin and some Middle west, it's quite an As companion to ever ask. So just kind of pick the framework you like, and then Pico kind of gives you the data layer. And the admin was kind of.

00:38:47 Yeah, talk about the Ask stuff a little bit because you did mention that there's some interesting support for those things, and it's got to some degree native Fast api, Flask and even Black sheet, which is an interesting one support for those frameworks, right?

00:39:02 Yeah. So I'm a huge fan of Ask because I was a Jango Channels power user, and Andrew Godwin created Aski out of Jenga Channels.

00:39:09 It's really like a beautiful thing if you look so Starlet was the one that really built a Foundation. So this is an Async library, but also kind of like a framework. You can build an app starlet, or you can use it to build up framework. What's amazing about ask? It's like every component in an Aski framework is ask. Ask is basically the spec where it's a function that accepts a scope, a send and receive. And then if you look at the internals of starlet, everything's ask, like the Middle west, ask, the endpoints are Ask like the whole thing. And it's like Super composable. So you can say I've got an Asian. You can out of Roski apps within it. So this is what I love about Asking as a spec. So you can take a Fast API app or style app and include Piccolo admin. Same with Black Sheep.

00:39:49 You could say a catalog is actually handled by this other app written in Fast API where the mining is written in Flask or something like that, and you just kind of click them together in that core. Maybe Core would have to be the one, but still.

00:40:00 Yeah. And I really love that it's quite exciting that you could kind of build an app for multiple frameworks and be like, well, this part of the app would be better by Fast api, but this bit St need Star loop. So I want Black Sheep or whichever Aski framework people can dream up. So I think it's really exciting for the Python community, the ASCE spec.

00:40:17 And we did talk a little bit about the challenges and the cascading effect of Async and await. But if you're already running in a framework that has Async view methods, there's just nothing to it, right? You just write your code and you just wait the bits. You gotta wait in the view method. And it just like the server and the framework handled the Vent loops and all that business.

00:40:34 Yeah. I think as well, what kind of happened is asinkayo came out and it doesn't direct Ly tech speed. It's more about report, but it's like the Python community took it as a challenge to build faster frameworks. And so a lot of them have really quite fast internals, and they do feel quite cutting edge.

00:40:50 Yeah. Like UV loop and stuff like that. They're like, how can we do this, but have the minimal overhead of adding this? I mean, people do talk about okay, async and await won't make your code go faster. Well, you won't make CPU code go faster, but so often what we're doing, especially in web apps, is waiting. I want to wait on a database and then wait on the network, and then I want to wait on the database again, and then I'm going to wait on an apr, and then I'm going to send back three line to JSON. Right. Like, 99.9% of that is just waiting on something else. And when you're using Async in a way, like, you can just do other things while you're doing that. 99% of waiting.

00:41:19 Yeah. So usually the database query, it takes a few milliseconds. But then if you use the time at module in Python and you see how long basic operations take, they're more like microseconds. So is orders of magnitude difference and how long a database query takes to basic Python stuff. But this is why I'm having stuff like Ud loops really important, because if you had a really slow event loop, I kind would make much difference. But because the event leaves fast as well. And a lot of the projects that did in the past, the Freeport is really important because some apps, you don't have a lot of traffic, and then all of a sudden you'll get 1,000 users. So I still like live events, and you get 1,000 people at once. And in that situation through Port is incredibly important.

00:41:54 I mean, look at how the whole healthcare roll out in 2,008 when I just can't help. I think there must have been more weights available to those frameworks and those web apps you just kept crashing and stuff was timing out. And I'm sure it's just like, well, we're just going to wait on this other slow government, a an api, and we're going to do it for a lot of people, and it's just going to overwhelm it, right? It's crazy.

00:42:13 It just is natural, because, like, in the web server world, you have apache, and a lot of people move to Engine X that's based endless, like, event loop driven. And we've kind of seen how beneficial Engine X was. So it just makes perfect sense to build your back end in the same way.

00:42:25 Yeah, absolutely. Absolutely. All right. A couple more things we've got some time to talk about over here.

00:42:30 You've got a Jingo comparison page, which I guess also could be slightly a Mongo engine comparison page, because like I said, they're basically the same thing without the nesting.

00:42:39 So if somebody is familiar with Jango and they're like, I would like to consider using this for my framework, for part of my code or whatever, but they already know how to do stuff in jango. You have like, well, Here's how you would create an object and save it in the different frameworks. Here's how you would update an object and make changes and so on. And you can just go through one at a time and just sort of compare the different pieces.

00:42:59 Right? Yeah.

00:43:00 It's quite heavily inspired by jango. But then I think Jango in storm, it's more pythonic. So rather than using where it uses filter, but then with piccolo, it's meant to be very close to sequel, as the fairy is. If, you know, sequel, it'll be Super easy to learn. And when you do need to drop down to a sequel query, there's no mismatch. You just like, well, I'm always sort of working in a sequel mindset, but there are a lot of similarities with jango. Still, I think people could pick it up quite quickly.

00:43:24 Yeah, I agree. Instead of object that values list, you have a select projection, or instead of filter, you have aware, but it's honestly not a huge mental jump to make.

00:43:33 Yeah. And ticular also takes huge inspiration from Dragon migrations, which I think is kind of like the goals a standard of migrations in any language. So a lot of efforts gone into that. Yeah.

00:43:43 That's another one of the batteries that you are kind of touching on. Right. Is the migration bit.

00:43:48 Yeah.

00:43:48 It's migrations are incredibly hard to do. Right. I think the Jango way is I can only imagine.

00:43:53 I don't even want to try to imagine writing that because it seems really hard.

00:43:57 Yeah. So the way change does it is it looks at your tables, and then it creates a migration file. It then adds up the migration files to build a picture of what the schema looks like. And then that's how it then create subsequent migration. I do in a day.

00:44:09 That's why I've got to go from this level to that level. So Here's the five migrations to basically use in order.

00:44:15 Yeah. And then you've got to do code generation as well. So we pick low has to actually create a Python file, and that's hard. And what it seems actually writing a Python file. But if you look at the Pico migrations, they're actually really look like quite beautiful PTO code. And there's a little trick I use internally. I use the black form matter on it before I write out the auto generate code.

00:44:32 Oh, that's cool. So your generated code as pipe in all the goodness.

00:44:36 Yeah. So if you look at it, you're like, oh, that's quite nice.

00:44:39 That's clever, actually. Yeah, that's really clever.

00:44:42 Yeah, it's cool. Black. Yeah.

00:44:44 I feel like other frameworks, like, for example, the cookie cutter stuff. You're just generating code files like crazy. I feel like you could apply that same technique is after we inject all the user enter values. Let's just do a quick format on them and then drop them.

00:44:56 Yeah, it makes sense, because otherwise you'll run your linters on your project and they'll fail because your migrations aren't correctly formatted.

00:45:02 Yeah, that's cool. A quick question from Teddy out in the live stream says I don't use arms much in my data day day. What are a good use case Besides web apps for them? And where is piccolo? Or better. So it's a question.

00:45:15 So I think that data science is obviously a big bit. So another reason for building Piccolo is data science is so much on the Ascendancy in the Python world, and people are just still dealing with database on a day to day basis. So you can use it in a script if you like. And there's maybe a couple of examples in the docs where you might be scraping some data from a website, and then you just need to stick into Postgres. So that would be another good example for using Piccolo.

00:45:37 Yeah, that is a good example.

00:45:38 And then where it performs best. So it's really way you need the async. Or you might still want a web app component. Even if it's just like a data science script, you still might want an admin screen to view that data.

00:45:49 Yeah, I think that performs better. You could maybe break into two pieces. Where does speak a lot perform better. And I think the Async stuff is really important there, like you say. And then where does an Orm perform better? When you talk about performance and getting stuff done, sometimes it's how fast does the code run, but sometimes it's how fast do I get the final thing built? And I think, Orms even if they're not always the the most efficient way, sometimes they're really ficient, but not always, but they can help you safely get to the other side, especially if you don't know sequel super.

00:46:16 Well, yeah, they hold your hand a little bit. I created this while working at design agencies, and speed is really important design agency, not really execution speed in terms of sequel queries, but in terms of scaffolding an app and being defective. So it's Piccolo hashing called Piccolo asking you and then to use that command that will basically scaffold your web app. So it supports fast API style black sheet.

00:46:35 That's really cool. So you just kind of create your starter code and your starter or structure from that, right?

00:46:40 Yeah. A bit like with jango, where you create a project on the command line, but with piccolo, you get an option of different Ask frameworks. And over time I'd like to add way more because there's many more exciting Ask frameworks, like Cars sanic. Jango itself is actually an Ask app, so you could support Jango changes come along.

00:46:57 So if people were out there listening and their favorite framework wasn't listed in one of those three, or was it one of those three PRS are accepted, I guess, and they could integrate there their favorite Sanic or whatever they're after.

00:47:09 Yeah, definitely. Any feedback's really appreciated. So the community has definitely helped me a lot of Piccolo just as much as trying it and giving feedback or use pull requests are also really valued. Even if you just want to raise an issue to say, why the hell did you do this like that?

00:47:23 That's still welcome.

00:47:24 Yeah.

00:47:25 Awesome.

00:47:25 Well, maybe that's a good place to talk about where things are going in the future and kind of wrap up or a conversation a bit.

00:47:30 Yeah. So I feel like I'll never be bored with Piccolo because Postgres is continuously developing and adding new features. And I almost feel like Postgres is almost like an operating system in a way. Like, the amount it does is kind of insane. So it even has, like, a Pub sub built in. You can do that. Listen, notify.

00:47:45 Wow.

00:47:45 I'd like to do Post JS support timescale DBS are really up and coming extension as well for Postgres for time series data. But then a lot of the stuff I'm excited about is, like on the admin side. So as I mentioned before, Picolo admin effectively turns Identi models into UI. So the next thing I want to add is you can basically give it arbitrary pedantic models, and it will render them as forms and the admin. So if you have, for example, you want to send an email mail, you'll just create send email model. I'll give it to a Piccolo admin, and it'll generate a form. That's stuff I'm really excited about as well. Just to increase the utility of Piccolo admins, a back end developer who could build a functional app for business, we've got actually writing any code. That's kind of the dream is to build a really, really great admin.

00:48:24 Yeah. Yeah. These self serve once you create the app and hand it off, how far can people go before they have to hire your design agency again or something like that? The more that they can just run with it, the better, I suspect.

00:48:36 Yeah. It's such a huge benefit from jango, like having that admin. So I just want to kind of see what I can do with the latest technologies to build a really great one.

00:48:44 Yeah. What's the story with Jango and piccolo? Is there a reasonable way to click them together, or is it really not so much so far?

00:48:51 I think you can. I haven't really tried it much, but it's very configurable piccolo, and none of the names. They deliberately don't clash with jango. So Jango has a Settings py, Piccolo has a Piccolo underscore Com stop pi, and then Jango has a migrations folder. But Piccolo has Piccolo underscore migrations, so there's no clash there. So in theory, they would work together, like compatibility layer between the admins. So you'd have two separate admins, but I'd like to have support the Jango as it is an Asia and it's the originator of the Ask Standard. And I still think Jango is one with great kind of masterpieces in the framework world. It's lasted so long and it's still such a rock solid choice. I would like to see what I can do there.

00:49:27 Yeah, the closer those could be. I think this having the Genesis and so many similar ideas to jango, it seems like they should be somehow working together, which is great.

00:49:35 Yeah, that'd be cool.

00:49:36 All right. Well, dan, I think that might be about it for a time.

00:49:39 Hat we got. Let me ask you the final two questions that I always ask. If you're going to write some code, you can work on piccolo, what energy do you use? I think I kind of hint of it earlier, but go ahead.

00:49:47 Yeah. Vs code all the way. I was a huge sublime text and TextMate user and I thought I'll try out this Vs code, see what all the hype is about. After five minutes, I was never going back. I just think it's such a great gift to the world for Microsoft.

00:49:59 Just gets better and better as well. I love Vs code right on.

00:50:02 And then notable Pipey package you want to give a shout out to.

00:50:06 So I'm going to cheat and pick two. So Pi danti, because I think it's it's such a nice serialization library, and I think it could almost be in the standard library. It feels so Pythonic and natural and then Starlit because I think it's just a beautiful Foundation for the Ask world. And I really encourage people to look at the code to see the power of asking how it is this like turtles all the way down. Everything's asking it is quite interesting. So those would be my two shout outs.

00:50:30 Yeah, very cool.

00:50:31 Fast API is so popular now, but Fast API is kind of like an opinionated view on top of Starlet to a large degree, but like the same wel. I mean, it takes the two things you said Panda and Starlight and put them together in a nice way, which I think is pretty neat. Yeah.

00:50:45 It's all great taste.

00:50:46 Yeah, for sure.

00:50:47 I just like to say one thing really quick and just. Yeah, thanks to everyone who's contributed Picolo because there's been people who've been contributing for several years by this point, and he put a lot of working. So just a shout out to anyone in the Piccolo community. Yeah.

00:50:58 And final call. Actually, people are interested in using this. It's good to go. It's ready for production, web apps and all that kind of stuff.

00:51:04 I didn't really want to promote it before it was ready, and I use it in production have done for years, and I'm quite conservative about pushing stuff out there. Unless I think it's solid. It's got hundred unit tests. It's solid. I'm not saying there's not some edge case I haven't discovered yet in some version of Postgres or something, but I use in production every single day.

00:51:22 Well, Congrats on building a really cool atonic OR. I really like the way that you put things together and looks great, but a lot of nice modern Python features, and people should definitely check it out.

00:51:33 Cool. Yeah. Thanks a lot, Michael.

00:51:34 You bet to you later.

00:51:36 This has been another episode of Talk Python to me.

00:51:39 Our guest on this episode was Daniel townson, and it's been brought to you by La Node in us over at Talk Python training, and the transcripts are brought to you by Assembly AI.

00:51:48 Simplify your infrastructure and cut your cloud bills in half with nodes. Linux virtual machines develop, deploy, and scale your modern applications faster and easier.

00:51:56 Visit Talk Python FMLA node and click the Create Free Account button to get started.

00:52:02 Transcripts for this and all of our episodes are brought to you by Assembly AI. Do you need a great automatic speechtotext api? Get human level accuracy in just a few lines of code. Visit Talk Python FM Assembly AI when you level up your python, we have one of the largest catalogs of Python video courses over at Talk Python. Our content ranges from true beginners to deeply advanced topics like memory and async. And best of all, there's not a subscription in sight. Check it out for yourself at Training to Python FM. Be sure to Subscribe to the show, open your favorite podcast app, and search for Python. We should be right at the top. You can also find the itunes feed at itunes, the Google Play feed at play, and the Direct RSS feed at RSS on Talk Python Film. We're live streaming most of our recordings these days. If you want to be part of the show and have your comments featured on the air, be sure to Subscribe to our YouTube channel at Hawk Python Film YouTube.

00:52:57 This is your host, Michael Kennedy. Thanks so much for listening. I really appreciate it. Now get out there and write some Python code.